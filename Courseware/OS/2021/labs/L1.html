<!DOCTYPE html><html class="h-100">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link href="../../../static/css/base.css" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.font.im/css?family=Source+Serif+Pro%7CLato%7CInconsolata" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="../../../static/img/favicon.png" type="image/x-icon">

  <style>
    .font-sans {
      font-family: 'Lato', 'SimHei', 'STHeiti', 'SimHei', 'Serif';
    }
    .font-serif {
      font-family: 'Source Serif Pro', 'Songti SC', 'SimSun', 'Serif', serif;
    }
  </style>
  <link rel="stylesheet" href="../../../static/katex/katex.min.css">
  <script defer src="../../../static/katex/katex.min.js"></script>
  <script defer src="../../../static/katex/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
  <script>
      document.addEventListener("DOMContentLoaded", function() {
          renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            // • rendering keys, e.g.:
            throwOnError : false
          });
      });
  </script>


  

<style>
.article {
  -webkit-hyphens: auto;
}
form {
  margin-block-end: 0;
}
img {
  display: inline-block;
}
code { font-size: 85%; }
pre {
  font-size: 95%;
  line-height: 120%;
}
blockquote {
  font-size: 95%;
}
p {
  font-size: 105%;
  text-indent: 2em;
}
li {
  font-size: 105%;
}
blockquote p {
  text-indent: 0em;
}
.float-right {
  padding-left: 10px;
}
.float-left {
  padding-right: 10px;
}
a {
  color: rgb(29 78 216);
}
strong {
  font-family: 'Lato', 'SimHei', 'STHeiti', 'SimHei', 'Serif';
}
.box        {
  border-radius: 2px; padding: 1px 4px 2px 4px;
  font-family: 'Lato', 'SimHei', 'STHeiti', 'SimHei', 'Serif';
  font-size: 95%;
}
.box-blue,  .badge-primary  { background-color: rgba(66, 139, 202, 0.5); color: #1d4ed8; }
.box-green, .badge-success  { background-color: rgba(92, 184, 92, 0.5);  color: #15803d; }
.box-red,   .badge-danger   { background-color: rgba(217, 83, 79, 0.5);  color: #b91c1c; }
.box-yellow,.badge-warning  { background-color: rgba(240, 173, 78, 0.5); color: #a16207; }
.box-gray   { background-color: #a0a0a0; }

.badge {
  padding: 1 4 1 4;
  display: inline-block;
  border-radius: 0.25rem;
  border: 1px solid;
}
.message p {
  text-indent: 0em;
  margin-top: 1px;
}
.message h1, h2, h3, h4, h5 {
  font-family: 'Lato', 'SimHei', 'STHeiti', 'SimHei', 'Serif';
}
.message h2 {
  font-size: 120%;
  margin-top: 5px;
  margin-bottom: 2px;
}
.message li {
  list-style: disc;
  margin-left: 2em;
}
li > p {
  text-indent: 0em;
}
block-quote h4 {
  float: left;
  display: inline-block;
}
.center {
  display: block;
  margin: auto;
}
hr {
  margin-top: 20px;
  padding-bottom: 20px;
}

.fa-gradient {
	background: -webkit-gradient(linear, left top, left bottom, from(rgb(99, 27, 103)), to(#333));
	-webkit-background-clip: text;
	-webkit-text-fill-color: transparent;
}

</style>


  <title>L1: 物理内存管理 (pmm)</title>
</head>

<body class="d-flex flex-column h-100">
  
  

<div>

<div class="px-2 py-1 w-full fixed z-50 bg-gradient-to-r from-black via-purple-700 via-purple-500 shadow-lg" style="-webkit-backdrop-filter: saturate(150%) blur(4px); backdrop-filter: saturate(150%) blur(4px)">
  <form>
    <a href="../../../index.html"><span class="text-lg px-2 text-white">Yanyan's Wiki</span></a>
    <a href="../../2023/index.html"><span class="text-sm px-2 text-white">操作系统 (2023)</span></a>
    <input maxlength="9" id="token-input" class="float-right appearance-none border border-transparent px-2 py-1 w-20 bg-white text-gray-700 placeholder-gray-400 shadow-md rounded text-xs focus:outline-none focus:ring-2 focus:ring-purple-600 focus:border-transparent font-mono" type="text" placeholder="TOKEN" oninput="login();">
  </form>
</div>

<div class="article container mx-auto md:px-8 lg:px-8 xl:px-8 2xl:px-8 shadow-lg border pb-8 pt-10 max-w-screen-md text-justify divide-y-2 divide-white">
  <div><h1 id="l1-pmm" class=" text-2xl mt-2 font-sans">L1: 物理内存管理 (pmm)</h1>
<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="_1" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-red" style=" padding-bottom: 0;">⚠️ 难度警告</h4>
<p class=" font-serif my-1">并发编程比想象中困难——尤其是 Online Judge 的测试用例相当强。请仔细阅读实验要求和正确性标准，确保没有误解实验。不要拖延！！</p>
<p class=" font-serif my-1">关于实验环境设置、提交方法、评分规则等，请阅读<a href="Labs.html" class=" text-amber-900">实验须知</a>。获取代码后，在 <code>os-workbench</code> 中执行 <code>git pull origin L1</code> 下载代码。由于 kernel 目录将在后续的操作系统实验中使用，<strong>本次实验提交时，需要设置环境变量 <code>MODULE</code> 为 <code>L1</code></strong>。</p>
<hr>
<p class=" font-serif my-1">Soft Deadline: 2020 年 4 月 25 日 23:59:59。</p>
</blockquote>
<p class=" font-serif my-1"><oj-status course="OS2021" module="L1"><div class="divide-y divide-dashed">
    <div class="flex font-semibold">
      OS2021-L1 提交结果
    </div>
    
  </div>
</oj-status></p>
<p class=" font-serif my-1">本实验需要提交以学号命名的 .pdf 格式实验报告 (保存在 <code>kernel/</code> 目录下)，之后的 OSLabs 将不断在此实验报告基础上添加。除非特殊情况，本次实验的实验报告<strong>不建议超过 2 页 A4 纸</strong>。请在实验报告中描述你在实验中遇到的特别值得一提的事件，例如你代码的架构设计、特别精巧的实现、遇到印象深刻的 bug 等。</p>
<h2 id="1" class=" text-xl mt-2 pb-2 font-sans">1. 背景</h2>
<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="_2" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-blue" style=" padding-bottom: 0;">操作系统之旅正式开始</h4>
<p class=" font-serif my-1">这次我们真的来写操作系统了，有点小激动嘛！框架代码的目录名也变成了 “kernel”。在《操作系统》课程中，我们遵循的是 “一步一个脚印”，自底向上实现一个基础坚实的操作系统。因此，在内核里实现很酷的 “分时多线程” (即并发运行多个状态机) 之前，我们先做多处理器上的热身练习——物理内存管理，具体完成物理内存的分配和回收。</p>
</blockquote>
<p class=" font-serif my-1">在实现操作系统内核时，我们经常会需要为操作系统中新增的对象分配存储空间。在这些对象不再使用时，我们需要将它们的内存回收。我们在 M2 中调用 <code>co_start</code> 中调用 <code>malloc</code> 为协程分配寄存器现场、堆栈等资源，在 <code>co_wait</code> 时回收；打开一个文件时，需要开辟内存空间保存文件描述符的偏移量等信息。对迷你自制操作系统来说，每种类型的资源都手工分配和释放并不是个大问题，但实现内存的分配和释放能简化操作系统内核中很多地方的代码实现，因此对大家来说依然是值得的。</p>
<p class=" font-serif my-1">在这个实验里，大家会亲手体验大家所熟悉的 malloc/free 应该怎样实现。在多处理器系统中，各个处理器上的代码会<strong>并发</strong>地申请或释放内存。这就给内存分配和释放带来额外的挑战：一方面，我们希望不同处理器能并行、高效地申请内存，不会因为同时申请而发生一个处理器等另一个处理器的情况，且在很短的时间内完成分配；另一方面，这又要求 malloc/free 不能简单粗暴地用一把互斥锁来保护。好准备好了？做不好也得做好了啦。</p>
<h2 id="2" class=" text-xl mt-2 pb-2 font-sans">2. 实验描述</h2>
<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="1_1" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-blue" style=" padding-bottom: 0;">实验要求 1：实现多处理器安全的内存分配和回收</h4>
<p class=" font-serif my-1">类似于 malloc/free，在 bare-metal 上实现内存分配/回收的函数：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">kalloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 内存分配</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 内存释放</span>
<span class="p">}</span>
</code></pre></div>

</blockquote>
<p class=" font-serif my-1">在 AbstractMachine 启动后，<code>[heap.start, heap.end)</code> 都是可用的物理内存 (堆区)，kalloc 返回的内存必须位于这个区间中。具体来说这个实验中你需要实现一个数据结构 (抽象数据类型)，维护一个不相交区间的集合 (堆区)</p>
<p class=" font-serif my-1">$$ H = \big\{ [\ell_0, r_0), [\ell_1, r_1), \ldots, [\ell_n, r_n) \big\}。$$</p>
<p class=" font-serif my-1">初始时，堆区为空。假设当前堆区为 $H$，<code>heap.start</code>$\ = L$, <code>heap.end</code>$\ = R$:</p>
<ul class=" list-disc font-serif">
<li class=" ml-8">kalloc($s$) 分配 $s$ 字节的内存 $[\ell, r)$ 满足
    $$分配发生在堆区中 (L \le \ell < r < R),$$
    $$分配的内存不与已分配内存重叠 (\forall [\ell_i, r_i) \in H.\ [\ell, r) \cap [\ell_i, r_i) = \varnothing)，$$
    得到新的堆区 $$H' = H \cup \big\{ [\ell, r) \big\}$$ 并返回分配区间的左端点 $\ell$。</li>
<li class=" ml-8">kfree($\ell$) 删除一个已有区间 $[\ell, r) \in H$，得到新的堆区
    $$H' = H \setminus \big\{ [\ell, r) \big\}.$$
当 $\ell$ 不是 $H$ 中任何一个区间左端点时，产生 undefined behavior。</li>
</ul>
<p class=" font-serif my-1">如果仅看上面的抽象描述，这看起来就是一道大家做过的 Online Judge 题目嘛！别急。虽然数学模型简单，但还有很多地方没有规定好，例如在有大量空余空间时，我们到底应该返回哪一个。这部分内容交给大家自由探索，我们只有一些作为<strong>计算机系统软件基础设施</strong>的要求：</p>
<ul class=" list-disc font-serif">
<li class=" ml-8">对于大小为 $s$ 的内存分配请求，返回的内存地址必须对齐到 $2^i$，其中 $i$ 是最小的正整数满足 $2^i \ge s$。例如，4 KiB 的内存分配请求返回的地址必须是 4,096 的整数倍 (页面边界)。例如，分配 17 字节内存返回的地址必须是 32 的整数倍。这么要求其实简化了大家的实现。</li>
<li class=" ml-8">在你的分配算法不能找到足够的内存可以分配时，返回 <code>NULL</code> (<code>0</code>)。<ul class=" list-disc font-serif">
<li class=" ml-8">受分配算法的局限，可能系统中仍然有空闲的内存，但形成了碎片的内存，或是你的算法不能找到它从而分配失败。这是允许的；但在系统内存压力很小的时候依然频繁分配失败，可能导致 hard test failure。</li>
</ul>
</li>
<li class=" ml-8">由于我们在自制的操作系统内核中使用，你可以直接拒绝超过 16 MiB 的内存分配。</li>
<li class=" ml-8">不必初始化返回的内存，当然，对返回的内存赋上初始值 (例如零) 也许是个不错的主意。</li>
<li class=" ml-8">最重要的要求在于<strong>允许多处理器并行地调用 kalloc/kfree</strong>：<ul class=" list-disc font-serif">
<li class=" ml-8">不同的处理器可能同时执行 kalloc 分配大小不同的内存；</li>
<li class=" ml-8">不同的处理器可能同时执行 kfree 释放内存；</li>
<li class=" ml-8">在一个处理器分配的内存，可能在另一个处理器上释放；但我们保证我们的测试代码中不存在数据竞争；</li>
<li class=" ml-8">在 kalloc/kfree 实现正确的前提下，尽可能使不同处理器上的内存分配能够并行。如果你代码的性能过低 (例如用全局的锁保护空闲链表，并用遍历链表的方式寻找可用的内存)，可能会导致 hard test failure。</li>
</ul>
</li>
</ul>
<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="2-abstractmachine-klib" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-blue" style=" padding-bottom: 0;">实验要求 2 (非强制完成)：实现 AbstractMachine 中 klib 中缺失的函数</h4>
<p class=" font-serif my-1">在 Lab0 中，我们已经提出了这个实验要求。从现在开始，我们正式建议大家实现 klib 里缺失的函数——没有 printf, sprintf 等函数，你根本就是在用汇编语言写操作系统，你不会 survive 到最后的。</p>
<ul class=" list-disc font-serif">
<li class=" ml-8">我们不会检查大家的 klib 实现，但请大家不要抄袭——虽然互联网上有很多代码，但自己写一遍依然是掌握这些库函数原理的最好方式。</li>
<li class=" ml-8">学期中我们将会上线自动 Git 记录检查工具，并在我们检测到潜在的异常行为时报告。如果你的确是独立完成的，请忽略看到的警告。</li>
</ul>
</blockquote>
<h2 id="3" class=" text-xl mt-2 pb-2 font-sans">3. 正确性标准</h2>
<h3 id="31" class=" text-lg mt-2 pb-2 font-sans">3.1. 测试用例说明</h3>
<p class=" font-serif my-1">从这个实验开始，正确性将变得非常重要——如果你的 kalloc/kfree 不正确，之后的实验可以说是难以为继了。为了帮助大家为后续的实验打下良好的基础，我们会使用来自类似于真实操作系统系统内核的 workload (多处理器) 来测试大家的程序。系统/workload 的一些假设：</p>
<p class=" font-serif my-1">为了强迫大家使用动态的方式管理大小不同的堆区，我们规定你使用的所有静态内存 (64-bit 模式下的代码、数据、bss) 不能超过 1 MiB。我们将会在运行之前对内核使用 size 命令进行检查，并拒绝过大的 kernel。管理堆区的数据结构应当在堆区中而不是静态区中进行分配。</p>
<ul class=" list-disc font-serif">
<li class=" ml-8">不超过 8 个处理器、不少于 64 MiB、不多于 4 GiB 内存的堆区；</li>
<li class=" ml-8">大量、频繁的小内存分配/释放；其中绝大部分不超过 128 字节；</li>
<li class=" ml-8">较为频繁的，以物理页面大小为单位的分配/释放 (4 KiB)；</li>
<li class=" ml-8">非常罕见的大内存分配。</li>
</ul>
<p class=" font-serif my-1">我们预期你的 kalloc/kfree 具有足够的 robustness，足以承载操作系统内核的实现:</p>
<ol class=" list-decimal font-serif">
<li class=" ml-8">
<p class=" font-serif my-1">Safety: 我们预期你的 kalloc/kfree 实现是正确的。一旦以下情况发生，将被立即被 Online Judge 判定为错误：</p>
<ul class=" list-disc font-serif">
<li class=" ml-8">虚拟机重启、crash、测试代码中的 assert fail 等 (通常由 undefined behavior 触发，例如数据竞争)</li>
<li class=" ml-8">kalloc 的返回值不满足 API 规约，例如分配的内存不位于堆区、错误的内存对齐等</li>
<li class=" ml-8">kalloc 返回一段尚未被 kfree 的内存</li>
</ul>
</li>
<li class=" ml-8">
<p class=" font-serif my-1">Liveness: 我们还需要系统有一定的 liveness，即系统中有充足剩余内存时，内存分配不应过于频繁的频繁失败。这是为了防止你为了 safety 进行一些 “投机取巧”：对所有 kalloc 都返回 <code>NULL</code>，safety trivially 被满足。</p>
<ul class=" list-disc font-serif">
<li class=" ml-8">liveness 并不是一个 “硬性” 的要求。在合理的 workload 上，你程序的表现只要不比一个 (实现得非常一般) 的 baseline 差太多 (你依然允许在某些你认为无法满足的 kalloc 上返回 <code>NULL</code>)，就会被判定为正确</li>
</ul>
</li>
</ol>
<p class=" font-serif my-1">与 L0 类似，我们会链接我们 klib 的参考实现，因此你不必担心你的 klib 有些许问题；但你要保持 klib 库函数的行为与 libc 一致。注意 native 会链接系统本地的 glibc (而非 klib)。</p>
<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="hard-test" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-blue" style=" padding-bottom: 0;">Hard Test 很难？</h4>
<p class=" font-serif my-1">如果你觉得能力实在有限，未必一定要搞定所有的 test cases。例如，如果你实在感到困难，可以考虑不实现 kfree:</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
</code></pre></div>

<p class=" font-serif my-1">这样 kalloc 的实现就非常简单了——简单到只需要维护一个指针即可，依然能确保有 easy tests 通过，按时提交可以获得 35% 的得分 (实现得稍稍更好一些，就可以获得更多的分数)。我们不严格禁止这样的实现，而且你会发现，如果内存充足，你之后编写的操作系统依然是可以运行的 (只是运行一段时间以后，就会 out of memory 无法再运行下去，会影响后续实验测试用例的得分)。</p>
</blockquote>
<h3 id="32-online-judge" class=" text-lg mt-2 pb-2 font-sans">3.2. Online Judge 运行测试代码的方式</h3>
<p class=" font-serif my-1">我们会替换 <code>framework/main.c</code> 的代码，但保持的 <code>src/</code> 目录下的文件不变。因此，你自己的测试用例 (在 <code>os_run()</code> 中) 可以不必修改。测试时，我们会改变 <code>mpe_init</code> 的入口 (不再从 <code>os->run</code> 开始执行，而是直接运行测试的 workload)。因此你必须在 <code>os->init()</code> 中完成所有必要的初始化，例如调用 <code>pmm->init()</code>。</p>
<p class=" font-serif my-1">以下是一个我们测试代码的例子，它会不断生成随机的 kalloc/kfree 请求 (你可以假设我们的生成器总是生成合法的请求，例如不会发生 double-free 等)，并且检查 kalloc/kfree 返回结果的合法性；当检测到问题后会 assert fail 退出，然后你可能会得到诸如 “Runtime Error (Exit Early)” 这样的错误信息。</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf"><common.h></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf"><klib.h></span>

<span class="k">enum</span><span class="w"> </span><span class="n">ops</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">OP_ALLOC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">OP_FREE</span><span class="w"> </span><span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">malloc_op</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">ops</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">  </span><span class="k">union</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">stress_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">malloc_op</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">random_op</span><span class="p">();</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">OP_ALLOC</span><span class="p">:</span><span class="w"> </span><span class="n">alloc_check</span><span class="p">(</span><span class="n">pmm</span><span class="o">-></span><span class="n">alloc</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">sz</span><span class="p">),</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">sz</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">OP_FREE</span><span class="p">:</span><span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">os</span><span class="o">-></span><span class="n">init</span><span class="p">();</span>
<span class="w">  </span><span class="n">mpe_init</span><span class="p">(</span><span class="n">stress_test</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="4" class=" text-xl mt-2 pb-2 font-sans">4. 实验指南</h2>
<h3 id="41" class=" text-lg mt-2 pb-2 font-sans">4.1. 代码组织与运行</h3>
<p class=" font-serif my-1">实验框架代码由三个目录组成：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>.
├── framework  -> 框架代码；可以在本地修改，但 Online Judge 评测时会被替换成我们的版本
│   ├── kernel.h
│   └── main.c
├── include    -> 头文件；可以自由修改/创建文件 (Online Judge 会复制)
│   └── common.h
├── Makefile
└── src        -> 源文件；可以自由修改/创建文件 (Online Judge 会复制)
    ├── os.c
    └── pmm.c
</code></pre></div>

<p class=" font-serif my-1">理解框架代码的编译，最好的办法是看 Makefile 啦。在<a href="../slides/C2.slides.html" class=" text-amber-900">代码课 C2</a> 中，我们已经讲解了如何阅读 Makefile (大家可以查看视频回看)，并讲解了镜像的生成过程。好奇操作系统是如何被 “编译” 出来的？如果觉得阅读 Makefile (和里面奇奇怪怪的语法) 有点困难，我们不妨把 make 工具的执行也想象成是状态机——没错，程序就是状态机，而我们如果观测这个状态机的执行，我们最关心的当然是 make 工具执行的所有命令了，因为是这些命令产生了我们编译出的 <code>.o</code> 文件、链接得到的 ELF 二进制文件，以及我们的操作系统镜像。</p>
<p class=" font-serif my-1">GNU make 自然为我们提供了这个功能：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>$ make -nB # RTFM!
... (完全不可读的输出)
</code></pre></div>

<p class=" font-serif my-1">但如果你稍稍对输出做一些处理</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>make -nB | grep -v '^mkdir' | vim -
</code></pre></div>

<p class=" font-serif my-1">并且在 Vim 里做一些你舒适的文本处理，例如 <code>:%s/^/\r</code> 在命令之间插入空行；<code>:%s/ /\r  /g</code> 将命令的参数缩进排版……你很快就会得到 “可读” 的代码，例如编译一个 .c 文件的命令：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>x86_64-linux-gnu-gcc
  -std=gnu11 -O2
  -MMD -Wall -Werror -ggdb
  -Iinclude/ -Iframework/ -I$KERNEL/include -I$AM/am/include/ -I$AM/klib/include/
  -D__ISA__=\"x86_64\"
  -D__ISA_X86_64__
  -D__ARCH__=x86_64-qemu
  -D__ARCH_X86_64_QEMU
  -D__PLATFORM__=qemu
  -D__PLATFORM_QEMU
  -DARCH_H=\"arch/x86_64-qemu.h\"
  -fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector -Wno-main -m64 -fPIC -mno-sse
  -c -o $BUILD/x86_64-qemu/framework/main.o
  $KERNEL/framework/main.c
</code></pre></div>

<p class=" font-serif my-1">链接生成 ELF 文件的命令：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>x86_64-linux-gnu-ld
  -melf_x86_64 -N
  -Ttext-segment=0x00100000
  -o $BUILD/kernel-x86_64-qemu.elf
  $BUILD/x86_64-qemu/framework/main.o
  $BUILD/x86_64-qemu/./src/pmm.o
  $BUILD/x86_64-qemu/./src/os.o
  $AM/am/build/am-x86_64-qemu.a
  $AM/klib/build/klib-x86_64-qemu.a
</code></pre></div>

<p class=" font-serif my-1">以及最终生成可运行的磁盘镜像的过程：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>( cat $AM/am/src/x86/qemu/boot/bootblock.o;
  head -c 1024 /dev/zero;
  cat $BUILD/kernel-x86_64-qemu.elf
) > $BUILD/kernel-x86_64-qemu
</code></pre></div>

<p class=" font-serif my-1">哇哦！操作系统好像也没有那么可怕了。真的是《计算机系统基础》课上学过的编译-链接，对照着手册，就能知道个大概了 (个别参数的具体含义也并不需要理解得非常清楚，只需要知道这些是用于编译出一个 “不借助操作系统” 能直接运行在硬件上的程序的就够了)。</p>
<p class=" font-serif my-1">使用 <code>make run</code> 编译运行，你将会看到一个处理器输出 Hello World：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>$ make run ARCH=x86_64-qemu
# Building kernel-image [x86_64-qemu]
...
Got 125 MiB heap: [0x300000, 0x8000000)
Hello World from CPU #0
</code></pre></div>

<p class=" font-serif my-1">如果要启动多个处理器，可以为 <code>make run</code> 传递 <code>smp</code> 环境变量，例如 <code>smp=2</code> 代表启动 2 个处理器；<code>smp=4</code> 代表启动 4 个处理器：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>$ make run ARCH=x86_64 smp=4
...
Got 125 MiB heap: [0x300000, 0x8000000)
Hello World from CPU #1
Hello World from CPU #2
Hello World from CPU #3
Hello World from CPU #0
</code></pre></div>

<h3 id="42" class=" text-lg mt-2 pb-2 font-sans">4.2. 框架代码导读</h3>
<p class=" font-serif my-1">框架代码很短，它的 <code>main</code> 函数首先执行 <code>os</code> 的初始化，然后启动多个处理器，每个处理器都跳转到 <code>os->run</code> 执行：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">os</span><span class="o">-></span><span class="n">init</span><span class="p">();</span>
<span class="w">  </span><span class="n">mpe_init</span><span class="p">(</span><span class="n">os</span><span class="o">-></span><span class="n">run</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p class=" font-serif my-1"><code>os</code> 是一个操作系统的 “模块”，可以看成是我们用 C 实现的面向对象编程，能增加代码的可读性。整个框架代码中唯一有些难以理解的部分就是模块的声明和定义 (<code>framework/kernel.h</code>)：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="cp">#define MODULE(mod) \</span>
<span class="cp">  typedef struct mod_##mod##_t mod_##mod##_t; \</span>
<span class="cp">  extern mod_##mod##_t *mod; \</span>
<span class="cp">  struct mod_##mod##_t</span>

<span class="cp">#define MODULE_DEF(mod) \</span>
<span class="cp">  extern mod_##mod##_t __##mod##_obj; \</span>
<span class="cp">  mod_##mod##_t *mod = &__##mod##_obj; \</span>
<span class="cp">  mod_##mod##_t __##mod##_obj</span>
</code></pre></div>

<p class=" font-serif my-1">我们用 <code>MODULE</code> 声明一个模块，用 <code>MODULE_DEF</code> 实际定义它。</p>
<p class=" font-serif my-1">这个宏的视觉效果很差，为了阅读它，大家不妨可以在刚才看到的编译命令中把 <code>-c -o ...</code> 替换成 <code>-E</code>，就得到了预编译后的代码：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">mod_os_t</span><span class="w"> </span><span class="n">mod_os_t</span><span class="p">;</span>
<span class="k">extern</span><span class="w"> </span><span class="n">mod_os_t</span><span class="w"> </span><span class="o">*</span><span class="n">os</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">mod_os_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)();</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">run</span><span class="p">)();</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">extern</span><span class="w"> </span><span class="n">mod_os_t</span><span class="w"> </span><span class="n">__os_obj</span><span class="p">;</span>
<span class="n">mod_os_t</span><span class="w"> </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&</span><span class="n">__os_obj</span><span class="p">;</span>
<span class="n">mod_os_t</span><span class="w"> </span><span class="n">__os_obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">.</span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">os_init</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">run</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">os_run</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<p class=" font-serif my-1">然后你就可以对照着阅读预编译的代码 (用对了方法，也就没有那么难了)，只需要记住以下两点：</p>
<ol class=" list-decimal font-serif">
<li class=" ml-8">宏是字面替换，<code>MODULE(mod)</code> 中所有的 “<code>mod</code>” 都会被替换掉；</li>
<li class=" ml-8"><code>##</code> 是 C 语言用来拼接标识符的机制，<code>sys ## tem</code> 将会得到 <code>system</code>;</li>
</ol>
<p class=" font-serif my-1">如果你阅读上述代码感到障碍，你可能需要补充：(1) <code>typedef</code> 类型别名定义, (2) <code>extern</code> 关键字, (3) C11 结构体初始化的知识。另外，下划线 <code>_</code> 也可以是标识符的一部分。</p>
<p class=" font-serif my-1">随着实验的进展，你会发现模块机制清晰地勾勒出了操作系统中各个部分以及它们之间的交互，能够帮助大家更好地理解操作系统的实现原理。</p>
<h3 id="43" class=" text-lg mt-2 pb-2 font-sans">4.3. 框架代码的执行</h3>
<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="_3" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-blue" style=" padding-bottom: 0;">好消息：实验做出的简化</h4>
<p class=" font-serif my-1">在这个实验中，我们只启动了 AbstractMachine 中的 TRM 和 MPE，因此你不必考虑中断和多处理器同时带来的诸多麻烦 (下一个实验才开始考虑)。你不妨把每个处理器想象成一个线程。</p>
</blockquote>
<p class=" font-serif my-1">我们的操作系统内核，目前只有两个函数：</p>
<ul class=" list-disc font-serif">
<li class=" ml-8"><code>os->init()</code> 完成操作系统所有部分的初始化。<code>os->init()</code> 运行在系统启动后的第一个处理器上，中断处于关闭状态；此时系统中的其他处理器尚未被启动。因此在 <code>os->init</code> 的实现中，你完全不必考虑数据竞争等多处理器上的问题。</li>
<li class=" ml-8"><code>os->run()</code> 是所有处理器的入口，在初始化完成后，框架代码调用 <code>_mpe_init(os->run)</code> 启动所有处理器执行。框架代码中，<code>os->run</code> 只是打印 Hello World 之后就开始死循环；你之后可以在 <code>os->run</code> 中添加各种测试代码。</li>
</ul>
<p class=" font-serif my-1">所以就想象成是你的 <code>os->run()</code> 就是 <code>threads.h</code> 里创建的一个线程，仅此而已！</p>
<h3 id="44-kallockfree" class=" text-lg mt-2 pb-2 font-sans">4.4. 实现 kalloc/kfree</h3>
<p class=" font-serif my-1">我们的实现主要在 pmm (physical memory management) 模块：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="n">MODULE</span><span class="p">(</span><span class="n">pmm</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)();</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc</span><span class="p">)(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p class=" font-serif my-1">模块包含三个函数指针：</p>
<ul class=" list-disc font-serif">
<li class=" ml-8"><code>pmm->init()</code> 初始化 pmm 模块，它应当在多处理器启动前 (<code>os->init()</code> 中) 调用。你会在这里完成数据结构、锁的初始化等；</li>
<li class=" ml-8"><code>pmm->alloc()</code> 对应实验要求中的 kalloc；</li>
<li class=" ml-8"><code>pmm->free()</code> 对应实验要求中的 kfree。</li>
</ul>
<p class=" font-serif my-1">框架代码中包含了 “空的” pmm 实现，它对任何内存分配的请求都返回失败，因此它满足 safety，但完全没有 liveness，仿佛堆区的大小为零：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">kalloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">pmm_init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span>
<span class="n">MODULE_DEF</span><span class="p">(</span><span class="n">pmm</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">.</span><span class="n">init</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">pmm_init</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kalloc</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">free</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">kfree</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="static" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-blue" style=" padding-bottom: 0;">思考题：static 函数</h4>
<p class=" font-serif my-1">为什么 kalloc/kfree/pmm_init 声明成了 <code>static</code>？我把 <code>static</code> 去掉依然可以编译呀？</p>
<p class=" font-serif my-1">这是一个好的编程习惯，在 C 这样缺少 module/package/namespace 机制的编程语言上有效减少意外发生。</p>
</blockquote>
<p class=" font-serif my-1">我们在讲解 “并发数据结构” 时讲解了 kalloc/free 的算法和实现。你应该阅读：</p>
<ul class=" list-disc font-serif">
<li class=" ml-8">教科书第 29 章 (并发数据结构)，学习如何对数据结构进行并发控制；</li>
<li class=" ml-8">教科书第 17 章 (空闲空间管理)，学习如何管理物理内存；</li>
<li class=" ml-8">互联网上的其他资料，例如教科书第 17 章中的参考文献。</li>
</ul>
<h3 id="45" class=" text-lg mt-2 pb-2 font-sans">4.5. 测试/调试你的代码</h3>
<h4 id="451" class=" pt-2 pb-2 font-sans">4.5.1. 做一个测试框架</h4>
<p class=" font-serif my-1">AbstractMachine 代码的调试并不容易——不论是 native 还是运行在模拟器里，AM APIs 都和系统有紧密的耦合。大家有没有想过，你们的代码是否可以链接 <code>threads.h</code> 直接运行测试呢？答案当然是肯定的！在这个实验里，做一个测试框架对你找到 bug 其实是非常有用的。</p>
<p class=" font-serif my-1">你可以创建一个 test 目录，用于存放和测试相关的代码，例如我们提供的 <code>threads.h</code>:</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>$ tree test 
test
├── am.h # 一个空的 am.h
├── common.h
├── test.c
└── threads.h # 上课时给出的代码
</code></pre></div>

<p class=" font-serif my-1">除此之外，所有的操作系统/框架代码等都和之前保持一致——我们通过最小的、非侵入式的项目修改确保你在任何时候都可以通过 <code>make submit</code> 直接提交代码而不需要做出任何额外的修改。这些自动工具/代码框架对于做实验 (包括做 Online Judge) 都是非常值得的。</p>
<p class=" font-serif my-1">为了让我们的代码能够兼容，你可以需要增加一些条件编译，例如，在 <code>pmm.c</code> 中，虽然你的 <code>kalloc</code> 和 <code>kfree</code> 的实现可以保持不变，但初始化代码则需要不同：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="cp">#ifndef TEST</span>
<span class="c1">// 框架代码中的 pmm_init (在 AbstractMachine 中运行)</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">pmm_init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uintptr_t</span><span class="w"> </span><span class="n">pmsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">heap</span><span class="p">.</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">heap</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"Got %d MiB heap: [%p, %p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">pmsize</span><span class="w"> </span><span class="o">>></span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="n">heap</span><span class="p">.</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">heap</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="c1">// 测试代码的 pmm_init ()</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">pmm_init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">HEAP_SIZE</span><span class="p">);</span>
<span class="w">  </span><span class="n">heap</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="w">  </span><span class="n">heap</span><span class="p">.</span><span class="n">end</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">HEAP_SIZE</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"Got %d MiB heap: [%p, %p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">HEAP_SIZE</span><span class="w"> </span><span class="o">>></span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="n">heap</span><span class="p">.</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">heap</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</code></pre></div>

<p class=" font-serif my-1">在你相应完成两个不同环境的条件编译后，在你的 Makefile 里增加一个编译目标 (我们添加了 git 的依赖，使得你的提交被正确追踪)：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="nf">test</span><span class="o">:</span><span class="w"> </span><span class="n">git</span>
<span class="w">        </span>@gcc<span class="w"> </span><span class="k">$(</span>shell<span class="w"> </span>find<span class="w"> </span>src/<span class="w"> </span>-name<span class="w"> </span><span class="s2">"*.c"</span><span class="k">)</span><span class="w">  </span><span class="se">\</span>
<span class="w">             </span><span class="k">$(</span>shell<span class="w"> </span>find<span class="w"> </span>test/<span class="w"> </span>-name<span class="w"> </span><span class="s2">"*.c"</span><span class="k">)</span><span class="w"> </span><span class="se">\</span>
<span class="w">             </span>-Iframework<span class="w"> </span>-Itest<span class="w"> </span>-DTEST<span class="w"> </span>-lpthread<span class="w"> </span><span class="se">\</span>
<span class="w">             </span>-o<span class="w"> </span>build/test
<span class="w">        </span>@build/test
</code></pre></div>

<p class=" font-serif my-1">然后就可以愉快地写测试代码啦 (<code>test.c</code>):</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">entry</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">pmm</span><span class="o">-></span><span class="n">alloc</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">goodbye</span><span class="p">()</span><span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">"End.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">pmm</span><span class="o">-></span><span class="n">init</span><span class="p">();</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o"><</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">create</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="w">  </span><span class="n">join</span><span class="p">(</span><span class="n">goodbye</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="_4" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-blue" style=" padding-bottom: 0;">把时间投资在框架建设上</h4>
<p class=" font-serif my-1">你可能需要花一点时间才能完成 <code>make</code> 和 <code>make test</code> 共用同一份 kalloc/kfree 代码的框架。但这绝对是值得的。一旦完成，直接测试/调试本地代码的好处是巨大的——它节省了编译、运行、调试……整个开发流程的 overhead。任何想用 “蛮力” 把实验糊弄过去都将导致巨大的时间浪费。</p>
</blockquote>
<h3 id="452" class=" text-lg mt-2 pb-2 font-sans">4.5.2. 设计测试用例</h3>
<p class=" font-serif my-1">如果不想被 Online Judge 折磨得死去活来，你应当设计一个自己的测试框架，尝试不同类型的测试，例如：</p>
<ul class=" list-disc font-serif">
<li class=" ml-8">针对数据结构的单元测试；</li>
<li class=" ml-8">最基本的 smoke test，测试单线程版本是否正确；</li>
<li class=" ml-8">基本的并发测试，例如多个处理器并发地分配 (但不回收)；</li>
<li class=" ml-8">针对回收专门设计的测试；</li>
<li class=" ml-8">极端情况下的压力测试 (我们会这么做！)<ul class=" list-disc font-serif">
<li class=" ml-8">在多个处理器上模拟各种不同类型的内存访问模式<ul class=" list-disc font-serif">
<li class=" ml-8">频繁的小内存申请；</li>
<li class=" ml-8">频繁的大内存申请；</li>
<li class=" ml-8">混合的内存申请；</li>
<li class=" ml-8">多处理器竞争的申请/释放……</li>
</ul>
</li>
<li class=" ml-8">你还需要有个办法验证你的 kalloc/free 是否正确<ul class=" list-disc font-serif">
<li class=" ml-8">一个可行的方案是，每次分配/释放都用 printf 打印一条记录，然后再写一个小脚本解析记录，确保例如同一段内存没有被分配给两个 kalloc。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class=" font-serif my-1">这时候，代码框架的威力就显示出来了！你可以很容易地批量运行很多测试，例如</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o"><</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="k">switch</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="n">do_test_0</span><span class="p">();</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="n">do_test_1</span><span class="p">();</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p class=" font-serif my-1">然后在你的 Makefile 里批量运行它们：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="nf">testall</span><span class="o">:</span><span class="w"> </span><span class="n">test</span>
<span class="w">        </span>@build/test<span class="w"> </span><span class="m">0</span>
<span class="w">        </span>@build/test<span class="w"> </span><span class="m">1</span>
<span class="w">        </span>@build/test<span class="w"> </span><span class="m">2</span>
<span class="w">        </span>...
</code></pre></div>

<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="_5" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-blue" style=" padding-bottom: 0;">警惕并发</h4>
<p class=" font-serif my-1">很可能你的顺序测试完全通过，但多处理器跑起来就挂了。不要慌，多加点 printf logs，慢慢诊断可能的问题。然后你可能会惊奇地发现，也许加了一个 printf，错误就不见了。此时的建议是调整 workloads、增加延迟等保证 bug 的稳定再现，然后再进行诊断。如果你希望实现各种 fancy 的算法，不妨从一把大锁保护 kalloc/free 开始。这是个不错的主意——这样你一开始就只需要关注单线程 kalloc/free 的正确性。当你需要性能的时候，再逐步把锁拆开。</p>
</blockquote>
<h3 id="453" class=" text-lg mt-2 pb-2 font-sans">4.5.3 性能调优</h3>
<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="workload" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-blue" style=" padding-bottom: 0;">抛开 workload 谈优化，就是耍流氓</h4>
<p class=" font-serif my-1"><em>Premature optimization is the root of all evil.</em> —— D. E. Knuth</p>
<p class=" font-serif my-1">要考虑好你优化的场景，否则一切都是空谈。</p>
</blockquote>
<p class=" font-serif my-1">你需要选取适当的 workload 进行调优，并且理解你程序的性能瓶颈在哪里。这时候，靠 “猜” 和随机修改程序以获得性能提升的方式是不专业的表现。理解程序性能的最好方法是使用正确的工具：profiler。作为本地进程运行的测试用例也能更容易地 profile——你可以用 Linux 系统自带的各种工具找到你实现的性能瓶颈。当然，这个实验对性能的要求并不高，大家体验一下即可。</p>
<p class=" font-serif my-1">当然，这个实验给大家的剧透是：如果数据结构选择得不太差，性能瓶颈就主要在于多个线程并发访问时的互斥，由于多个线程都需要获得同一把锁，就会出现 “一核出力、他人围观” 的情况。正如课本上所说，现代 malloc/free 实现的主要思想就是区分 fast/slow path，使得 fast path 分配在线程本地完成，从而不会造成锁的争抢。你也可以为每个 CPU 分配页面的缓存——可以借鉴 slab，也可以预先把页面分配给 CPU，在内存不足时再上锁从其他 CPU “偷取” 页面。</p>
<h2 id="5" class=" text-xl mt-2 pb-2 font-sans">5. 操作系统中的内存管理</h2>
<p class=" font-serif my-1">很多现代编程语言都运行在自动管理内存的的运行时环境上：Java, Python, Javascript, ...它们的特点是：没有 raw pointer，也没有 API 用于 “释放” 内存。当一个对象从一系列的 root objects (例如栈上的局部变量、全局变量等……) 通过引用关系不可达，它们就会自动被运行时环境回收。这真是程序员的福音——再也没有 use-after-free, double-free 等问题了，memory leak 的可能性也大大降低 (虽然依然可能会有)。</p>
<p class=" font-serif my-1">当然，自动内存管理带来的问题是内存回收是个 highly non-trivial 的问题，至今仍然不能算彻底完美地解决，生产系统依然经常受到垃圾回收 (回收不可达对象) 停顿/降低性能的困扰。由于操作系统的性能至关重要，让垃圾回收占据处理器运行似乎不是个好主意……未必！</p>
<ul class=" list-disc font-serif">
<li class=" ml-8">阅读材料：Cody Cutler, M. Frans Kaashoek, and Robert T. Morris. <a href="https://www.usenix.org/conference/osdi18/presentation/cutler" class=" text-amber-900">The benefits and costs of writing a POSIX kernel in a high-level language</a>. In <em>Proc. of OSDI</em>, 2018. (硬核/专业人士警告)</li>
</ul>
<p class=" font-serif my-1">当然，操作系统内核的有趣故事也没有停过：</p>
<ul class=" list-disc font-serif">
<li class=" ml-8">Kevin Boos, Namitha Liyanage, Ramla Ijaz, and Lin Zhong. <a href="https://www.usenix.org/conference/osdi20/presentation/boos" class=" text-amber-900">Theseus: An experiment in operating system structure and state management</a>. In <em>Proc. of OSDI</em>, 2020. </li>
<li class=" ml-8">清华大学的 <a href="https://zhuanlan.zhihu.com/p/137733625" class=" text-amber-900">zCore</a> 也有很类似的想法 (和我们的 OSLab 一样，zCore 的内核可以以进程的方式直接运行在用户态，他们人手也更充足，维护了功能更全的代码)。jyy 也一直在考虑把课程/实验向 Rust 迁移的可能性。不过暂时我们还是 “原汁原味”，体会一下老一辈人实现操作系统的困难吧。</li>
</ul></div>
</div>

<div class="container text-xs py-3">
  <span class="text-muted">
    <center><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="../../../static/img/cc-4.0.png"></a>
       <a style="color:inherit" href="https://beian.miit.gov.cn/">苏 ICP 备 2020049101 号</a>
    </center>
  </span>
</div>

</div>

<script src="../../../static/js/jquery.min.js"></script>

<script>
function get_token() {
  var match = document.cookie.match(new RegExp('(^| )token=([^;]+)'));
  if (match) return match[2];
  else return "";
}
var token = get_token();
var hint = "token", box = $("#token-input");

if (token == "") { }
else { box.val(token); }

function login() {
  var token = box.val()
  if (!token) {
    document.cookie = ''
  } else {
    document.cookie = 'token=' + token + '; expires=Fri, 31 Dec 9999 23:59:59 GMT;'
  }
}
</script>


</body>

</html>