<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Yanyan&#x27;s Wiki</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css"/><meta name="next-head-count" content="5"/><link rel="preload" href="../_next/static/css/e993edd6a18ef4f0.css" as="style"/><link rel="stylesheet" href="../_next/static/css/e993edd6a18ef4f0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="../_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="../_next/static/chunks/webpack-f73d82589f972e7d.js" defer=""></script><script src="../_next/static/chunks/framework-66d32731bdd20e83.js" defer=""></script><script src="../_next/static/chunks/main-3929bf55b0f13a18.js" defer=""></script><script src="../_next/static/chunks/pages/_app-00b06920b385caf1.js" defer=""></script><script src="../_next/static/chunks/pages/[[...index]]-877ec949b69be209.js" defer=""></script><script src="../_next/static/a2FwJzUPGFGc0QcwaUr13/_buildManifest.js" defer=""></script><script src="../_next/static/a2FwJzUPGFGc0QcwaUr13/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-slate-300/10"><div class="sticky top-0 z-40 w-full backdrop-blur flex-none border-b border-slate-900/10 bg-white/75 supports-backdrop-blur:bg-white/60"><div class="max-w-8xl mx-auto"><div class="py-4 border-b border-slate-900/10 lg:px-8 lg:border-0 dark:border-slate-300/10 mx-4 lg:mx-0"><div class="relative flex items-center"><a href="../index.html">Yanyan&#x27;s wiki</a><form class="text-xs text-slate-500"> for <input type="text" name="token" class="font-mono text-xs w-16" maxLength="8"/></form><div class="relative hidden lg:flex items-center ml-4 pl-4 border-l"><nav class="text-sm leading-6 font-semibold text-slate-700 dark:text-slate-200"><ul class="flex space-x-8"><li><a class="hover:text-sky-500 dark:hover:text-sky-400" href="2025/index.html">操作系统 (2025 春)</a></li></ul></nav></div></div></div></div></div><div class="container mx-auto max-w-5xl flex flex-col min-h-screen px-4"><div class="wiki bg-neutral-200/10"><h1>生存指南</h1>
<p><strong>操作系统是一门十分硬核的编程课</strong>，因此如果你还没有完全准备好开始 “编程”、开始面对别人的代码，那可能你需要细心规划一下你的学习路线。当然，也不必焦虑，一来可能 “没学好编程” 不完全是你的责任，二来万事总有开头：</p>
<blockquote>
<p><strong>Don&#x27;t Panic.</strong> ——The Hitchhiker&#x27;s Guide to the Galaxy</p>
</blockquote>
<h2>1. 操作系统为什么难学？</h2>
<p>一直以来，老师们觉得《操作系统》课难教的原因主要是其中的主题既多、涉及的知识又深入，点面无法兼得。举个例子，同学们到目前为止编写的大部分代码都是串行的，就好像是写一个程序模仿 “一个人”，一次执行一步动作。通常《操作系统》课都是第一个引入并发编程的课程 (因为操作系统是最早的并发程序)，也就是你需要协同多个共享内存的 “多个人” 时，会遇到很多你也许意料之外的问题。</p>
<p>很显然，你 “想不清” 这个问题——可以预计，人类已经和并发编程的问题肉搏了几十年，时至今日仍有创新。那么，把这个话题 “讲清楚” 自然是极难的。更糟糕的是，很多课程试图把 “牛逼的现代操作系统” 概念放到课程中 (也许是为了装逼)，但这无异于空中楼阁。《操作系统》课要讲清楚的问题包括：</p>
<ul>
<li>操作系统应该为应用程序提供怎样的 API？</li>
<li>如何用硬件实现多个进程的并发/并行？</li>
<li>如何编写能够工作的并发程序，它不会在压力负载下随时随地崩溃？</li>
<li>如何维持多个隔离的执行流？</li>
<li>如何在磁盘上实现持久的数据结构？</li>
<li>……</li>
</ul>
<p>在解决这些问题上作出突出贡献的人已经得过 n 个图灵奖了——每一个问题都不是吃素的。我们的课程试图把这些问题的来龙去脉、解决方法、代码实现都掌握好，已经相当有挑战性。</p>
<p>操作系统 “难学” 的另一个原因是，想要理解 “操作系统为什么要做成今天这样”，就需要相当的应用编程经验——很多在你有了编程经验后 “理所应当” 的事情，在还不会编程的时候就显得很生硬。某位资深教师曾经问我：“copy-on-write fork 为什么需要引用计数？” 我一时语塞：如果一个共享资源可以自由共享，除了 gc 和引用计数，就没有简单明了的方法去释放它了。这一部分是因为我们的课程设置 “高不成低不就”：</p>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>停下来想一想️</b></span><div class="font-serif pt-2"><div class="py-1">进入大学，第一门编程课的职责到底是什么？</div><ol class="quiz-card p-0 ml-8 my-1"><li class="hover:cursor-pointer hover:bg-slate-200">学会用 API 把内心所想用代码表达出来并且爱上编程</li><li class="hover:cursor-pointer hover:bg-slate-200">深入理解一门编程语言的语法和语义，向语言律师迈进一步</li><li class="hover:cursor-pointer hover:bg-slate-200">引导学生取得学分，卷得 GPA</li></ol></div></div></div>
<p>如果你还没有爱上编程，那花一点时间 (包括学习《操作系统》课) 绝对是值得的。现在我们假设大家已经爱上编程，讨论操作系统该怎么学。</p>
<h2>2. 操作系统该怎么学？</h2>
<blockquote>
<p><strong>Don&#x27;t Panic. Everything is a state machine.</strong> ——The Hitchhiker&#x27;s Guide to Operating Systems</p>
</blockquote>
<p>幸运的是，我们在多年的经验里找到了理解操作系统的三把 “钥匙” (尤其是很特别的第三把钥匙)，从三个视角里，“从外向里” 一点一点深入地观测操作系统，直到形成对操作系统完整、一致的理解。</p>
<h3>🔑-1 <strong>在程序眼中，操作系统 = 对象 + API</strong></h3>
<widget><p>操作系统为应用程序提供了执行的基础环境、一系列操作系统对象和操作它们的 API——至少对于今天的操作系统来说，这些东西都是精确定义、触手可及的。我们可以在课堂上通过代码片段、调试工具、日志、trace 等等实在地触摸到操作系统为应用程序提供的一切。这就帮助我们理解现代操作系统<red>设计</red>背后的思路。</p></widget>
<p>我们会学习真实操作系统中的程序是什么，以及如何借助操作系统提供的 API 为操作系统编程。具体来说，我们的选择是 Linux (准确来说是 POSIX) 作为课程教学的平台，因为它既免费也自由 (能知道它内部的实现)，而且互联网上有丰富的 (英文) 文档。它的设计继承自 “Keep it simple, stupid” 的 UNIX，这个经典的设计背后的动机反而更容易为第一次接触操作系统的初学者所理解，也会贯穿整个课程。</p>
<p>选择 Linux 的另一个原因是它的开源基础——你能找到 Linux 世界中几乎任何程序的源代码！例如，你是否好奇 “文本编辑器” 是怎样实现的？命令行中的 Vim 看起来很酷，但你可能没有学过实现它所必须的编程知识。一方面，你可以求助 AI，另一方面，你也可以直接找一个 “简化版” 的实现，例如早期 busybox 的 <a href="https://git.busybox.net/busybox/tree/editors/vi.c?h=1_00_stable">vi.c</a>。扫一眼代码，你甚至会发现下面的注释：</p>
<pre><code class="hljs language-c"><span class="hljs-comment">/* To compile for standalone use:
 *	gcc -Wall -Os -s -DSTANDALONE -o vi vi.c ... */</span>
</code></pre>
<p>看不懂也没关系，我们有人工智能。AI 给了相当好的答案：</p>
<blockquote>
<p>GPT-4-turbo: 这个命令是在使用 GCC (GNU Compiler Collection) 编译器编译一个名为 <code>vi.c</code> 的C语言源文件，并生成一个名为 <code>vi</code> 的可执行文件。命令中的各个选项含义如下：<code>-Wall</code>: 开启所有的警告信息，帮助开发者发现代码中可能的问题。<code>-Os</code>: 优化编译后的代码，使其在大小上进行优化，即尽可能减小生成的可执行文件的大小。<code>-s</code>: 去除符号表和调试信息，这也有助于减小最终可执行文件的大小。<code>-DSTANDALONE</code>: 定义一个宏 <code>STANDALONE</code>，这通常用于条件编译。在源代码中，可以使用 <code>#ifdef STANDALONE</code> 来检查这个宏是否被定义，从而决定是否编译某些特定的代码块。<code>-o vi</code>: 指定输出的可执行文件名为 <code>vi</code>。综上所述，这个命令的目的是编译 <code>vi.c</code> 文件，并生成一个优化过的、体积较小的、没有调试信息的 <code>vi</code> 可执行文件。</p>
</blockquote>
<p>这个文件也许比你写过的任何项目都大 (4000 行)，但你如果使用正确的工具把函数代码折叠起来，你会发现这简单，你也写得出，而且它包含了实现 “命令行图形界面” 的必要代码，例如如何移动光标、如何清除屏幕等，你依葫芦画瓢也能写出来！Standalone 编译可能会遇到一些小麻烦 (但如果你有好的编程基础，不用怕，你可以解决这些小问题)，一旦解决了一些未定义的函数问题，你就真的得到了一个可以编译运行的文本编辑器：</p>
<p><img src="img/vi.c.png" alt=""/></p>
<p>没错。我们就是通过编写各种有趣的实际程序理解操作系统为应用程序提供的对象和 API——在这些对象和 API 上构建了我们肉眼可见的一切：浏览器、编辑器、游戏、游戏外挂、虚拟机……包括为了帮助大家更好地理解操作系统的 API，我们还设置了若干 Linux 系统上的 Mini Programming Labs，每个 200 行左右的代码，实际调用 Linux 操作系统 API 完成一些仅使用 C 标准库难以办到的任务。</p>
<h3>🔑-2 <strong>在硬件眼中，操作系统 = C 程序</strong></h3>
<widget><p>如果你完全理解了操作系统中有什么对象、如何操纵它们，就只剩一个问题：你能用计算机硬件提供的机制把这些对象和 API 实现出来吗？实际上，运算和访存指令、I/O、中断/异常和虚存就是我们实现操作系统所需的全部。<red>实现</red>操作系统就是硬件和体系结构知识基础上的普通 “编程活”。</p></widget>
<p>从我们初学编程开始就知道，我们的代码从 main 函数开始执行，下面的程序能打印出 Hello World:</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;Hello World\n&quot;</span>; *p; p++) {
   <span class="hljs-built_in">putchar</span>(*p);
  }
}
</code></pre>
<p>一模一样的代码，能直接在没有操作系统的硬件上运行，并且打印出 Hello World 吗？答案是肯定的——前提是我们需要做好一系列的准备：AI 也给出了 “需要做什么” 的正确答案：</p>
<ol>
<li><strong>启动代码 (Bootloader)</strong>：在没有操作系统的硬件上，你需要一个启动加载程序 (bootloader) 来初始化硬件并加载你的程序到内存中。</li>
<li><strong>硬件初始化</strong>：你的程序需要包含初始化硬件的代码，比如设置堆栈、初始化中断向量表、配置时钟、设置内存管理单元等。</li>
<li><strong>直接硬件访问</strong>：你需要编写代码直接与硬件通信，比如通过内存映射的I/O或特殊的硬件寄存器来发送字符到串行端口、LCD显示屏或其他输出设备。</li>
<li><strong>自定义输出函数</strong>：由于标准库函数如 <code>putchar</code> 不可用，你需要编写自己的输出函数来替代它，这个函数将直接与你选择的输出硬件接口交互。</li>
</ol>
<p>没错！我们的确需要编写一些 “底层代码”，一旦编写完成 (也不用害怕，我们会为同学们提供友好的代码框架)，我们的 “操作系统” 就完全可以用 C 语言编写了。事实上，UNIX 自诞生以来，就不断有人在实现新的操作系统——一个成功的例子就是 Linux，在它之上还有或许更为成功的 Android。UNIX 也有更多 “迷你版” 的替代实现，能容易地帮助大家理解代码背后的原理。我们在课堂上选用 <a href="http://pdos.csail.mit.edu/6.S081/xv6">xv6-riscv</a> 作为讲解操作系统的例子。同时，大家也需要在 Operating System Labs 中，从 “裸机” (bare-metal) 编程开始，自底向上实现一个支持多处理器、文件系统、虚拟存储的迷你操作系统内核。</p>
<h3>🔑-3 <strong>在上帝眼中，操作系统 = 一个数学对象</strong></h3>
<widget><p>这也是我们多年以来找到最有趣的视角：我们可以把计算机系统 (电路) 建模成有限状态机模型，当然也可以把运行在硬件上的任何软件 (包括操作系统) 建模成状态机。这个视角不仅可以给我们带来许多有趣的思想实验，也指导我们真正把 “数学对象” 实现出来，并用代码自动分析和<red>理解</red>它们。</p></widget>
<p>我们从小到大学过很多数学，我们习惯于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = \sin(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 这样的 “函数”。但 “函数” 的定义发生了微妙的变化：我们可以在 <code>main</code> “函数” 里调用 <code>printf()</code> 打印，因此计算机世界中的函数，和数学世界中的函数就很难被联系起来了。</p>
<p>从另一个角度，数学的视角又总是伴随着我们的计算机程序。例如，我们可以把编译器想象成一个，它接受一个程序 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span> 作为输入，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C = f(P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mclose">)</span></span></span></span> 得到编译后的二进制代码。同样，我们也可以把计算机想象成一个数学函数，如果把所有内存、寄存器的数值想象成一个巨大的数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span>，计算机每执行一条指令，就会得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x&#x27; = f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，即 “执行指令之后的计算机状态”。</p>
<p>如果我们的计算机系统和程序都是数学对象，我们能不能像研究数学对象一样 (例如，证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x) = x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 相对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span> 轴对称)，证明关于计算机程序和系统的数学性质？答案是肯定的。我们将在这门课中用通俗的方式引入 “形式化方法”，而这个视角最终将帮助我们更严格地理解计算机系统地方方面面。</p>
<h3>迈出第一步</h3>
<p>你也许倒在实验的第一步：</p>
<ul>
<li>“在命令行中 git pull origin M1 下载框架代码。”</li>
</ul>
<p>你也许感到不知所措——但无论是互联网还是人工智能，都可以很好地帮到你。你可以向人工智能提问：</p>
<ul>
<li>“我的实验要求我在命令行中 git pull origin M1 下载框架代码。这个命令做了什么？”</li>
</ul>
<p>你会得到很不错的回答：</p>
<ul>
<li><code>git pull origin M1</code> 这个命令在 Git 版本控制系统中执行了几个操作。为了更好地理解这个命令，我们可以将其分解为几个部分：<!-- -->
<ol>
<li><strong><code>git</code></strong>：这是调用 Git 命令行工具的方式，所有 Git 命令都以它开始。</li>
<li><strong><code>pull</code></strong>：这个命令用于将更改从远程仓库合并到当前分支中。它实际上是两个命令的组合：<code>git fetch</code> 后跟 <code>git merge</code>。首先，<code>git fetch</code> 从指定的远程仓库下载最新的内容。然后，<code>git merge</code> 将这些更改合并到当前分支中。</li>
<li><strong><code>origin</code></strong>：这是远程仓库的默认名称。当你克隆一个仓库时，Git 自动为你的远程仓库命名为 &quot;origin&quot;。这是一个约定俗成的名称，指向你克隆的仓库的原始服务器位置。</li>
<li><strong><code>M1</code></strong>：这指的是远程仓库中的一个分支名。在这个上下文中，<code>M1</code> 是你想要从远程仓库 <code>origin</code> 拉取并合并到你当前分支的目标分支。</li>
</ol>
</li>
</ul>
<p>所以，<red>迈出第一步最重要的，莫过于坚信所有的问题都能得到满意的解答，然后去花时间理解其中的来龙去脉</red>。如果你感到恐惧，请记住：坚持住，进入未知领域，<red><strong>从简单的、能理解的东西试起，投入时间，就有收获</strong></red>。<a href="References.md">参考资料</a>中有一些非常棒的入门材料，例如 “Harley Hahn&#x27;s Guide to Unix and Linux”，引人入胜 (这本书不是写给计算机专业人士的，所以它异常好读且有中文版)。从这里开始，你就能慢慢克服恐惧了。</p>
<p>同样，你可能会对一小段程序 (例如课堂上的示例代码) 感到难以理解。程序难读是很正常的——但程序的运行时状态是好理解的。无非就是数字和指针嘛。请你勇敢地打开你的调试器，设置一个断点，单步执行你的程序。不知道怎么调试？调试的时候没有代码？做好阅读互联网资料的准备，也准备好你身边的 AI 助手，然后现在就开始吧！</p></div></div><div class="bg-neutral-100 text-center text-neutral-600 dark:bg-neutral-600 dark:text-neutral-200 lg:text-left"><div class="bg-neutral-200 p-6 text-center dark:bg-neutral-700"><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons License: BY-NC 4.0</a><br/><a href="https://beian.miit.gov.cn/">苏 ICP 备 2020049101 号</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    blockquote: \"blockquote\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\",\n    ol: \"ol\",\n    math: \"math\",\n    semantics: \"semantics\",\n    mrow: \"mrow\",\n    mi: \"mi\",\n    mo: \"mo\",\n    annotation: \"annotation\",\n    msup: \"msup\",\n    mn: \"mn\"\n  }, _provideComponents(), props.components), {Quiz} = _components;\n  if (!Quiz) _missingMdxReference(\"Quiz\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"生存指南\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"操作系统是一门十分硬核的编程课\"\n      }), \"，因此如果你还没有完全准备好开始 “编程”、开始面对别人的代码，那可能你需要细心规划一下你的学习路线。当然，也不必焦虑，一来可能 “没学好编程” 不完全是你的责任，二来万事总有开头：\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Don't Panic.\"\n        }), \" ——The Hitchhiker's Guide to the Galaxy\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 操作系统为什么难学？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一直以来，老师们觉得《操作系统》课难教的原因主要是其中的主题既多、涉及的知识又深入，点面无法兼得。举个例子，同学们到目前为止编写的大部分代码都是串行的，就好像是写一个程序模仿 “一个人”，一次执行一步动作。通常《操作系统》课都是第一个引入并发编程的课程 (因为操作系统是最早的并发程序)，也就是你需要协同多个共享内存的 “多个人” 时，会遇到很多你也许意料之外的问题。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"很显然，你 “想不清” 这个问题——可以预计，人类已经和并发编程的问题肉搏了几十年，时至今日仍有创新。那么，把这个话题 “讲清楚” 自然是极难的。更糟糕的是，很多课程试图把 “牛逼的现代操作系统” 概念放到课程中 (也许是为了装逼)，但这无异于空中楼阁。《操作系统》课要讲清楚的问题包括：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"操作系统应该为应用程序提供怎样的 API？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如何用硬件实现多个进程的并发/并行？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如何编写能够工作的并发程序，它不会在压力负载下随时随地崩溃？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如何维持多个隔离的执行流？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如何在磁盘上实现持久的数据结构？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"……\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在解决这些问题上作出突出贡献的人已经得过 n 个图灵奖了——每一个问题都不是吃素的。我们的课程试图把这些问题的来龙去脉、解决方法、代码实现都掌握好，已经相当有挑战性。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"操作系统 “难学” 的另一个原因是，想要理解 “操作系统为什么要做成今天这样”，就需要相当的应用编程经验——很多在你有了编程经验后 “理所应当” 的事情，在还不会编程的时候就显得很生硬。某位资深教师曾经问我：“copy-on-write fork 为什么需要引用计数？” 我一时语塞：如果一个共享资源可以自由共享，除了 gc 和引用计数，就没有简单明了的方法去释放它了。这一部分是因为我们的课程设置 “高不成低不就”：\"\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"停下来想一想️\",\n      question: \"进入大学，第一门编程课的职责到底是什么？\",\n      options: ['学会用 API 把内心所想用代码表达出来并且爱上编程', '深入理解一门编程语言的语法和语义，向语言律师迈进一步', '引导学生取得学分，卷得 GPA'],\n      answer: 0,\n      comment: \"从游戏、数值计算、符号求解到深度学习，“编程” 是改变世界的力量。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果你还没有爱上编程，那花一点时间 (包括学习《操作系统》课) 绝对是值得的。现在我们假设大家已经爱上编程，讨论操作系统该怎么学。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 操作系统该怎么学？\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Don't Panic. Everything is a state machine.\"\n        }), \" ——The Hitchhiker's Guide to Operating Systems\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"幸运的是，我们在多年的经验里找到了理解操作系统的三把 “钥匙” (尤其是很特别的第三把钥匙)，从三个视角里，“从外向里” 一点一点深入地观测操作系统，直到形成对操作系统完整、一致的理解。\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"🔑-1 \", _jsx(_components.strong, {\n        children: \"在程序眼中，操作系统 = 对象 + API\"\n      })]\n    }), \"\\n\", _jsx(\"widget\", {\n      children: _jsxs(_components.p, {\n        children: [\"操作系统为应用程序提供了执行的基础环境、一系列操作系统对象和操作它们的 API——至少对于今天的操作系统来说，这些东西都是精确定义、触手可及的。我们可以在课堂上通过代码片段、调试工具、日志、trace 等等实在地触摸到操作系统为应用程序提供的一切。这就帮助我们理解现代操作系统\", _jsx(\"red\", {\n          children: \"设计\"\n        }), \"背后的思路。\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我们会学习真实操作系统中的程序是什么，以及如何借助操作系统提供的 API 为操作系统编程。具体来说，我们的选择是 Linux (准确来说是 POSIX) 作为课程教学的平台，因为它既免费也自由 (能知道它内部的实现)，而且互联网上有丰富的 (英文) 文档。它的设计继承自 “Keep it simple, stupid” 的 UNIX，这个经典的设计背后的动机反而更容易为第一次接触操作系统的初学者所理解，也会贯穿整个课程。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"选择 Linux 的另一个原因是它的开源基础——你能找到 Linux 世界中几乎任何程序的源代码！例如，你是否好奇 “文本编辑器” 是怎样实现的？命令行中的 Vim 看起来很酷，但你可能没有学过实现它所必须的编程知识。一方面，你可以求助 AI，另一方面，你也可以直接找一个 “简化版” 的实现，例如早期 busybox 的 \", _jsx(_components.a, {\n        href: \"https://git.busybox.net/busybox/tree/editors/vi.c?h=1_00_stable\",\n        children: \"vi.c\"\n      }), \"。扫一眼代码，你甚至会发现下面的注释：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/* To compile for standalone use:\\n *\\tgcc -Wall -Os -s -DSTANDALONE -o vi vi.c ... */\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"看不懂也没关系，我们有人工智能。AI 给了相当好的答案：\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"GPT-4-turbo: 这个命令是在使用 GCC (GNU Compiler Collection) 编译器编译一个名为 \", _jsx(_components.code, {\n          children: \"vi.c\"\n        }), \" 的C语言源文件，并生成一个名为 \", _jsx(_components.code, {\n          children: \"vi\"\n        }), \" 的可执行文件。命令中的各个选项含义如下：\", _jsx(_components.code, {\n          children: \"-Wall\"\n        }), \": 开启所有的警告信息，帮助开发者发现代码中可能的问题。\", _jsx(_components.code, {\n          children: \"-Os\"\n        }), \": 优化编译后的代码，使其在大小上进行优化，即尽可能减小生成的可执行文件的大小。\", _jsx(_components.code, {\n          children: \"-s\"\n        }), \": 去除符号表和调试信息，这也有助于减小最终可执行文件的大小。\", _jsx(_components.code, {\n          children: \"-DSTANDALONE\"\n        }), \": 定义一个宏 \", _jsx(_components.code, {\n          children: \"STANDALONE\"\n        }), \"，这通常用于条件编译。在源代码中，可以使用 \", _jsx(_components.code, {\n          children: \"#ifdef STANDALONE\"\n        }), \" 来检查这个宏是否被定义，从而决定是否编译某些特定的代码块。\", _jsx(_components.code, {\n          children: \"-o vi\"\n        }), \": 指定输出的可执行文件名为 \", _jsx(_components.code, {\n          children: \"vi\"\n        }), \"。综上所述，这个命令的目的是编译 \", _jsx(_components.code, {\n          children: \"vi.c\"\n        }), \" 文件，并生成一个优化过的、体积较小的、没有调试信息的 \", _jsx(_components.code, {\n          children: \"vi\"\n        }), \" 可执行文件。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个文件也许比你写过的任何项目都大 (4000 行)，但你如果使用正确的工具把函数代码折叠起来，你会发现这简单，你也写得出，而且它包含了实现 “命令行图形界面” 的必要代码，例如如何移动光标、如何清除屏幕等，你依葫芦画瓢也能写出来！Standalone 编译可能会遇到一些小麻烦 (但如果你有好的编程基础，不用怕，你可以解决这些小问题)，一旦解决了一些未定义的函数问题，你就真的得到了一个可以编译运行的文本编辑器：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"img/vi.c.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"没错。我们就是通过编写各种有趣的实际程序理解操作系统为应用程序提供的对象和 API——在这些对象和 API 上构建了我们肉眼可见的一切：浏览器、编辑器、游戏、游戏外挂、虚拟机……包括为了帮助大家更好地理解操作系统的 API，我们还设置了若干 Linux 系统上的 Mini Programming Labs，每个 200 行左右的代码，实际调用 Linux 操作系统 API 完成一些仅使用 C 标准库难以办到的任务。\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"🔑-2 \", _jsx(_components.strong, {\n        children: \"在硬件眼中，操作系统 = C 程序\"\n      })]\n    }), \"\\n\", _jsx(\"widget\", {\n      children: _jsxs(_components.p, {\n        children: [\"如果你完全理解了操作系统中有什么对象、如何操纵它们，就只剩一个问题：你能用计算机硬件提供的机制把这些对象和 API 实现出来吗？实际上，运算和访存指令、I/O、中断/异常和虚存就是我们实现操作系统所需的全部。\", _jsx(\"red\", {\n          children: \"实现\"\n        }), \"操作系统就是硬件和体系结构知识基础上的普通 “编程活”。\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"从我们初学编程开始就知道，我们的代码从 main 函数开始执行，下面的程序能打印出 Hello World:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *p = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello World\\\\n\\\"\"\n        }), \"; *p; p++) {\\n   \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"putchar\"\n        }), \"(*p);\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一模一样的代码，能直接在没有操作系统的硬件上运行，并且打印出 Hello World 吗？答案是肯定的——前提是我们需要做好一系列的准备：AI 也给出了 “需要做什么” 的正确答案：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"启动代码 (Bootloader)\"\n        }), \"：在没有操作系统的硬件上，你需要一个启动加载程序 (bootloader) 来初始化硬件并加载你的程序到内存中。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"硬件初始化\"\n        }), \"：你的程序需要包含初始化硬件的代码，比如设置堆栈、初始化中断向量表、配置时钟、设置内存管理单元等。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"直接硬件访问\"\n        }), \"：你需要编写代码直接与硬件通信，比如通过内存映射的I/O或特殊的硬件寄存器来发送字符到串行端口、LCD显示屏或其他输出设备。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"自定义输出函数\"\n        }), \"：由于标准库函数如 \", _jsx(_components.code, {\n          children: \"putchar\"\n        }), \" 不可用，你需要编写自己的输出函数来替代它，这个函数将直接与你选择的输出硬件接口交互。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"没错！我们的确需要编写一些 “底层代码”，一旦编写完成 (也不用害怕，我们会为同学们提供友好的代码框架)，我们的 “操作系统” 就完全可以用 C 语言编写了。事实上，UNIX 自诞生以来，就不断有人在实现新的操作系统——一个成功的例子就是 Linux，在它之上还有或许更为成功的 Android。UNIX 也有更多 “迷你版” 的替代实现，能容易地帮助大家理解代码背后的原理。我们在课堂上选用 \", _jsx(_components.a, {\n        href: \"http://pdos.csail.mit.edu/6.S081/xv6\",\n        children: \"xv6-riscv\"\n      }), \" 作为讲解操作系统的例子。同时，大家也需要在 Operating System Labs 中，从 “裸机” (bare-metal) 编程开始，自底向上实现一个支持多处理器、文件系统、虚拟存储的迷你操作系统内核。\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"🔑-3 \", _jsx(_components.strong, {\n        children: \"在上帝眼中，操作系统 = 一个数学对象\"\n      })]\n    }), \"\\n\", _jsx(\"widget\", {\n      children: _jsxs(_components.p, {\n        children: [\"这也是我们多年以来找到最有趣的视角：我们可以把计算机系统 (电路) 建模成有限状态机模型，当然也可以把运行在硬件上的任何软件 (包括操作系统) 建模成状态机。这个视角不仅可以给我们带来许多有趣的思想实验，也指导我们真正把 “数学对象” 实现出来，并用代码自动分析和\", _jsx(\"red\", {\n          children: \"理解\"\n        }), \"它们。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们从小到大学过很多数学，我们习惯于 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"y\"\n                }), _jsx(_components.mo, {\n                  children: \"=\"\n                }), _jsx(_components.mi, {\n                  children: \"sin\"\n                }), _jsx(_components.mo, {\n                  children: \"⁡\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"x\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"y = \\\\sin(x)\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.625em\",\n                verticalAlign: \"-0.1944em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.03588em\"\n              },\n              children: \"y\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mop\",\n              children: \"sin\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            })]\n          })]\n        })]\n      }), \" 这样的 “函数”。但 “函数” 的定义发生了微妙的变化：我们可以在 \", _jsx(_components.code, {\n        children: \"main\"\n      }), \" “函数” 里调用 \", _jsx(_components.code, {\n        children: \"printf()\"\n      }), \" 打印，因此计算机世界中的函数，和数学世界中的函数就很难被联系起来了。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"从另一个角度，数学的视角又总是伴随着我们的计算机程序。例如，我们可以把编译器想象成一个，它接受一个程序 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mi, {\n                  children: \"P\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"P\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6833em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.13889em\"\n              },\n              children: \"P\"\n            })]\n          })\n        })]\n      }), \" 作为输入，而 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"C\"\n                }), _jsx(_components.mo, {\n                  children: \"=\"\n                }), _jsx(_components.mi, {\n                  children: \"f\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"P\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"C = f(P)\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6833em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.07153em\"\n              },\n              children: \"C\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.10764em\"\n              },\n              children: \"f\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.13889em\"\n              },\n              children: \"P\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            })]\n          })]\n        })]\n      }), \" 得到编译后的二进制代码。同样，我们也可以把计算机想象成一个数学函数，如果把所有内存、寄存器的数值想象成一个巨大的数字 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mi, {\n                  children: \"x\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"x\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.4306em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            })]\n          })\n        })]\n      }), \"，计算机每执行一条指令，就会得到 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsxs(_components.msup, {\n                  children: [_jsx(_components.mi, {\n                    children: \"x\"\n                  }), _jsx(_components.mo, {\n                    mathvariant: \"normal\",\n                    lspace: \"0em\",\n                    rspace: \"0em\",\n                    children: \"′\"\n                  })]\n                }), _jsx(_components.mo, {\n                  children: \"=\"\n                }), _jsx(_components.mi, {\n                  children: \"f\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"x\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"x' = f(x)\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.7519em\"\n              }\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mord mathnormal\",\n                children: \"x\"\n              }), _jsx(_components.span, {\n                className: \"msupsub\",\n                children: _jsx(_components.span, {\n                  className: \"vlist-t\",\n                  children: _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.7519em\"\n                      },\n                      children: _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.063em\",\n                          marginRight: \"0.05em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"2.7em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"sizing reset-size6 size3 mtight\",\n                          children: _jsx(_components.span, {\n                            className: \"mord mtight\",\n                            children: _jsx(_components.span, {\n                              className: \"mord mtight\",\n                              children: \"′\"\n                            })\n                          })\n                        })]\n                      })\n                    })\n                  })\n                })\n              })]\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.10764em\"\n              },\n              children: \"f\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            })]\n          })]\n        })]\n      }), \"，即 “执行指令之后的计算机状态”。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果我们的计算机系统和程序都是数学对象，我们能不能像研究数学对象一样 (例如，证明 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"f\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"x\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                }), _jsx(_components.mo, {\n                  children: \"=\"\n                }), _jsxs(_components.msup, {\n                  children: [_jsx(_components.mi, {\n                    children: \"x\"\n                  }), _jsx(_components.mn, {\n                    children: \"2\"\n                  })]\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"f(x) = x^2\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.10764em\"\n              },\n              children: \"f\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.8141em\"\n              }\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mord mathnormal\",\n                children: \"x\"\n              }), _jsx(_components.span, {\n                className: \"msupsub\",\n                children: _jsx(_components.span, {\n                  className: \"vlist-t\",\n                  children: _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.8141em\"\n                      },\n                      children: _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.063em\",\n                          marginRight: \"0.05em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"2.7em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"sizing reset-size6 size3 mtight\",\n                          children: _jsx(_components.span, {\n                            className: \"mord mtight\",\n                            children: \"2\"\n                          })\n                        })]\n                      })\n                    })\n                  })\n                })\n              })]\n            })]\n          })]\n        })]\n      }), \" 相对于 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mi, {\n                  children: \"y\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"y\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.625em\",\n                verticalAlign: \"-0.1944em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.03588em\"\n              },\n              children: \"y\"\n            })]\n          })\n        })]\n      }), \" 轴对称)，证明关于计算机程序和系统的数学性质？答案是肯定的。我们将在这门课中用通俗的方式引入 “形式化方法”，而这个视角最终将帮助我们更严格地理解计算机系统地方方面面。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"迈出第一步\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"你也许倒在实验的第一步：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"“在命令行中 git pull origin M1 下载框架代码。”\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"你也许感到不知所措——但无论是互联网还是人工智能，都可以很好地帮到你。你可以向人工智能提问：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"“我的实验要求我在命令行中 git pull origin M1 下载框架代码。这个命令做了什么？”\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"你会得到很不错的回答：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"git pull origin M1\"\n        }), \" 这个命令在 Git 版本控制系统中执行了几个操作。为了更好地理解这个命令，我们可以将其分解为几个部分：\", \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"git\"\n              })\n            }), \"：这是调用 Git 命令行工具的方式，所有 Git 命令都以它开始。\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"pull\"\n              })\n            }), \"：这个命令用于将更改从远程仓库合并到当前分支中。它实际上是两个命令的组合：\", _jsx(_components.code, {\n              children: \"git fetch\"\n            }), \" 后跟 \", _jsx(_components.code, {\n              children: \"git merge\"\n            }), \"。首先，\", _jsx(_components.code, {\n              children: \"git fetch\"\n            }), \" 从指定的远程仓库下载最新的内容。然后，\", _jsx(_components.code, {\n              children: \"git merge\"\n            }), \" 将这些更改合并到当前分支中。\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"origin\"\n              })\n            }), \"：这是远程仓库的默认名称。当你克隆一个仓库时，Git 自动为你的远程仓库命名为 \\\"origin\\\"。这是一个约定俗成的名称，指向你克隆的仓库的原始服务器位置。\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"M1\"\n              })\n            }), \"：这指的是远程仓库中的一个分支名。在这个上下文中，\", _jsx(_components.code, {\n              children: \"M1\"\n            }), \" 是你想要从远程仓库 \", _jsx(_components.code, {\n              children: \"origin\"\n            }), \" 拉取并合并到你当前分支的目标分支。\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"所以，\", _jsx(\"red\", {\n        children: \"迈出第一步最重要的，莫过于坚信所有的问题都能得到满意的解答，然后去花时间理解其中的来龙去脉\"\n      }), \"。如果你感到恐惧，请记住：坚持住，进入未知领域，\", _jsx(\"red\", {\n        children: _jsx(_components.strong, {\n          children: \"从简单的、能理解的东西试起，投入时间，就有收获\"\n        })\n      }), \"。\", _jsx(_components.a, {\n        href: \"References.md\",\n        children: \"参考资料\"\n      }), \"中有一些非常棒的入门材料，例如 “Harley Hahn's Guide to Unix and Linux”，引人入胜 (这本书不是写给计算机专业人士的，所以它异常好读且有中文版)。从这里开始，你就能慢慢克服恐惧了。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"同样，你可能会对一小段程序 (例如课堂上的示例代码) 感到难以理解。程序难读是很正常的——但程序的运行时状态是好理解的。无非就是数字和指针嘛。请你勇敢地打开你的调试器，设置一个断点，单步执行你的程序。不知道怎么调试？调试的时候没有代码？做好阅读互联网资料的准备，也准备好你身边的 AI 助手，然后现在就开始吧！\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"frontmatter":{}},"__N_SSG":true},"page":"/[[...index]]","query":{"index":["OS","Guide.md"]},"buildId":"a2FwJzUPGFGc0QcwaUr13","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>