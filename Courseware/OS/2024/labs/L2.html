<!DOCTYPE html><html>
<head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>L2: 内核线程管理 (kmt)</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/><link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css"/><meta name="next-head-count" content="5"/><link rel="preload" href="../../../_next/static/css/e993edd6a18ef4f0.css" as="style"/><link rel="stylesheet" href="../../../_next/static/css/e993edd6a18ef4f0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="../../../_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="../../../_next/static/chunks/webpack-f73d82589f972e7d.js" defer=""></script><script src="../../../_next/static/chunks/framework-66d32731bdd20e83.js" defer=""></script><script src="../../../_next/static/chunks/main-3929bf55b0f13a18.js" defer=""></script><script src="../../../_next/static/chunks/pages/_app-00b06920b385caf1.js" defer=""></script><script src="../../../_next/static/chunks/pages/%5b%5b...index%5d%5d-877ec949b69be209.js" defer=""></script><script src="../../../_next/static/a2FwJzUPGFGc0QcwaUr13/_buildManifest.js" defer=""></script><script src="../../../_next/static/a2FwJzUPGFGc0QcwaUr13/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-slate-300/10"><div class="sticky top-0 z-40 w-full backdrop-blur flex-none border-b border-slate-900/10 bg-white/75 supports-backdrop-blur:bg-white/60"><div class="max-w-8xl mx-auto"><div class="py-4 border-b border-slate-900/10 lg:px-8 lg:border-0 dark:border-slate-300/10 mx-4 lg:mx-0"><div class="relative flex items-center"><a href="../../../index.html">Yanyan's wiki</a><form class="text-xs text-slate-500"> for <input type="text" name="token" class="font-mono text-xs w-16" maxLength="8"/></form><div class="relative hidden lg:flex items-center ml-4 pl-4 border-l"><nav class="text-sm leading-6 font-semibold text-slate-700 dark:text-slate-200"><ul class="flex space-x-8"><li><a class="hover:text-sky-500 dark:hover:text-sky-400" href="../../2025/index.html">操作系统 (2025 春)</a></li></ul></nav></div></div></div></div></div><div class="container mx-auto max-w-5xl flex flex-col min-h-screen px-4"><div class="wiki bg-neutral-200/10"><h1>L2: 内核线程管理 (kmt)</h1>
<div class="box yellow-box"><div><span class="float-left text-4xl mr-3 mt-2">⏰</span><span class="font-serif text-lg border-b border-slate-600"><b>Soft Deadline: 同 Hard Deadline</b></span><div class="font-serif pt-2"><red><strong>本实验在 L1 代码的基础上完成</strong>。但如果你完全没有完成 L1，依然可以合并代码并开始 L2 (例如使用一个非常简单的 kalloc/kfree 实现)。</red><p>在命令行中 <code>git pull origin L2</code> 下载框架代码。<strong><red>本次实验提交时，需要设置环境变量 <code>MODULE</code> 为 <code>L2</code></red></strong> (如果你将 export 写在了 Makefile 里，需要相应作出修改，否则将提交到过往的实验)。</p><p>本次实验的报告直接在 <code>kernel/</code> 目录下原先的实验报告基础上添加。除非特殊情况，本次实验的实验报告<strong>不建议超过 2 页 A4 纸</strong>。请在实验报告中描述你在实验中遇到的特别值得一提的事件，例如你代码的架构设计、特别精巧的实现、遇到印象深刻的 bug 等。</p></div></div></div>
<div class="box slate-box"><div><span class="float-left text-4xl mr-3 mt-2">⚖️</span><span class="font-serif text-lg border-b border-slate-600"><b>L2 - kmt</b></span><div class="font-serif pt-2"><p>请输入 Token 登录。</p></div></div></div>
<h2>1. 背景</h2>
<p>真正的 “操作系统内核” 开始于课堂上的示例代码 “线程操作系统”：</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2"><button class="hover:bg-blue-300 text-white font-bold px-2 rounded"><img class="w-10" src="../../img/vscode.svg"/></button></span><span class="font-serif text-lg border-b border-slate-600"><b></b></span><div class="font-serif pt-2"><div></div></div></div></div>
<p>线程操作系统实现了共享内存的状态机 (线程) 之间的主动和被动切换：在线程执行时中断到来，操作系统代码开始执行并保存处理器运行的寄存器现场；在中断返回时，可以选择任何一个进程/线程已经保存的寄存器现场恢复。在这个实验中，我们扩展 thread-os，实现多处理器操作系统内核中的内核线程 API (就像 pthreads 库，或是课堂上展示的 <code>thread.h</code>)。在完成这个实验后，你就得到了一个可以分时抢占式运行多任务的 “嵌入式操作系统”。</p>
<h2>2. 实验描述</h2>
<h3>2.1 操作系统内核：线程与同步</h3>
<p>本次实验在 pmm 的基础上，增加中断和线程管理的功能。和 thread-os 类似，操作系统代码会设置接管中断/系统调用/异常时的回调函数，并且实现线程的生命周期函数以及同步机制。</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>更新你的 pmm</b></span><div class="font-serif pt-2"><p>本次实验 pmm 模块的接口保持不变 (沿用你上一次的实现即可)。但因为处理器上的线程随时可能被中断，你需要在 Lab1 <strong>线程安全</strong>的基础上实现<strong>中断安全</strong>——这可以通过使用类似 xv6 spinlock 的方式实现。</p></div></div></div>
<p>本次实验在 os 模块中新增了 <code>trap</code> 和 <code>on_irq</code> 两个函数，分别是系统中唯一中断/系统调用的入口和中断处理程序的回调注册。</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>实验要求：实现 Kernel Multi-threading</b></span><div class="font-serif pt-2"><p>本次实验的主要任务是实现 kmt 模块中的函数，你需要完成 <code>struct task</code>, <code>struct spinlock</code>, <code>struct semaphore</code> 的定义，并实现 kmt 的全部 API。</p></div></div></div>
<pre><code class="hljs language-c"><span class="hljs-keyword">typedef</span> Context *(*<span class="hljs-type">handler_t</span>)(Event, Context *);
MODULE(os) {
    <span class="hljs-type">void</span> (*init)();
    <span class="hljs-type">void</span> (*run)();
    Context *(*trap)(Event ev, Context *context);
    <span class="hljs-type">void</span> (*on_irq)(<span class="hljs-type">int</span> seq, <span class="hljs-type">int</span> event, <span class="hljs-type">handler_t</span> handler);
};

MODULE(pmm) {
    <span class="hljs-type">void</span>  (*init)();
    <span class="hljs-type">void</span> *(*alloc)(<span class="hljs-type">size_t</span> size);
    <span class="hljs-type">void</span>  (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);
};

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task</span> <span class="hljs-title">task_t</span>;</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">spinlock_t</span>;</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">sem_t</span>;</span>
MODULE(kmt) {
    <span class="hljs-type">void</span> (*init)();
    <span class="hljs-type">int</span>  (*create)(<span class="hljs-type">task_t</span> *task, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span> *arg), <span class="hljs-type">void</span> *arg);
    <span class="hljs-type">void</span> (*teardown)(<span class="hljs-type">task_t</span> *task);
    <span class="hljs-type">void</span> (*spin_init)(<span class="hljs-type">spinlock_t</span> *lk, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name);
    <span class="hljs-type">void</span> (*spin_lock)(<span class="hljs-type">spinlock_t</span> *lk);
    <span class="hljs-type">void</span> (*spin_unlock)(<span class="hljs-type">spinlock_t</span> *lk);
    <span class="hljs-type">void</span> (*sem_init)(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> value);
    <span class="hljs-type">void</span> (*sem_wait)(<span class="hljs-type">sem_t</span> *sem);
    <span class="hljs-type">void</span> (*sem_signal)(<span class="hljs-type">sem_t</span> *sem);
};
</code></pre>
<h3>2.2 OS (Operating Systems) 模块</h3>
<p>框架代码的 main 函数发生了一些修改：</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    ioe_init();
    cte_init(os->trap);
    os->init();
    mpe_init(os->run);
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</code></pre>
<p>在上一个实验中，框架代码在 <code>os->init()</code> 后直接 <code>mpe->init()</code> 启动多个线程运行内存分配/回收。框架代码中的 ioe_init 和 cte_init 是本次实验新加入的，调用它们并不会立即生效——此时处理器的中断处于关闭状态，除非执行非法操作，否则 <code>os->trap</code> 不会被调用。</p>
<p>虽然你不能修改框架代码 (或者说你可以修改，但提交到 Online Judge 后，会被替换)，但你可以控制 <code>os->init()</code> 的行为，例如，你可能需要在其中执行模块的初始化 (框架代码不会调用模块的初始化)：
但你可能会在其中增加 kmt 模块的初始化：</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_init</span><span class="hljs-params">()</span> {
    pmm->init();
    kmt->init();
}
</code></pre>
<p>在 <code>os->init()</code> 初始化完成后，<code>mpe_init</code> 会让每个处理器都运行相同的 <code>os->run()</code> 代码。此时，操作系统就真正化身成为了中断处理程序：</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>实验要求：实现中断处理和上下文切换</b></span><div class="font-serif pt-2"><p>中断、系统调用、异常都会调用 <code>os->trap(ev, context)</code>。中断/异常发生后，AbstractMachine 会将寄存器保存到栈上，我们推荐你对 <code>context</code> 做一个拷贝 (这样容易保证正确性)，并用 thread-os 类似的方式实现上下文切换。每个处理器都各自管理中断，<code>os->trap()</code> 也会在多处理之间并行执行，因此你需要用自旋锁保护好其中的共享变量 (小心死锁，并保持中断关闭)。</p></div></div></div>
<p>中断处理程序几乎就是 “整个操作系统”。为了增加代码的可维护性，防止在增加新的功能时都直接去修改 <code>os->trap</code> 的代码，我们提供了中断处理 API：</p>
<center><p><code>os->on_irq(seq, event, handler)</code></p></center>
<p>调用 <code>os->on_irq</code> 向操作系统内核 “注册” 一个中断处理程序：在 <code>os->trap(ev, ctx)</code> 执行时，当 <code>ev.event</code> (事件编号) 和 <code>event</code> 匹配时，调用 <code>handler(event, ctx);</code>。更多的细节：</p>
<ul>
<li><code>seq</code> 决定了 handler 被调用的顺序，<code>seq</code> 小的 handler 先被调用。<code>seq</code> 相同的按任意顺序调用；</li>
<li>当 <code>event == EVENT_NULL</code> 时，在任何中断/异常时都调用 <code>handler</code>；</li>
<li>我们允许一个且仅一个 handler 返回一个 <code>Context</code>，在中断返回时恢复到这个 conetxt。当多个 handler 都返回 context 时，是 undefined behavior。</li>
</ul>
<p><code>os->on_irq</code> 的设计类似于 “面向切面编程” (<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspected-Oriented Programming, AOP</a>) 的设计。我们的 os 模块并不需要知道系统中有多少中断、多少设备驱动程序可能会处理中断，而是让每个需要响应中断的组件：设备驱动、系统调用，甚至是调度器自行注册中断处理程序。</p>
<p>例如，如果我们希望在 I/O 设备发生中断时，向键盘驱动的信号量执行一个 V 操作，我们只需要：</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> Context *<span class="hljs-title function_">input_notify</span><span class="hljs-params">(Event ev, Context *context)</span> {
    kmt->sem_signal(&sem_kbdirq); <span class="hljs-comment">// 在 IO 设备中断到来时，执行 V 操作唤醒一个线程</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-type">void</span> <span class="hljs-title function_">input_init</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// seq == 100 是随意设置的，我们并不在意何时调用</span>
    os->on_irq(<span class="hljs-number">100</span>, EVENT_IRQ_IODEV, input_notify); 
    ...
}
</code></pre>
<p>甚至在 jyy 的参考实现中，寄存器现场保存、执行调度程序的代码，也都是用 <code>on_irq</code> 注册的 (尽管你并不必要这么做，可以把这部分代码直接写在 <code>os->trap</code> 中)：</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// thread.c，线程管理</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kmt_init</span><span class="hljs-params">()</span> {
    ...
    os->on_irq(INT_MIN, EVENT_NULL, kmt_context_save);   <span class="hljs-comment">// 总是最先调用</span>
    os->on_irq(INT_MAX, EVENT_NULL, kmt_schedule);       <span class="hljs-comment">// 总是最后调用</span>
    ...
}
</code></pre>
<p>如果上述代码被执行，那么按照注册时的 sequence number 进行调用：</p>
<ul>
<li>在时钟中断发生时依次调用 <code>kmt_context_save</code> (<code>INT_MIN</code>) 和 <code>kmt_schedule</code> (<code>INT_MAX</code>)；</li>
<li>在键盘中断发生时依次调用 <code>kmt_context_save</code> (<code>INT_MIN</code>), <code>input_notify</code> (<code>100</code>), 和 <code>kmt_schedule</code> (<code>INT_MAX</code>)</li>
</ul>
<p>而 <code>os->trap()</code> 的实现依然保持简单：</p>
<pre><code class="hljs language-c++"><span class="hljs-function"><span class="hljs-type">static</span> Context *<span class="hljs-title">os_trap</span><span class="hljs-params">(Event ev, Context *ctx)</span> </span>{
    Context *next = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &h: handlers_sorted_by_seq) {
        <span class="hljs-keyword">if</span> (h.event == EVENT_NULL || h.event == ev.event) {
            Context *r = h.<span class="hljs-built_in">handler</span>(ev, ctx);
            <span class="hljs-built_in">panic_on</span>(r && next, <span class="hljs-string">"return to multiple contexts"</span>);
            <span class="hljs-keyword">if</span> (r) next = r;
        }
    }
    <span class="hljs-built_in">panic_on</span>(!next, <span class="hljs-string">"return to NULL context"</span>);
    <span class="hljs-built_in">panic_on</span>(<span class="hljs-built_in">sane_context</span>(next), <span class="hljs-string">"return to invalid context"</span>);
    <span class="hljs-keyword">return</span> next;
}
</code></pre>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>防御性的 Assertions</b></span><div class="font-serif pt-2"><div class="py-1">我们上面的代码中有很多防御性的 assertions——看起来有些多余，但可以逮住一些小错，最大程度保护你们不受伤害——例如在某个罕见的执行路径上，你忘记返回 context，或是 context 已经被损坏，你会得到 assertion failure 而不是虚拟机的神秘重启。你可以考虑一下 `sane_context` 是如何实现的——例如，我们要求 RIP 总是位于代码段。此外，当前的 assert failure 只能打印出失败的位置。如果你写一小段代码，能够打印出 call stack frame，那会极大程度简化你们调试的过程——虽然这不是必须的。</div><ol class="quiz-card p-0 ml-8 my-1"></ol></div></div></div>
<h3>2.3 PMM (Physical Memory Management) 模块</h3>
<p>pmm 与之前行为一致，但因为它被调用的场景增加了 (并不是每个 CPU 只是连续不断地执行代码，而是 CPU 可能被中断)，我们需要稍稍对它进行改进：</p>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>实现线程安全的内存分配</b></span><div class="font-serif pt-2"><p>允许任意线程调用 <code>pmm->alloc</code> 和 <code>pmm->free</code>。此外，允许在中断处理程序中分配和回收内存。因此简单起见，不允许 <code>pmm->alloc()</code> 和 <code>pmm->free()</code> 被中断。</p></div></div></div>
<p>小心：如果你在 <code>kmt->init()</code> 的时候调用 <code>pmm->alloc()</code>，此时自旋锁可能还没有完成必要的初始化。</p>
<h3>2.4 KMT (Kernel Multi-Threading) 模块</h3>
<h4>2.4.1 模块初始化</h4>
<p><code>kmt->init()</code> 负责初始化必要的数据，例如分配一些重要的数据结构。我们预期你会在 <code>os->init()</code> 时调用 <code>kmt->init()</code>。整个系统启动只调用一次 <code>kmt->init()</code>。</p>
<h4>2.4.2 线程管理</h4>
<pre><code class="hljs language-c"><span class="hljs-type">int</span>  (*create)(<span class="hljs-type">task_t</span> *task, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span> *arg), <span class="hljs-type">void</span> *arg);
<span class="hljs-type">void</span> (*teardown)(<span class="hljs-type">task_t</span> *task);
</code></pre>
<p>其中 <code>create</code> 在系统中创建一个线程 (<code>task_t</code> 应当事先被分配好)，这个线程立即就可以被调度执行 (但调用 create 时中断可能处于关闭状态，在打开中断后它才获得被调度执行的权利)。我们假设 <code>create</code> 创建的线程永不返回——但它有可能在永远不会被调度执行的情况下被调用 <code>kmt->teardown</code> 回收。</p>
<p><code>teardown</code> 相应回收为线程分配的资源——例如你可能会为 <code>task_t</code> 动态分配内存：</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">kmt_create</span><span class="hljs-params">(<span class="hljs-type">task_t</span> *task, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span> *arg), <span class="hljs-type">void</span> *arg)</span> {
    ...
    task-><span class="hljs-built_in">stack</span> = pmm->alloc(STACK_SIZE); <span class="hljs-comment">// 动态分配内核栈</span>
    ...
}
</code></pre>
<p>这部分的内存需要在 <code>teardown()</code> 时被回收。线程只有在永远不会被调度到处理器上执行的前提下才能被回收。你可以假设回收的时候线程不再持有任何自旋锁或在信号量上等待。</p>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>create/teardown: 实现线程安全性</b></span><div class="font-serif pt-2"><p>允许任意线程调用 <code>create</code>/<code>teardown</code>。不会在中断处理程序中调用 <code>create</code>/<code>teardown</code>。</p></div></div></div>
<h4>2.4.3 自旋锁</h4>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> (*spin_init)(<span class="hljs-type">spinlock_t</span> *lk, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name);
<span class="hljs-type">void</span> (*spin_lock)(<span class="hljs-type">spinlock_t</span> *lk);
<span class="hljs-type">void</span> (*spin_unlock)(<span class="hljs-type">spinlock_t</span> *lk);
</code></pre>
<p>lock-unlock 实现保护一段强原子性 (任何其他线程、中断处理程序、其他处理器都不能同时得到同一把锁)：</p>
<ul>
<li>允许在中断处理程序中调用自旋锁；</li>
<li>允许任意在任意处理器的任意线程中调用自旋锁；</li>
<li><code>spin_lock</code> 将会关闭处理器的中断，因此对一个处理器而言，持有任何一个自旋锁之后就不会再发生线程切换；</li>
<li><code>spin_unlock</code> 在解除最后一个当前处理器持有的自旋锁之后，需要将处理器的中断状态恢复。例如在中断处理程序中，中断是关闭的，因此 <code>spin_unlock</code> 不应该打开中断；但在一般的线程中，<code>spin_unlock</code> 后应当恢复处理器的中断。</li>
</ul>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>自旋锁：线程安全、中断安全</b></span><div class="font-serif pt-2"><p>允许任意线程调用 <code>spin_init</code>, <code>spin_lock</code> 和 <code>spin_unlock</code>。中断处理程序允许调用 <code>spin_lock</code> 和 <code>spin_unlock</code>。</p></div></div></div>
<h4>2.4.4 信号量</h4>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> (*sem_init)(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> value);
<span class="hljs-type">void</span> (*sem_wait)(<span class="hljs-type">sem_t</span> *sem);
<span class="hljs-type">void</span> (*sem_signal)(<span class="hljs-type">sem_t</span> *sem);
</code></pre>
<p>在信号量初始化时，<code>value</code> 指定了它初始的数值。初始时 <code>value == 1</code> 可以把信号量当互斥锁；初始时 <code>value == 0</code> 可以把信号量作为生产者-消费者缓冲区管理实现。<code>sem_wait</code> 和 <code>sem_signal</code> 分别对应了 P/V 操作。</p>
<ul>
<li>允许在线程中执行信号量的 <code>sem_wait</code> 操作。在 P 操作执行没有相应资源时，线程将被阻塞 (不再被调度执行)。中断没有对应的线程、不能阻塞，因此不能在中断时调用 <code>sem_wait</code>；</li>
<li>允许在任意状态下任意执行 <code>sem_signal</code>，包括任何处理器中的任何线程和任何处理器的任何中断。</li>
</ul>
<p>在信号量实现时，大约需要做以下几件事 (任何一本操作系统教材上都会提到类似的实现)：</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span> {
    spin_lock(&sem->lock); <span class="hljs-comment">// 获得自旋锁</span>
    sem->count--; <span class="hljs-comment">// 自旋锁保证原子性</span>
    <span class="hljs-keyword">if</span> (...) {
        <span class="hljs-comment">// 没有资源，需要等待</span>
        ...
        mark_as_not_runnable(current); <span class="hljs-comment">// 当前线程不能再执行</span>
    }
    spin_unlock(&sem->unlock);
    <span class="hljs-keyword">if</span> (...) {    <span class="hljs-comment">// 如果 P 失败，不能继续执行</span>
                  <span class="hljs-comment">// (注意此时可能有线程执行 V 操作)</span>
        yield();  <span class="hljs-comment">// 引发一次上下文切换</span>
    }
}
</code></pre>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>信号量：线程安全、中断安全</b></span><div class="font-serif pt-2"><p>允许任意线程调用 <code>sem_init</code>, <code>sem_wait</code> 和 <code>sem_signal</code>。中断处理程序不可睡眠，但可以在中断处理程序中调用 <code>sem_signal</code>。</p></div></div></div>
<h2>3. 正确性标准</h2>
<p>native 处于长久没有维护的阶段，因此为了实验的稳定性，我们总是以 qemu (x86-64 和 i386) 为准。Online Judge 评测时只有 <code>x86-qemu</code> 和 <code>x86_64-qemu</code>。</p>
<p>我们测试代码的时候，会替换我们的 <code>framework</code> 目录 (os.h 除外)，因此你对其中文件 (例如 kernel.h) 的任何修改都会被消除。注意到我们的测试代码需要数据结构 (<code>sem_t</code> 等) 的定义，而这些定义并不在 kernel.h 中，因此你需要在 os.h 中包含它们，否则测试代码将无法编译。测试代码框架如下：</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string"><klib.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string"><klib-macros.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string"><am.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string"><common.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string"><os.h></span></span>

... <span class="hljs-comment">// 此处省略测试代码</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *args)</span> {
    ioe_init();
    cte_init(os->trap);
    os->init();

    init_workload(args); <span class="hljs-comment">// 我们有自己的 workload</span>
    mpe_init(os->run);
}
</code></pre>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>不要打印多余的输出，不要启动设备。</b></span><div class="font-serif pt-2"><p>操作系统随时可能被中断——如果你在中断处理程序中打印了日志，可能会和其他日志混合在一起，从而影响 Online Judge 的正确性判断。我们建议你使用自己的 log 或 printk 函数 (而不是 printf; 我们的测试程序会使用 printf)，且它们的行为由预编译指令控制，仅在你本地编译时才打印数据。</p><p>当然这也不是绝对的。例如，系统启动时 (<code>mpe_init</code> 之前) 打印少量日志，不会引起问题。<red>另外，提交时请不要激活官方测试用例 (例如向 tty 输出)，它可能会导致测试失败</red>。</p></div></div></div>
<h3>3.1 Safety 和 Liveness</h3>
<p>在任意时刻，操作系统中都可能有多个线程，你需要设计调度的策略在多个处理器中调度这些线程，使系统中能够被执行的线程尽可能不发生饥饿。</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>实验要求 (Hard Tests)：多处理器调度</b></span><div class="font-serif pt-2"><p>在线程数不过多的前提 (十几) 下，我们要求每个可运行的线程，给定足够长 (例如数秒) 的时间，能够被调度到每个处理器上执行。这个需求看起来很简单：稍微改一改 <code>thread-os.c</code> 的调度器就行了。但你要警惕了！这可能比你想象的困难得多。</p></div></div></div>
<p>经过 Lab1 的洗礼，你们应该意识到，写出正确的程序要从简单、有效的策略开始，盲目使用复杂的策略只会让你陷入 Wrong Answer 的泥潭。</p>
<h3>3.2 官方测试用例</h3>
<p>官方测试用例使你的 “操作系统” 看起来更像是个操作系统。但它并不能作为 “压力测试” 来帮助你检查 kmt 实现的正确性。我们为大家提供了 dev 模块及其实现 (已经包含在框架代码中)：</p>
<pre><code class="hljs language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">device_t</span>;</span>
MODULE(dev) {
    <span class="hljs-type">void</span> (*init)();
    <span class="hljs-type">device_t</span> *(*lookup)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name);
};
</code></pre>
<p>我们的官方测试用例还包含了以下设备的驱动。回顾 everything is a file，在 Linux 中，设备不过是一个实现了 <code>struct file_operations</code> 的对象。我们的 “操作系统” 中包含以下设备：</p>
<ul>
<li><code>input</code>，支持读取键盘的输入；</li>
<li><code>fb</code>，支持一个软件模拟的 2D 显示加速器的写入 (我们打算未来把这个显示加速器用真正的硬件实现)；</li>
<li><code>tty1</code>, <code>tty2</code>, 两个支持读写的虚拟终端，使用 Alt-1, Alt-2 在虚拟中断之间切换；</li>
<li><code>sda</code>, 支持读写的物理磁盘。你可以从中读出操作系统内核的 ELF 文件。</li>
</ul>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>调试正确驱动程序：并不是实验必要的要求</b></span><div class="font-serif pt-2"><p>在这个实验中，你并不需要调试正确所有的设备驱动程序 (但调试不通过一般意味着 Online Judge 会测试失败)。</p></div></div></div>
<p>代码合并后，你需要在 <code>os->init()</code> 中手工添加设备模块的初始化 <code>dev->init()</code>。如果实现正确，就能完成中断处理程序 (和若干设备相关线程) 的初始化。你不需要添加额外的代码，就能看到闪烁的光标，并且能看到输入字符的回显。此后，你就可以创建若干访问设备的线程，例如你可以为每个 tty 设备创建一个线程：</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">tty_reader</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> {
    <span class="hljs-type">device_t</span> *tty = dev->lookup(arg);
    <span class="hljs-type">char</span> cmd[<span class="hljs-number">128</span>], resp[<span class="hljs-number">128</span>], ps[<span class="hljs-number">16</span>];
    <span class="hljs-built_in">snprintf</span>(ps, <span class="hljs-number">16</span>, <span class="hljs-string">"(%s) $ "</span>, arg);
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        tty->ops->write(tty, <span class="hljs-number">0</span>, ps, <span class="hljs-built_in">strlen</span>(ps));
        <span class="hljs-type">int</span> nread = tty->ops->read(tty, <span class="hljs-number">0</span>, cmd, <span class="hljs-keyword">sizeof</span>(cmd) - <span class="hljs-number">1</span>);
        cmd[nread] = <span class="hljs-string">'\0'</span>;
        <span class="hljs-built_in">sprintf</span>(resp, <span class="hljs-string">"tty reader task: got %d character(s).\n"</span>, <span class="hljs-built_in">strlen</span>(cmd));
        tty->ops->write(tty, <span class="hljs-number">0</span>, resp, <span class="hljs-built_in">strlen</span>(resp));
    }
}

<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_init</span><span class="hljs-params">()</span> {
    ...
    kmt->create(task_alloc(), <span class="hljs-string">"tty_reader"</span>, tty_reader, <span class="hljs-string">"tty1"</span>);
    kmt->create(task_alloc(), <span class="hljs-string">"tty_reader"</span>, tty_reader, <span class="hljs-string">"tty2"</span>);
}
</code></pre>
<p><img src="../../img/lab2-drv.webp" alt=""/></p>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>真的实现了 “操作系统”</b></span><div class="font-serif pt-2"><div class="py-1">有了设备和线程，我们真的得到了一个小 “嵌入式操作系统”。顺着操作系统课程上讲过的内容，进程是戴上 VR 眼镜 (拥有独立地址空间) 的线程；而存储数据的文件是磁盘上的数据结构。理论上，我们的确可以在 “最小” 的操作系统内核中实现这些机制。</div><ol class="quiz-card p-0 ml-8 my-1"></ol></div></div></div>
<h3>3.3 Online Judge 上的测试用例</h3>
<p>与 L1 类似，我们的测试代码会使用 Online Judge 的 <code>framework</code> 代码 (包含一些测试用例、额外的运行时检查等)。框架代码会调用你的 <code>os->init()</code> 和 <code>os->run()</code>，就像下面的代码那样：</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> { ... }
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> { ... }
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">create_threads</span><span class="hljs-params">()</span> {
    ...
    kmt->create(pmm->alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">task_t</span>)),
                <span class="hljs-string">"test-thread-1"</span>, producer, xxx);
    kmt->create(pmm->alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">task_t</span>)),
                <span class="hljs-string">"test-thread-2"</span>, consumer, yyy);
    ...
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    ioe_init();
    cte_init(os->trap);
    os->init();
    create_threads();
    mpe_init(os->run); <span class="hljs-comment">// all cores call os->run()</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</code></pre>
<p>我们的 producer/consumer 可能就像上课的例子那样，管理 empty 和 fill 两个信号量，分别打印左括号和右括号，然后我们会检查输出是否满足 (1) 是合法括号序列的一个前缀; (2) 括号嵌套的深度是否超过要求。与 Lab1 一样，我们在测试时会链接一个我们实现正确的 klib，所以大家即便 klib 有 bug，也不必太过担心。</p>
<h2>4. 实验指南</h2>
<h3>4.1 坐下来，读一读代码</h3>
<p>我们推荐大家阅读的两份代码，首先是 thread-os，它提供了 “操作系统” 的大框架：</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2"><button class="hover:bg-blue-300 text-white font-bold px-2 rounded"><img class="w-10" src="../../img/vscode.svg"/></button></span><span class="font-serif text-lg border-b border-slate-600"><b></b></span><div class="font-serif pt-2"><div></div></div></div></div>
<p>此外就是 xv6，它包含了更多的实现细节，例如管道、文件……<red>上课时的代码调试演示对实验的生存是至关重要的</red>，尤其是其中的一些辅助脚本，它可以大幅提高调试的效率。例如，你应该结合 thread-os 在一次时钟中断后的代码，结合 AbstractMachine 的文档，你就能对中断到底发生了什么、AbstractMachine 到底做了什么有更加深入的认识——更重要的是，thread-os.c 是大家实现 Lab2 的一个 “基础性” 的框架。不要忘记了，我们的 Lab2 就是要实现丰富版的 thread-os.c!</p>
<h3>4.2 操作系统上的程序</h3>
<p>现在，我们的操作系统还不支持进程、文件系统等，但的确有了完善的物理内存管理和线程管理 API。换句话说，我们实现的是一个支持线程的 “嵌入式操作系统”，它能运行在没有 MMU 的硬件上。</p>
<p>为这样的一个操作系统编写 “应用程序”，就是直接在操作系统代码中静态链接一些函数，这些函数可以作为线程的入口，并且函数可以任意访问内核数据、直接以函数调用的形式调用操作系统内的 API。为了更好地理解实验要求，我们不妨给出一个课堂上 “生产者-消费者” 在我们操作系统上运行的例子。</p>
<p>首先，我们定义信号量 (kmt 实验需求部分)，并且用宏包装一下 P/V 操作 (这一步完全不必要也不是 best practice，只是为了让我们的代码看起来和课堂上讲解得一样)：</p>
<pre><code class="hljs language-c"><span class="hljs-type">sem_t</span> empty, fill;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> P kmt->sem_wait</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> V kmt->sem_signal</span>
</code></pre>
<p>接下来，我们写出个生产者/消费者线程的代码，就跟我们课堂上展示的 <code>threads.h</code> 完全一样：</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">T_produce</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> { <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) { P(&empty); putch(<span class="hljs-string">'('</span>); V(&fill);  } }
<span class="hljs-type">void</span> <span class="hljs-title function_">T_consume</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> { <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) { P(&fill);  putch(<span class="hljs-string">')'</span>); V(&empty); } }
</code></pre>
<p>然后，我们在操作系统初始化 (<code>os->init</code>) 中创建若干个生产者/消费者线程，其中利用了物理内存的分配：</p>
<pre><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">task_t</span> *<span class="hljs-title function_">task_alloc</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> pmm->alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">task_t</span>));
}

<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">run_test1</span><span class="hljs-params">()</span> {
    kmt->sem_init(&empty, <span class="hljs-string">"empty"</span>, N);
    kmt->sem_init(&fill,  <span class="hljs-string">"fill"</span>,  <span class="hljs-number">0</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i < NPROD; i++) {
        kmt->create(task_alloc(), <span class="hljs-string">"producer"</span>, T_produce, <span class="hljs-literal">NULL</span>);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i < NCONS; i++) {
        kmt->create(task_alloc(), <span class="hljs-string">"consumer"</span>, T_consume, <span class="hljs-literal">NULL</span>);
    }
}

<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_init</span><span class="hljs-params">()</span> {
    pmm->init();
    kmt->init(); <span class="hljs-comment">// 模块先初始化</span>

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG_LOCAL</span>
    run_test1();
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
}
</code></pre>
<p>注意到上面的 <code>DEBUG_LOCAL</code> 宏。你们可以把这个宏的定义加载你们的 <code>CFLAGS</code> 里，这样你们在本地调试的时候就会创建用于测试的线程，但在 Online Judge 上则不会。这个行为对大家来说很重要：你们打印任何多余的输出，都可能导致 Wrong Answer。这个技巧同样可以用于在 Online Judge 上关闭额外的运行时检查，提高程序的执行速度。</p>
<p>如果你的代码实现正确，在模拟器上运行 (可以使用 <code>smp=2</code>, <code>smp=4</code> 等运行启动多个处理器) 能够看到打印出正确的括号序列：总是合法括号序列的前缀，且括号嵌套的深度不超过 5。带着这样的一个具体的操作系统的小 “测试”，你能更好地理解框架代码——它其实并不复杂。</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>本次实验的难点：正确性</b></span><div class="font-serif pt-2"><p>比起上一个实验，本次实验更难 “调对”。在这个实验中，我们预期你会遇到无数诡异的 bug，跑着跑着虚拟机就挂了，而且错得非常离谱，完全不知道发生了什么。对于并发程序，更难受的是可能要运行很多次，或者在某个特定的条件下 bug 才会触发。但你都相信 (1) 机器永远是对的; (2) 未测代码永远是错的。</p><p>当然，我们不排除 AbstractMachine 有 bug、gcc 有 bug、qemu 有 bug，甚至是你的处理器有 bug。但最终无论是哪里的问题，只要使用正确的编程方式，你最终都能找到这个 bug，机器永远是对的。处理器的 bug 是它的一个 “feature”。</p></div></div></div>
<h3>4.3 在 Bug 中活下来</h3>
<p>因此你实际回过头看，这个实验并不需要实现多少代码——比较紧凑的参考实现仅仅小几百行代码——不就是线程、自旋锁和信号量，加上一些零碎的代码 (中断处理的入口等) 嘛！那为什么实验要求要写那么长呢？还特别用红色字和灰色的底色标出 “线程/中断” 安全？是因为我们希望你的代码在多处理器、中断都存在的情况下保持正确。这不是一句空话，你下面会看到它实际的具体含义。或者说，你只有在做完实验以后，才会对下面这些话产生真正的理解：</p>
<ol>
<li>代码可以在多个处理器上被<strong>同时</strong>调用。因此你需要小心地保证原子性、顺序、可见性。千万小心：<code>kmt->create()</code>, <code>kmt->sem_signal()</code> 等所有函数都可能同时在多个处理器上被调用。你现在觉得这句话很可笑，你早就知道，但你调过 bug 就知道厉害了。</li>
<li>在中断处理程序中可以调用自旋锁。实际上，一个 CPU 的中断处理程序可以和另一个 CPU 访问同一个共享数据结构 (例如在中断中向链表里插入一个元素，这个链表被另一个线程读取)，因此自旋锁是保证正确性的重要手段。</li>
<li>小心数据竞争。一切共享的数据都可能会产生数据竞争——如果你没有保护好的话。有些内存访问悄悄在你意想不到的时候发生，例如对堆栈的访问——我们已经做出了提示，小心！小心！</li>
</ol>
<p>很快写着写着你就会发现自己的代码出 bug 了，有可能是并发的，有可能只是顺序的逻辑实现错了。如果出现了莫名其妙的异常、虚拟机神秘重启等情况不要惊慌，<strong>机器永远是对的</strong>，坐下来调代码吧。</p>
<h4>4.3.1 调试理论：再次复习</h4>
<p>在这两个学期的课程里，我们反复提到了调试理论——我们犯下的 bug 是 fault，它在运行时导致系统某个数值不符合预期 (specification), 这是一个 error，而只有最终虚拟机神秘卡死/重启/输出奇怪内容，我才真正证明了程序里 bug 的存在 (failure)。我建议大家再复习一下我们课程的视频 (并发 bug)，我们试图用这次课程来启发你，实现可靠软件系统是有迹可循的。</p>
<p>为了让 bug (fault) 更容易被找到，我们有两个想法：</p>
<ol>
<li>fault → error, 让更多的 bug 能在运行时被触发出来。这是通过详尽的测试实现的——你们已经在 Lab1 里饱受测试不充分的折磨了；而你们要知道，Lab1 Online Judge 的测试远谈不上充分。</li>
<li>error → failure, 让运行时错误的状态能尽快地被捕获。我们的 klib 里已经提供了以下有用的机制帮助你检查：<!-- -->
<ol>
<li><code>assert</code>, 你可以通过 assert 将程序应该满足的 specification (但代码未必体现) 写出来</li>
<li><code>panic</code>, 立即退出，通常是因为进入了某种不正常的状态</li>
<li><code>panic_on</code>, 条件成立时退出，检查不正常状态并退出</li>
</ol>
</li>
</ol>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>不要放弃 </b></span><div class="font-serif pt-2"><div class="py-1">相信大家有无数次想放弃。算了，成绩不要了。算了，抄作业吧。如果你坚持把 “独立完成” 想象成是对自己的训练，这是非常有益的。</div><ol class="quiz-card p-0 ml-8 my-1"></ol></div></div></div>
<p>在适当的地方加上 printf 和 assert 能帮助你快速定位到程序中出错的状态 (比如在中断到来时打印寄存器的现场，能快速帮你定位出现异常的位置)，缩小bug 的检查范围。</p>
<h4>4.3.2 更好的 log 方式</h4>
<p>相信大家都有过不停地加 <code>printf</code>, 删掉 <code>printf</code> 的调试体验吧。这感觉可不太好，找了一大圈，最后发现一开始删掉的 <code>printf</code> 打印的信息才是最有用的，不过一整天就已经过去了。</p>
<p>你可以考虑使用一些预编译选项控制 log 的开关：</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TRACE_F</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> TRACE_ENTRY printf(<span class="hljs-string">"[trace] %s:entry\n"</span>, __func__)</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> TRACE_EXIT printf(<span class="hljs-string">"[trace] %s:exit\n"</span>, __func__)</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> TRACE_ENTRY ((void)0)</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> TRACE_EXIT ((void)0)</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> {
  TRACE_ENTRY;
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"This is f.\n"</span>);
  TRACE_EXIT;
}
</code></pre>
<p>当然你也可以使用一些变量控制 log 的开关，例如设置 <code>print_registers_on_irq</code>。然后把这些开关控制统一放在程序的开头。</p>
<h4>4.3.3 使用调试器</h4>
<p>让然，如果各种 <code>printf</code> 和 log 都没办法帮你找到问题，也许上 gdb 是个不错的主意。框架代码里<strong>故意</strong>没有提供 <code>make debug</code> 的选项，但我们已经频繁地在课上展示了如何调试，qemu 为我们提供了丰富的命令行选项：</p>
<ul>
<li><code>-gdb</code> 能启动调试模式；</li>
<li><code>-S</code> 能让虚拟机在收到调试命令前不执行执行；</li>
<li>在 gdb 中可以用 <code>target</code> 命令连接远程调试；</li>
<li>用 <code>.gdbinit</code> (或 <code>-x</code>, <code>-ex</code> 选项) 能实现脚本的预先执行。在 Python 中 import gdb 即可获得完整控制 gdb 的能，例如我们轻松地实现了变速齿轮：</li>
</ul>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2"><button class="hover:bg-blue-300 text-white font-bold px-2 rounded"><img class="w-10" src="../../img/vscode.svg"/></button></span><span class="font-serif text-lg border-b border-slate-600"><b></b></span><div class="font-serif pt-2"><div></div></div></div></div>
<p>QEMU 也包含 log 可以帮助你调试神秘的 CPU 重启。当你真正走投无路的时候，你会发现这些工具才是调试系统软件里最重要的设施。</p>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>一些过来人的经验</b></span><div class="font-serif pt-2"><div class="py-1">同学们调试代码的能力有差别；jyy 一定程度上提倡 “OJ 有害” 理论：Online Judge，尤其是固定解决算法题的 Online Judge，无论你习惯多么的坏，花时间多多少少总是能调试出来的。但如果想要维护更大的程序，不正确地使用工具是不可能的——这里有一个有趣的陷阱：工具通常都有一定的学习曲线，因此如果你总是只写几十行的 OJ 程序，你就会建立一种 “不需要工具” 的错误习惯。但如果你能花一些时间走出舒适区，就会看到新的天地。</div><ol class="quiz-card p-0 ml-8 my-1"></ol></div></div></div>
<h3>4.3.4 保护自己不受伤害</h3>
<p>有些 bug 可能会非常难调试，这里举一个例子：栈溢出。也许已经有同学吃过苦头了：栈空间不是无限大的，而如果我们带着很大的局部变量或者递归很多层，栈就悄悄溢出了……在操作系统内核中，内核线程栈的溢出就显得更危险了，因为你可能会定义：</p>
<pre><code class="hljs language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_t</span> {</span>
    <span class="hljs-type">int32_t</span> id;
    ...
    <span class="hljs-type">uint8_t</span> <span class="hljs-built_in">stack</span>[STK_SZ];
};
</code></pre>
<p>而栈溢出 (x86 的栈从高地址向低地址生长) 的后果就是线程的信息可能被覆盖，出现各种诡异 (难以理解) 的情况，而且有可能 bug 若隐若现，加一条 printf 也许就不触发了。如果想避免这种情况的发生，可以给栈的前后加一些栅栏缓冲 (fences)，或者金丝雀 (canaries)，我们上课时也讲解过。</p>
<p>同理，我们可以在 kalloc/free 的时候做一些 hacking，这样可以帮助你检查出很多类型的 bugs，例如你可以在 free 以后将内存全部填为某一个 magic number，然后在关键的 pointer deference 的地方插入</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> uaf_check(ptr) \
    panic_on(MAGIC == *(uint32_t *)(ptr), <span class="hljs-string">"use-after-free"</span>);</span>

*ptr ... <span class="hljs-comment">// important pointer, e.g., current</span>
uaf_check(ptr)
</code></pre>
<p>这些 defensive 的编程方式，帮助你把代码中应该满足的 specification 明确地在代码中写出来——我们优先假设我们的代码是有 bug 的，而不是没有 bug 的。在此假设下，做的检查越多，越能减少 bug 对我们调试带来的痛苦。</p>
<p>最后，这几节中介绍的知识都是<strong>完全没有用</strong>的——如果你不写够大的代码，做够系统的项目，你永远都不会用到这里的知识，永远都不会想把 C 语言的能力发挥到极致。这里的知识对理论考试几乎完全没有任何帮助。但正是在种种细节上追求完美才成就了大型软件系统的成功。优雅的代码赏心悦目。关于操作系统内核，xv6 绝对是一份了不起的佳作，看似平淡无奇的代码里参透着系统设计的智慧，值得大家品味。</p>
<h2>4.4 实现能睡眠的互斥锁和信号量</h2>
<p>自旋锁大家参考课堂讲解的代码和 xv6 实现即可。但自旋锁虽然保证了多处理器资源不会被完全浪费 (在没有死锁的前提下，至少有一个处理器能一直执行)，但关中断对于长临界区来说是非常糟糕的一件事：</p>
<ul>
<li>长时间关中断会导致中断丢失；</li>
<li>其他处理器上试图获得锁的线程会大量浪费处理器资源自旋；</li>
<li>互斥中的代码可能需要等待中断 (例如希望互斥访问 I/O 设备的代码)。</li>
</ul>
<p>因此，这个实验很重要的要求就是在进入临界区后允许中断和线程切换，从而避免处理器在没有获得锁的前提下消除 “空转”。进一步想，假如某个线程执行 <code>lock(&lk)</code> 已经获得了锁正在执行，此时另一个线程执行了 <code>lock(&lk)</code> 但需要等待——这个等待预期的时间会比较长，因此与其不停地自旋，我们不如在自旋失败的时候，主动切换到其他线程执行：</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lk)</span> {
    <span class="hljs-keyword">while</span> (<span class="hljs-type">atomic_xchg</span>(&lk->locked, <span class="hljs-number">1</span>)) {
      yield(); <span class="hljs-comment">// 切换    </span>
    }
}

<span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lk)</span> {
    <span class="hljs-type">atomic_xchg</span>(&lk->locked, <span class="hljs-number">0</span>);
}
</code></pre>
<p>大家可以考虑一下，如果在关闭中断的时候 <code>yield()</code> 会发生什么。考虑清楚这个问题，请把计算机系统的执行想象成状态机；计算机的状态完全是由寄存器和内存的数值决定的，而控制中断开关的是处理器中的中断标志位。</p>
<p>虽然 <code>yield()</code> 能在一定程度上解决问题，但依然不够完美——如果等待锁的线程很多，轮着调度一遍也要花费很多的开销，我们不如做得彻底一点，给每个线程设置状态：<code>BLOCKED</code> (在等待某个锁，此时不能被调度执行)；<code>RUNNABLE</code> (可被调度执行)。由于决定下一个运行的线程完全是在中断处理函数中完成的，因此我们不妨为每一个线程增加一个 <code>status</code> 变量 (在 <code>Task</code> 中)，然后修改我们的调度程序，就可以让 <code>BLOCKED</code> 的线程不再占用处理器执行。以 thread-os 为例，原本三行的 on_interrupt 只要作出如下修改即可：</p>
<pre><code class="hljs language-c">Context *<span class="hljs-title function_">on_interrupt</span><span class="hljs-params">(Event ev, Context *ctx)</span> {
    <span class="hljs-comment">// Save context.</span>
    current->context = *ctx;

    <span class="hljs-comment">// Thread schedule.</span>
    current = current->next;
    <span class="hljs-keyword">while</span> (current->status != RUNNING) {
        current = current->next;
    }

    <span class="hljs-comment">// Restore current thread's context.</span>
    <span class="hljs-keyword">return</span> &current->context;
}
</code></pre>
<p>没错，只要通过对 “进程状态” 的一个小小的 hacking，我们就可以进一步实现可以睡眠的互斥锁：</p>
<ul>
<li>互斥锁由一把自旋锁保护，这大幅简化了我们理解的难度——同一把自旋锁保护的区域满足原子性、顺序和可见性；</li>
<li>如果在互斥锁上锁时，锁未被占用，则更新锁的状态并直接返回；</li>
<li>如果在互斥锁上锁时，锁已经被别的线程持有，则把当前线程放到锁的队列中，然后把当前线程标记为不 <code>RUNNABLE</code>。注意此时不能进入临界区执行，因此互斥锁函数不能立即返回。此时执行 <code>yield()</code> “自陷” (trap) 进入中断处理程序，触发调度器执行；</li>
<li>在互斥锁释放时，如果有线程在队列中等待，直接唤醒它即可。如果没有线程在等待，把锁恢复到可用的状态。</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">mutex_lock</span><span class="hljs-params">(<span class="hljs-type">mutexlock_t</span> *lk)</span> {
    <span class="hljs-type">int</span> acquired = <span class="hljs-number">0</span>;
    spin_lock(&lk->spinlock);
    <span class="hljs-keyword">if</span> (lk->locked != <span class="hljs-number">0</span>) {
        enqueue(lk->wait_list, current);
        current->status = BLOCKED;
    } <span class="hljs-keyword">else</span> {
        lk->locked = <span class="hljs-number">1</span>;
        acquired = <span class="hljs-number">1</span>;
    }
    spin_unlock(&lk->spinlock);
    <span class="hljs-keyword">if</span> (!acquired) yield(); <span class="hljs-comment">// 主动切换到其他线程执行</span>
}

<span class="hljs-type">void</span> <span class="hljs-title function_">mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">mutexlock_t</span> *lk)</span> {
  spin_lock(&lk->spinlock);
  <span class="hljs-keyword">if</span> (!empty(lk->wait_list)) {
      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_t</span> *<span class="hljs-title">task</span> =</span> dequeue(lk->wait_list);
      task->status = RUNNABLE; <span class="hljs-comment">// 唤醒之前睡眠的线程</span>
  } <span class="hljs-keyword">else</span> {
      lk->locked = <span class="hljs-number">0</span>;
  }
  spin_unlock(&lk->spinlock);
}
</code></pre>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>理解算法的方式</b></span><div class="font-serif pt-2"><div class="py-1">防把线程想象成人、把共享内存想象成物理世界。</div><ol class="quiz-card p-0 ml-8 my-1"></ol></div></div></div>
<p>在上述互斥锁的实现中个，如果 lock 调用失败，我们干脆不要自旋了，而是把自己加到一个等待的队列里，等到有人释放锁的时候再唤醒，这就好像是我们的lock/unlock 不再直接粗暴地去 “硬抢” (spin) 这把锁的使用权，而是类似于游泳馆那样的管理方法，现在先假设游泳池同一时间只能容纳一个人。每当同学 (线程) 试图获得锁 (试图进入游泳池) 时，都问管理员 (操作系统) 要手环。此时和管理员交谈的过程由一把自旋锁保护，防止其他同学强势插入打断。如果管理员 (操作系统) 此时有一个手环，就直接把手环给同学 (设置 <code>locked = 1</code>)，并且允许他进入游泳池 (<code>mutex_lock</code> 返回)。否则，线程就需要在管理员处排队 (然后线程睡眠，你可以理解成在队伍里专心致志地玩手机)，直到上一个同学出游泳馆 (<code>mutex_unlock</code>) 的时候把手环交换给管理员，戳一戳在队首的线程 (唤醒它)，队首的同学 (线程) 获得锁。此时如果没有排队的同学，管理员会把手环放到柜子里。</p>
<center><p><img src="../../img/locker.webp" alt=""/></p></center>
<center>获得手环，在游泳馆更衣室的同学。互斥锁保证了其他同学不能进入更衣室 (误</center>
<p>信号量和可以睡眠的互斥锁实现可以说是完全相同——只不过是我们的 <code>locked</code> 不再是一个 0 或 1 的数值，而是允许是更多的数值，它代表了手环的数量。</p></div></div><div class="bg-neutral-100 text-center text-neutral-600 dark:bg-neutral-600 dark:text-neutral-200 lg:text-left"><div class="bg-neutral-200 p-6 text-center dark:bg-neutral-700"><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons License: BY-NC 4.0</a><br/><a href="https://beian.miit.gov.cn/">苏 ICP 备 2020049101 号</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    strong: \"strong\",\n    p: \"p\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    pre: \"pre\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    h4: \"h4\",\n    img: \"img\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components), {Box, Submission, Demo, Quiz} = _components;\n  if (!Box) _missingMdxReference(\"Box\", true);\n  if (!Demo) _missingMdxReference(\"Demo\", true);\n  if (!Quiz) _missingMdxReference(\"Quiz\", true);\n  if (!Submission) _missingMdxReference(\"Submission\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"L2: 内核线程管理 (kmt)\"\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"⏰\",\n      title: \"Soft Deadline: 同 Hard Deadline\",\n      children: [_jsxs(\"red\", {\n        children: [_jsx(_components.strong, {\n          children: \"本实验在 L1 代码的基础上完成\"\n        }), \"。但如果你完全没有完成 L1，依然可以合并代码并开始 L2 (例如使用一个非常简单的 kalloc/kfree 实现)。\"]\n      }), _jsxs(_components.p, {\n        children: [\"在命令行中 \", _jsx(_components.code, {\n          children: \"git pull origin L2\"\n        }), \" 下载框架代码。\", _jsx(_components.strong, {\n          children: _jsxs(\"red\", {\n            children: [\"本次实验提交时，需要设置环境变量 \", _jsx(_components.code, {\n              children: \"MODULE\"\n            }), \" 为 \", _jsx(_components.code, {\n              children: \"L2\"\n            })]\n          })\n        }), \" (如果你将 export 写在了 Makefile 里，需要相应作出修改，否则将提交到过往的实验)。\"]\n      }), _jsxs(_components.p, {\n        children: [\"本次实验的报告直接在 \", _jsx(_components.code, {\n          children: \"kernel/\"\n        }), \" 目录下原先的实验报告基础上添加。除非特殊情况，本次实验的实验报告\", _jsx(_components.strong, {\n          children: \"不建议超过 2 页 A4 纸\"\n        }), \"。请在实验报告中描述你在实验中遇到的特别值得一提的事件，例如你代码的架构设计、特别精巧的实现、遇到印象深刻的 bug 等。\"]\n      })]\n    }), \"\\n\", _jsx(Submission, {\n      course: \"OS2024\",\n      module: \"L2\",\n      desc: \"L2 - kmt\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 背景\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"真正的 “操作系统内核” 开始于课堂上的示例代码 “线程操作系统”：\"\n    }), \"\\n\", _jsx(Demo, {\n      path: \"kernel/thread-os\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"线程操作系统实现了共享内存的状态机 (线程) 之间的主动和被动切换：在线程执行时中断到来，操作系统代码开始执行并保存处理器运行的寄存器现场；在中断返回时，可以选择任何一个进程/线程已经保存的寄存器现场恢复。在这个实验中，我们扩展 thread-os，实现多处理器操作系统内核中的内核线程 API (就像 pthreads 库，或是课堂上展示的 \", _jsx(_components.code, {\n        children: \"thread.h\"\n      }), \")。在完成这个实验后，你就得到了一个可以分时抢占式运行多任务的 “嵌入式操作系统”。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 实验描述\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.1 操作系统内核：线程与同步\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"本次实验在 pmm 的基础上，增加中断和线程管理的功能。和 thread-os 类似，操作系统代码会设置接管中断/系统调用/异常时的回调函数，并且实现线程的生命周期函数以及同步机制。\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"🗒️\",\n      title: \"更新你的 pmm\",\n      children: _jsxs(_components.p, {\n        children: [\"本次实验 pmm 模块的接口保持不变 (沿用你上一次的实现即可)。但因为处理器上的线程随时可能被中断，你需要在 Lab1 \", _jsx(_components.strong, {\n          children: \"线程安全\"\n        }), \"的基础上实现\", _jsx(_components.strong, {\n          children: \"中断安全\"\n        }), \"——这可以通过使用类似 xv6 spinlock 的方式实现。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"本次实验在 os 模块中新增了 \", _jsx(_components.code, {\n        children: \"trap\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"on_irq\"\n      }), \" 两个函数，分别是系统中唯一中断/系统调用的入口和中断处理程序的回调注册。\"]\n    }), \"\\n\", _jsx(Box, {\n      logo: \"🗒️\",\n      title: \"实验要求：实现 Kernel Multi-threading\",\n      children: _jsxs(_components.p, {\n        children: [\"本次实验的主要任务是实现 kmt 模块中的函数，你需要完成 \", _jsx(_components.code, {\n          children: \"struct task\"\n        }), \", \", _jsx(_components.code, {\n          children: \"struct spinlock\"\n        }), \", \", _jsx(_components.code, {\n          children: \"struct semaphore\"\n        }), \" 的定义，并实现 kmt 的全部 API。\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typedef\"\n        }), \" Context *(*\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"handler_t\"\n        }), \")(Event, Context *);\\nMODULE(os) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*init)();\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*run)();\\n    Context *(*trap)(Event ev, Context *context);\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*on_irq)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" seq, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" event, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"handler_t\"\n        }), \" handler);\\n};\\n\\nMODULE(pmm) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \"  (*init)();\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" *(*alloc)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"size_t\"\n        }), \" size);\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \"  (*\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"free\"\n        }), \")(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" *ptr);\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typedef\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-class\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"struct\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"task\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"task_t\"\n          }), \";\"]\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typedef\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-class\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"struct\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"spinlock\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"spinlock_t\"\n          }), \";\"]\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typedef\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-class\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"struct\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"semaphore\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"sem_t\"\n          }), \";\"]\n        }), \"\\nMODULE(kmt) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*init)();\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \"  (*create)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"task_t\"\n        }), \" *task, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *name, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*entry)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" *arg), \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" *arg);\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*teardown)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"task_t\"\n        }), \" *task);\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*spin_init)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"spinlock_t\"\n        }), \" *lk, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *name);\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*spin_lock)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"spinlock_t\"\n        }), \" *lk);\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*spin_unlock)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"spinlock_t\"\n        }), \" *lk);\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*sem_init)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"sem_t\"\n        }), \" *sem, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *name, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" value);\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*sem_wait)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"sem_t\"\n        }), \" *sem);\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*sem_signal)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"sem_t\"\n        }), \" *sem);\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.2 OS (Operating Systems) 模块\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"框架代码的 main 函数发生了一些修改：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    ioe_init();\\n    cte_init(os-\u003etrap);\\n    os-\u003einit();\\n    mpe_init(os-\u003erun);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在上一个实验中，框架代码在 \", _jsx(_components.code, {\n        children: \"os-\u003einit()\"\n      }), \" 后直接 \", _jsx(_components.code, {\n        children: \"mpe-\u003einit()\"\n      }), \" 启动多个线程运行内存分配/回收。框架代码中的 ioe_init 和 cte_init 是本次实验新加入的，调用它们并不会立即生效——此时处理器的中断处于关闭状态，除非执行非法操作，否则 \", _jsx(_components.code, {\n        children: \"os-\u003etrap\"\n      }), \" 不会被调用。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"虽然你不能修改框架代码 (或者说你可以修改，但提交到 Online Judge 后，会被替换)，但你可以控制 \", _jsx(_components.code, {\n        children: \"os-\u003einit()\"\n      }), \" 的行为，例如，你可能需要在其中执行模块的初始化 (框架代码不会调用模块的初始化)：\\n但你可能会在其中增加 kmt 模块的初始化：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"os_init\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    pmm-\u003einit();\\n    kmt-\u003einit();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在 \", _jsx(_components.code, {\n        children: \"os-\u003einit()\"\n      }), \" 初始化完成后，\", _jsx(_components.code, {\n        children: \"mpe_init\"\n      }), \" 会让每个处理器都运行相同的 \", _jsx(_components.code, {\n        children: \"os-\u003erun()\"\n      }), \" 代码。此时，操作系统就真正化身成为了中断处理程序：\"]\n    }), \"\\n\", _jsx(Box, {\n      logo: \"🗒️\",\n      title: \"实验要求：实现中断处理和上下文切换\",\n      children: _jsxs(_components.p, {\n        children: [\"中断、系统调用、异常都会调用 \", _jsx(_components.code, {\n          children: \"os-\u003etrap(ev, context)\"\n        }), \"。中断/异常发生后，AbstractMachine 会将寄存器保存到栈上，我们推荐你对 \", _jsx(_components.code, {\n          children: \"context\"\n        }), \" 做一个拷贝 (这样容易保证正确性)，并用 thread-os 类似的方式实现上下文切换。每个处理器都各自管理中断，\", _jsx(_components.code, {\n          children: \"os-\u003etrap()\"\n        }), \" 也会在多处理之间并行执行，因此你需要用自旋锁保护好其中的共享变量 (小心死锁，并保持中断关闭)。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"中断处理程序几乎就是 “整个操作系统”。为了增加代码的可维护性，防止在增加新的功能时都直接去修改 \", _jsx(_components.code, {\n        children: \"os-\u003etrap\"\n      }), \" 的代码，我们提供了中断处理 API：\"]\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"os-\u003eon_irq(seq, event, handler)\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"调用 \", _jsx(_components.code, {\n        children: \"os-\u003eon_irq\"\n      }), \" 向操作系统内核 “注册” 一个中断处理程序：在 \", _jsx(_components.code, {\n        children: \"os-\u003etrap(ev, ctx)\"\n      }), \" 执行时，当 \", _jsx(_components.code, {\n        children: \"ev.event\"\n      }), \" (事件编号) 和 \", _jsx(_components.code, {\n        children: \"event\"\n      }), \" 匹配时，调用 \", _jsx(_components.code, {\n        children: \"handler(event, ctx);\"\n      }), \"。更多的细节：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"seq\"\n        }), \" 决定了 handler 被调用的顺序，\", _jsx(_components.code, {\n          children: \"seq\"\n        }), \" 小的 handler 先被调用。\", _jsx(_components.code, {\n          children: \"seq\"\n        }), \" 相同的按任意顺序调用；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"当 \", _jsx(_components.code, {\n          children: \"event == EVENT_NULL\"\n        }), \" 时，在任何中断/异常时都调用 \", _jsx(_components.code, {\n          children: \"handler\"\n        }), \"；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"我们允许一个且仅一个 handler 返回一个 \", _jsx(_components.code, {\n          children: \"Context\"\n        }), \"，在中断返回时恢复到这个 conetxt。当多个 handler 都返回 context 时，是 undefined behavior。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"os-\u003eon_irq\"\n      }), \" 的设计类似于 “面向切面编程” (\", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Aspect-oriented_programming\",\n        children: \"Aspected-Oriented Programming, AOP\"\n      }), \") 的设计。我们的 os 模块并不需要知道系统中有多少中断、多少设备驱动程序可能会处理中断，而是让每个需要响应中断的组件：设备驱动、系统调用，甚至是调度器自行注册中断处理程序。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"例如，如果我们希望在 I/O 设备发生中断时，向键盘驱动的信号量执行一个 V 操作，我们只需要：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" Context *\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"input_notify\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"(Event ev, Context *context)\"\n        }), \" {\\n    kmt-\u003esem_signal(\u0026sem_kbdirq); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 在 IO 设备中断到来时，执行 V 操作唤醒一个线程\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \";\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"input_init\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// seq == 100 是随意设置的，我们并不在意何时调用\"\n        }), \"\\n    os-\u003eon_irq(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \", EVENT_IRQ_IODEV, input_notify); \\n    ...\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"甚至在 jyy 的参考实现中，寄存器现场保存、执行调度程序的代码，也都是用 \", _jsx(_components.code, {\n        children: \"on_irq\"\n      }), \" 注册的 (尽管你并不必要这么做，可以把这部分代码直接写在 \", _jsx(_components.code, {\n        children: \"os-\u003etrap\"\n      }), \" 中)：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// thread.c，线程管理\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"kmt_init\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    ...\\n    os-\u003eon_irq(INT_MIN, EVENT_NULL, kmt_context_save);   \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 总是最先调用\"\n        }), \"\\n    os-\u003eon_irq(INT_MAX, EVENT_NULL, kmt_schedule);       \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 总是最后调用\"\n        }), \"\\n    ...\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果上述代码被执行，那么按照注册时的 sequence number 进行调用：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"在时钟中断发生时依次调用 \", _jsx(_components.code, {\n          children: \"kmt_context_save\"\n        }), \" (\", _jsx(_components.code, {\n          children: \"INT_MIN\"\n        }), \") 和 \", _jsx(_components.code, {\n          children: \"kmt_schedule\"\n        }), \" (\", _jsx(_components.code, {\n          children: \"INT_MAX\"\n        }), \")；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"在键盘中断发生时依次调用 \", _jsx(_components.code, {\n          children: \"kmt_context_save\"\n        }), \" (\", _jsx(_components.code, {\n          children: \"INT_MIN\"\n        }), \"), \", _jsx(_components.code, {\n          children: \"input_notify\"\n        }), \" (\", _jsx(_components.code, {\n          children: \"100\"\n        }), \"), 和 \", _jsx(_components.code, {\n          children: \"kmt_schedule\"\n        }), \" (\", _jsx(_components.code, {\n          children: \"INT_MAX\"\n        }), \")\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"而 \", _jsx(_components.code, {\n        children: \"os-\u003etrap()\"\n      }), \" 的实现依然保持简单：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c++\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"static\"\n          }), \" Context *\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os_trap\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(Event ev, Context *ctx)\"\n          }), \" \"]\n        }), \"{\\n    Context *next = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"auto\"\n        }), \" \u0026h: handlers_sorted_by_seq) {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (h.event == EVENT_NULL || h.event == ev.event) {\\n            Context *r = h.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"handler\"\n        }), \"(ev, ctx);\\n            \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"panic_on\"\n        }), \"(r \u0026\u0026 next, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"return to multiple contexts\\\"\"\n        }), \");\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (r) next = r;\\n        }\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"panic_on\"\n        }), \"(!next, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"return to NULL context\\\"\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"panic_on\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"sane_context\"\n        }), \"(next), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"return to invalid context\\\"\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" next;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"防御性的 Assertions\",\n      question: \"我们上面的代码中有很多防御性的 assertions——看起来有些多余，但可以逮住一些小错，最大程度保护你们不受伤害——例如在某个罕见的执行路径上，你忘记返回 context，或是 context 已经被损坏，你会得到 assertion failure 而不是虚拟机的神秘重启。你可以考虑一下 `sane_context` 是如何实现的——例如，我们要求 RIP 总是位于代码段。此外，当前的 assert failure 只能打印出失败的位置。如果你写一小段代码，能够打印出 call stack frame，那会极大程度简化你们调试的过程——虽然这不是必须的。\",\n      options: [],\n      answer: \"0\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.3 PMM (Physical Memory Management) 模块\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"pmm 与之前行为一致，但因为它被调用的场景增加了 (并不是每个 CPU 只是连续不断地执行代码，而是 CPU 可能被中断)，我们需要稍稍对它进行改进：\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⚠️\",\n      title: \"实现线程安全的内存分配\",\n      children: _jsxs(_components.p, {\n        children: [\"允许任意线程调用 \", _jsx(_components.code, {\n          children: \"pmm-\u003ealloc\"\n        }), \" 和 \", _jsx(_components.code, {\n          children: \"pmm-\u003efree\"\n        }), \"。此外，允许在中断处理程序中分配和回收内存。因此简单起见，不允许 \", _jsx(_components.code, {\n          children: \"pmm-\u003ealloc()\"\n        }), \" 和 \", _jsx(_components.code, {\n          children: \"pmm-\u003efree()\"\n        }), \" 被中断。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"小心：如果你在 \", _jsx(_components.code, {\n        children: \"kmt-\u003einit()\"\n      }), \" 的时候调用 \", _jsx(_components.code, {\n        children: \"pmm-\u003ealloc()\"\n      }), \"，此时自旋锁可能还没有完成必要的初始化。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.4 KMT (Kernel Multi-Threading) 模块\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"2.4.1 模块初始化\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"kmt-\u003einit()\"\n      }), \" 负责初始化必要的数据，例如分配一些重要的数据结构。我们预期你会在 \", _jsx(_components.code, {\n        children: \"os-\u003einit()\"\n      }), \" 时调用 \", _jsx(_components.code, {\n        children: \"kmt-\u003einit()\"\n      }), \"。整个系统启动只调用一次 \", _jsx(_components.code, {\n        children: \"kmt-\u003einit()\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"2.4.2 线程管理\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \"  (*create)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"task_t\"\n        }), \" *task, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *name, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*entry)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" *arg), \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" *arg);\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*teardown)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"task_t\"\n        }), \" *task);\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"其中 \", _jsx(_components.code, {\n        children: \"create\"\n      }), \" 在系统中创建一个线程 (\", _jsx(_components.code, {\n        children: \"task_t\"\n      }), \" 应当事先被分配好)，这个线程立即就可以被调度执行 (但调用 create 时中断可能处于关闭状态，在打开中断后它才获得被调度执行的权利)。我们假设 \", _jsx(_components.code, {\n        children: \"create\"\n      }), \" 创建的线程永不返回——但它有可能在永远不会被调度执行的情况下被调用 \", _jsx(_components.code, {\n        children: \"kmt-\u003eteardown\"\n      }), \" 回收。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"teardown\"\n      }), \" 相应回收为线程分配的资源——例如你可能会为 \", _jsx(_components.code, {\n        children: \"task_t\"\n      }), \" 动态分配内存：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"kmt_create\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"task_t\"\n          }), \" *task, \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"const\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"char\"\n          }), \" *name, \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" (*entry)(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *arg), \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *arg)\"]\n        }), \" {\\n    ...\\n    task-\u003e\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"stack\"\n        }), \" = pmm-\u003ealloc(STACK_SIZE); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 动态分配内核栈\"\n        }), \"\\n    ...\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"这部分的内存需要在 \", _jsx(_components.code, {\n        children: \"teardown()\"\n      }), \" 时被回收。线程只有在永远不会被调度到处理器上执行的前提下才能被回收。你可以假设回收的时候线程不再持有任何自旋锁或在信号量上等待。\"]\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⚠️\",\n      title: \"create/teardown: 实现线程安全性\",\n      children: _jsxs(_components.p, {\n        children: [\"允许任意线程调用 \", _jsx(_components.code, {\n          children: \"create\"\n        }), \"/\", _jsx(_components.code, {\n          children: \"teardown\"\n        }), \"。不会在中断处理程序中调用 \", _jsx(_components.code, {\n          children: \"create\"\n        }), \"/\", _jsx(_components.code, {\n          children: \"teardown\"\n        }), \"。\"]\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"2.4.3 自旋锁\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*spin_init)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"spinlock_t\"\n        }), \" *lk, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *name);\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*spin_lock)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"spinlock_t\"\n        }), \" *lk);\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*spin_unlock)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"spinlock_t\"\n        }), \" *lk);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"lock-unlock 实现保护一段强原子性 (任何其他线程、中断处理程序、其他处理器都不能同时得到同一把锁)：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"允许在中断处理程序中调用自旋锁；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"允许任意在任意处理器的任意线程中调用自旋锁；\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"spin_lock\"\n        }), \" 将会关闭处理器的中断，因此对一个处理器而言，持有任何一个自旋锁之后就不会再发生线程切换；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"spin_unlock\"\n        }), \" 在解除最后一个当前处理器持有的自旋锁之后，需要将处理器的中断状态恢复。例如在中断处理程序中，中断是关闭的，因此 \", _jsx(_components.code, {\n          children: \"spin_unlock\"\n        }), \" 不应该打开中断；但在一般的线程中，\", _jsx(_components.code, {\n          children: \"spin_unlock\"\n        }), \" 后应当恢复处理器的中断。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⚠️\",\n      title: \"自旋锁：线程安全、中断安全\",\n      children: _jsxs(_components.p, {\n        children: [\"允许任意线程调用 \", _jsx(_components.code, {\n          children: \"spin_init\"\n        }), \", \", _jsx(_components.code, {\n          children: \"spin_lock\"\n        }), \" 和 \", _jsx(_components.code, {\n          children: \"spin_unlock\"\n        }), \"。中断处理程序允许调用 \", _jsx(_components.code, {\n          children: \"spin_lock\"\n        }), \" 和 \", _jsx(_components.code, {\n          children: \"spin_unlock\"\n        }), \"。\"]\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"2.4.4 信号量\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*sem_init)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"sem_t\"\n        }), \" *sem, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *name, \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" value);\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*sem_wait)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"sem_t\"\n        }), \" *sem);\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*sem_signal)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"sem_t\"\n        }), \" *sem);\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在信号量初始化时，\", _jsx(_components.code, {\n        children: \"value\"\n      }), \" 指定了它初始的数值。初始时 \", _jsx(_components.code, {\n        children: \"value == 1\"\n      }), \" 可以把信号量当互斥锁；初始时 \", _jsx(_components.code, {\n        children: \"value == 0\"\n      }), \" 可以把信号量作为生产者-消费者缓冲区管理实现。\", _jsx(_components.code, {\n        children: \"sem_wait\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"sem_signal\"\n      }), \" 分别对应了 P/V 操作。\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"允许在线程中执行信号量的 \", _jsx(_components.code, {\n          children: \"sem_wait\"\n        }), \" 操作。在 P 操作执行没有相应资源时，线程将被阻塞 (不再被调度执行)。中断没有对应的线程、不能阻塞，因此不能在中断时调用 \", _jsx(_components.code, {\n          children: \"sem_wait\"\n        }), \"；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"允许在任意状态下任意执行 \", _jsx(_components.code, {\n          children: \"sem_signal\"\n        }), \"，包括任何处理器中的任何线程和任何处理器的任何中断。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在信号量实现时，大约需要做以下几件事 (任何一本操作系统教材上都会提到类似的实现)：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sem_wait\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"sem_t\"\n          }), \" *sem)\"]\n        }), \" {\\n    spin_lock(\u0026sem-\u003elock); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 获得自旋锁\"\n        }), \"\\n    sem-\u003ecount--; \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 自旋锁保证原子性\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (...) {\\n        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 没有资源，需要等待\"\n        }), \"\\n        ...\\n        mark_as_not_runnable(current); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 当前线程不能再执行\"\n        }), \"\\n    }\\n    spin_unlock(\u0026sem-\u003eunlock);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (...) {    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 如果 P 失败，不能继续执行\"\n        }), \"\\n                  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// (注意此时可能有线程执行 V 操作)\"\n        }), \"\\n        yield();  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 引发一次上下文切换\"\n        }), \"\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⚠️\",\n      title: \"信号量：线程安全、中断安全\",\n      children: _jsxs(_components.p, {\n        children: [\"允许任意线程调用 \", _jsx(_components.code, {\n          children: \"sem_init\"\n        }), \", \", _jsx(_components.code, {\n          children: \"sem_wait\"\n        }), \" 和 \", _jsx(_components.code, {\n          children: \"sem_signal\"\n        }), \"。中断处理程序不可睡眠，但可以在中断处理程序中调用 \", _jsx(_components.code, {\n          children: \"sem_signal\"\n        }), \"。\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 正确性标准\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"native 处于长久没有维护的阶段，因此为了实验的稳定性，我们总是以 qemu (x86-64 和 i386) 为准。Online Judge 评测时只有 \", _jsx(_components.code, {\n        children: \"x86-qemu\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"x86_64-qemu\"\n      }), \"。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们测试代码的时候，会替换我们的 \", _jsx(_components.code, {\n        children: \"framework\"\n      }), \" 目录 (os.h 除外)，因此你对其中文件 (例如 kernel.h) 的任何修改都会被消除。注意到我们的测试代码需要数据结构 (\", _jsx(_components.code, {\n        children: \"sem_t\"\n      }), \" 等) 的定义，而这些定义并不在 kernel.h 中，因此你需要在 os.h 中包含它们，否则测试代码将无法编译。测试代码框架如下：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003cklib.h\u003e\"\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003cklib-macros.h\u003e\"\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003cam.h\u003e\"\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003ccommon.h\u003e\"\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003cos.h\u003e\"\n          })]\n        }), \"\\n\\n... \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 此处省略测试代码\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"const\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"char\"\n          }), \" *args)\"]\n        }), \" {\\n    ioe_init();\\n    cte_init(os-\u003etrap);\\n    os-\u003einit();\\n\\n    init_workload(args); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 我们有自己的 workload\"\n        }), \"\\n    mpe_init(os-\u003erun);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"⚠️\",\n      title: \"不要打印多余的输出，不要启动设备。\",\n      children: [_jsx(_components.p, {\n        children: \"操作系统随时可能被中断——如果你在中断处理程序中打印了日志，可能会和其他日志混合在一起，从而影响 Online Judge 的正确性判断。我们建议你使用自己的 log 或 printk 函数 (而不是 printf; 我们的测试程序会使用 printf)，且它们的行为由预编译指令控制，仅在你本地编译时才打印数据。\"\n      }), _jsxs(_components.p, {\n        children: [\"当然这也不是绝对的。例如，系统启动时 (\", _jsx(_components.code, {\n          children: \"mpe_init\"\n        }), \" 之前) 打印少量日志，不会引起问题。\", _jsx(\"red\", {\n          children: \"另外，提交时请不要激活官方测试用例 (例如向 tty 输出)，它可能会导致测试失败\"\n        }), \"。\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.1 Safety 和 Liveness\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在任意时刻，操作系统中都可能有多个线程，你需要设计调度的策略在多个处理器中调度这些线程，使系统中能够被执行的线程尽可能不发生饥饿。\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"🗒️\",\n      title: \"实验要求 (Hard Tests)：多处理器调度\",\n      children: _jsxs(_components.p, {\n        children: [\"在线程数不过多的前提 (十几) 下，我们要求每个可运行的线程，给定足够长 (例如数秒) 的时间，能够被调度到每个处理器上执行。这个需求看起来很简单：稍微改一改 \", _jsx(_components.code, {\n          children: \"thread-os.c\"\n        }), \" 的调度器就行了。但你要警惕了！这可能比你想象的困难得多。\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"经过 Lab1 的洗礼，你们应该意识到，写出正确的程序要从简单、有效的策略开始，盲目使用复杂的策略只会让你陷入 Wrong Answer 的泥潭。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.2 官方测试用例\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"官方测试用例使你的 “操作系统” 看起来更像是个操作系统。但它并不能作为 “压力测试” 来帮助你检查 kmt 实现的正确性。我们为大家提供了 dev 模块及其实现 (已经包含在框架代码中)：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typedef\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-class\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"struct\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"device\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"device_t\"\n          }), \";\"]\n        }), \"\\nMODULE(dev) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*init)();\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"device_t\"\n        }), \" *(*lookup)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *name);\\n};\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们的官方测试用例还包含了以下设备的驱动。回顾 everything is a file，在 Linux 中，设备不过是一个实现了 \", _jsx(_components.code, {\n        children: \"struct file_operations\"\n      }), \" 的对象。我们的 “操作系统” 中包含以下设备：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"input\"\n        }), \"，支持读取键盘的输入；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"fb\"\n        }), \"，支持一个软件模拟的 2D 显示加速器的写入 (我们打算未来把这个显示加速器用真正的硬件实现)；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"tty1\"\n        }), \", \", _jsx(_components.code, {\n          children: \"tty2\"\n        }), \", 两个支持读写的虚拟终端，使用 Alt-1, Alt-2 在虚拟中断之间切换；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"sda\"\n        }), \", 支持读写的物理磁盘。你可以从中读出操作系统内核的 ELF 文件。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Box, {\n      logo: \"🗒️\",\n      title: \"调试正确驱动程序：并不是实验必要的要求\",\n      children: _jsx(_components.p, {\n        children: \"在这个实验中，你并不需要调试正确所有的设备驱动程序 (但调试不通过一般意味着 Online Judge 会测试失败)。\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"代码合并后，你需要在 \", _jsx(_components.code, {\n        children: \"os-\u003einit()\"\n      }), \" 中手工添加设备模块的初始化 \", _jsx(_components.code, {\n        children: \"dev-\u003einit()\"\n      }), \"。如果实现正确，就能完成中断处理程序 (和若干设备相关线程) 的初始化。你不需要添加额外的代码，就能看到闪烁的光标，并且能看到输入字符的回显。此后，你就可以创建若干访问设备的线程，例如你可以为每个 tty 设备创建一个线程：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"tty_reader\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *arg)\"]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"device_t\"\n        }), \" *tty = dev-\u003elookup(arg);\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" cmd[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"128\"\n        }), \"], resp[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"128\"\n        }), \"], ps[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \"];\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"snprintf\"\n        }), \"(ps, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"(%s) $ \\\"\"\n        }), \", arg);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") {\\n        tty-\u003eops-\u003ewrite(tty, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", ps, \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"strlen\"\n        }), \"(ps));\\n        \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" nread = tty-\u003eops-\u003eread(tty, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", cmd, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"sizeof\"\n        }), \"(cmd) - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \");\\n        cmd[nread] = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'\\\\0'\"\n        }), \";\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"sprintf\"\n        }), \"(resp, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tty reader task: got %d character(s).\\\\n\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"strlen\"\n        }), \"(cmd));\\n        tty-\u003eops-\u003ewrite(tty, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", resp, \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"strlen\"\n        }), \"(resp));\\n    }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"os_init\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    ...\\n    kmt-\u003ecreate(task_alloc(), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tty_reader\\\"\"\n        }), \", tty_reader, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tty1\\\"\"\n        }), \");\\n    kmt-\u003ecreate(task_alloc(), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tty_reader\\\"\"\n        }), \", tty_reader, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tty2\\\"\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"../../img/lab2-drv.webp\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"真的实现了 “操作系统”\",\n      question: \"有了设备和线程，我们真的得到了一个小 “嵌入式操作系统”。顺着操作系统课程上讲过的内容，进程是戴上 VR 眼镜 (拥有独立地址空间) 的线程；而存储数据的文件是磁盘上的数据结构。理论上，我们的确可以在 “最小” 的操作系统内核中实现这些机制。\",\n      options: [],\n      answer: \"0\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.3 Online Judge 上的测试用例\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"与 L1 类似，我们的测试代码会使用 Online Judge 的 \", _jsx(_components.code, {\n        children: \"framework\"\n      }), \" 代码 (包含一些测试用例、额外的运行时检查等)。框架代码会调用你的 \", _jsx(_components.code, {\n        children: \"os-\u003einit()\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"os-\u003erun()\"\n      }), \"，就像下面的代码那样：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"producer\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *arg)\"]\n        }), \" { ... }\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"consumer\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *arg)\"]\n        }), \" { ... }\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create_threads\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    ...\\n    kmt-\u003ecreate(pmm-\u003ealloc(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"sizeof\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"task_t\"\n        }), \")),\\n                \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"test-thread-1\\\"\"\n        }), \", producer, xxx);\\n    kmt-\u003ecreate(pmm-\u003ealloc(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"sizeof\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"task_t\"\n        }), \")),\\n                \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"test-thread-2\\\"\"\n        }), \", consumer, yyy);\\n    ...\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    ioe_init();\\n    cte_init(os-\u003etrap);\\n    os-\u003einit();\\n    create_threads();\\n    mpe_init(os-\u003erun); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// all cores call os-\u003erun()\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我们的 producer/consumer 可能就像上课的例子那样，管理 empty 和 fill 两个信号量，分别打印左括号和右括号，然后我们会检查输出是否满足 (1) 是合法括号序列的一个前缀; (2) 括号嵌套的深度是否超过要求。与 Lab1 一样，我们在测试时会链接一个我们实现正确的 klib，所以大家即便 klib 有 bug，也不必太过担心。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. 实验指南\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.1 坐下来，读一读代码\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我们推荐大家阅读的两份代码，首先是 thread-os，它提供了 “操作系统” 的大框架：\"\n    }), \"\\n\", _jsx(Demo, {\n      path: \"kernel/thread-os\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"此外就是 xv6，它包含了更多的实现细节，例如管道、文件……\", _jsx(\"red\", {\n        children: \"上课时的代码调试演示对实验的生存是至关重要的\"\n      }), \"，尤其是其中的一些辅助脚本，它可以大幅提高调试的效率。例如，你应该结合 thread-os 在一次时钟中断后的代码，结合 AbstractMachine 的文档，你就能对中断到底发生了什么、AbstractMachine 到底做了什么有更加深入的认识——更重要的是，thread-os.c 是大家实现 Lab2 的一个 “基础性” 的框架。不要忘记了，我们的 Lab2 就是要实现丰富版的 thread-os.c!\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.2 操作系统上的程序\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"现在，我们的操作系统还不支持进程、文件系统等，但的确有了完善的物理内存管理和线程管理 API。换句话说，我们实现的是一个支持线程的 “嵌入式操作系统”，它能运行在没有 MMU 的硬件上。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"为这样的一个操作系统编写 “应用程序”，就是直接在操作系统代码中静态链接一些函数，这些函数可以作为线程的入口，并且函数可以任意访问内核数据、直接以函数调用的形式调用操作系统内的 API。为了更好地理解实验要求，我们不妨给出一个课堂上 “生产者-消费者” 在我们操作系统上运行的例子。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"首先，我们定义信号量 (kmt 实验需求部分)，并且用宏包装一下 P/V 操作 (这一步完全不必要也不是 best practice，只是为了让我们的代码看起来和课堂上讲解得一样)：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"sem_t\"\n        }), \" empty, fill;\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"define\"\n          }), \" P kmt-\u003esem_wait\"]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"define\"\n          }), \" V kmt-\u003esem_signal\"]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"接下来，我们写出个生产者/消费者线程的代码，就跟我们课堂上展示的 \", _jsx(_components.code, {\n        children: \"threads.h\"\n      }), \" 完全一样：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"T_produce\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *arg)\"]\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") { P(\u0026empty); putch(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'('\"\n        }), \"); V(\u0026fill);  } }\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"T_consume\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *arg)\"]\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") { P(\u0026fill);  putch(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"')'\"\n        }), \"); V(\u0026empty); } }\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"然后，我们在操作系统初始化 (\", _jsx(_components.code, {\n        children: \"os-\u003einit\"\n      }), \") 中创建若干个生产者/消费者线程，其中利用了物理内存的分配：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"inline\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"task_t\"\n        }), \" *\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"task_alloc\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" pmm-\u003ealloc(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"sizeof\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"task_t\"\n        }), \"));\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"run_test1\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    kmt-\u003esem_init(\u0026empty, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"empty\\\"\"\n        }), \", N);\\n    kmt-\u003esem_init(\u0026fill,  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"fill\\\"\"\n        }), \",  \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" i = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"; i \u003c NPROD; i++) {\\n        kmt-\u003ecreate(task_alloc(), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"producer\\\"\"\n        }), \", T_produce, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \");\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" i = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"; i \u003c NCONS; i++) {\\n        kmt-\u003ecreate(task_alloc(), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"consumer\\\"\"\n        }), \", T_consume, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \");\\n    }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"os_init\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    pmm-\u003einit();\\n    kmt-\u003einit(); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 模块先初始化\"\n        }), \"\\n\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"ifdef\"\n          }), \" DEBUG_LOCAL\"]\n        }), \"\\n    run_test1();\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"endif\"\n          })]\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"注意到上面的 \", _jsx(_components.code, {\n        children: \"DEBUG_LOCAL\"\n      }), \" 宏。你们可以把这个宏的定义加载你们的 \", _jsx(_components.code, {\n        children: \"CFLAGS\"\n      }), \" 里，这样你们在本地调试的时候就会创建用于测试的线程，但在 Online Judge 上则不会。这个行为对大家来说很重要：你们打印任何多余的输出，都可能导致 Wrong Answer。这个技巧同样可以用于在 Online Judge 上关闭额外的运行时检查，提高程序的执行速度。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果你的代码实现正确，在模拟器上运行 (可以使用 \", _jsx(_components.code, {\n        children: \"smp=2\"\n      }), \", \", _jsx(_components.code, {\n        children: \"smp=4\"\n      }), \" 等运行启动多个处理器) 能够看到打印出正确的括号序列：总是合法括号序列的前缀，且括号嵌套的深度不超过 5。带着这样的一个具体的操作系统的小 “测试”，你能更好地理解框架代码——它其实并不复杂。\"]\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"🗒️\",\n      title: \"本次实验的难点：正确性\",\n      children: [_jsx(_components.p, {\n        children: \"比起上一个实验，本次实验更难 “调对”。在这个实验中，我们预期你会遇到无数诡异的 bug，跑着跑着虚拟机就挂了，而且错得非常离谱，完全不知道发生了什么。对于并发程序，更难受的是可能要运行很多次，或者在某个特定的条件下 bug 才会触发。但你都相信 (1) 机器永远是对的; (2) 未测代码永远是错的。\"\n      }), _jsx(_components.p, {\n        children: \"当然，我们不排除 AbstractMachine 有 bug、gcc 有 bug、qemu 有 bug，甚至是你的处理器有 bug。但最终无论是哪里的问题，只要使用正确的编程方式，你最终都能找到这个 bug，机器永远是对的。处理器的 bug 是它的一个 “feature”。\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.3 在 Bug 中活下来\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此你实际回过头看，这个实验并不需要实现多少代码——比较紧凑的参考实现仅仅小几百行代码——不就是线程、自旋锁和信号量，加上一些零碎的代码 (中断处理的入口等) 嘛！那为什么实验要求要写那么长呢？还特别用红色字和灰色的底色标出 “线程/中断” 安全？是因为我们希望你的代码在多处理器、中断都存在的情况下保持正确。这不是一句空话，你下面会看到它实际的具体含义。或者说，你只有在做完实验以后，才会对下面这些话产生真正的理解：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"代码可以在多个处理器上被\", _jsx(_components.strong, {\n          children: \"同时\"\n        }), \"调用。因此你需要小心地保证原子性、顺序、可见性。千万小心：\", _jsx(_components.code, {\n          children: \"kmt-\u003ecreate()\"\n        }), \", \", _jsx(_components.code, {\n          children: \"kmt-\u003esem_signal()\"\n        }), \" 等所有函数都可能同时在多个处理器上被调用。你现在觉得这句话很可笑，你早就知道，但你调过 bug 就知道厉害了。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"在中断处理程序中可以调用自旋锁。实际上，一个 CPU 的中断处理程序可以和另一个 CPU 访问同一个共享数据结构 (例如在中断中向链表里插入一个元素，这个链表被另一个线程读取)，因此自旋锁是保证正确性的重要手段。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"小心数据竞争。一切共享的数据都可能会产生数据竞争——如果你没有保护好的话。有些内存访问悄悄在你意想不到的时候发生，例如对堆栈的访问——我们已经做出了提示，小心！小心！\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"很快写着写着你就会发现自己的代码出 bug 了，有可能是并发的，有可能只是顺序的逻辑实现错了。如果出现了莫名其妙的异常、虚拟机神秘重启等情况不要惊慌，\", _jsx(_components.strong, {\n        children: \"机器永远是对的\"\n      }), \"，坐下来调代码吧。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"4.3.1 调试理论：再次复习\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在这两个学期的课程里，我们反复提到了调试理论——我们犯下的 bug 是 fault，它在运行时导致系统某个数值不符合预期 (specification), 这是一个 error，而只有最终虚拟机神秘卡死/重启/输出奇怪内容，我才真正证明了程序里 bug 的存在 (failure)。我建议大家再复习一下我们课程的视频 (并发 bug)，我们试图用这次课程来启发你，实现可靠软件系统是有迹可循的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"为了让 bug (fault) 更容易被找到，我们有两个想法：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"fault → error, 让更多的 bug 能在运行时被触发出来。这是通过详尽的测试实现的——你们已经在 Lab1 里饱受测试不充分的折磨了；而你们要知道，Lab1 Online Judge 的测试远谈不上充分。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"error → failure, 让运行时错误的状态能尽快地被捕获。我们的 klib 里已经提供了以下有用的机制帮助你检查：\", \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.code, {\n              children: \"assert\"\n            }), \", 你可以通过 assert 将程序应该满足的 specification (但代码未必体现) 写出来\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.code, {\n              children: \"panic\"\n            }), \", 立即退出，通常是因为进入了某种不正常的状态\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.code, {\n              children: \"panic_on\"\n            }), \", 条件成立时退出，检查不正常状态并退出\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"不要放弃 \",\n      question: \"相信大家有无数次想放弃。算了，成绩不要了。算了，抄作业吧。如果你坚持把 “独立完成” 想象成是对自己的训练，这是非常有益的。\",\n      options: [],\n      answer: \"0\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在适当的地方加上 printf 和 assert 能帮助你快速定位到程序中出错的状态 (比如在中断到来时打印寄存器的现场，能快速帮你定位出现异常的位置)，缩小bug 的检查范围。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"4.3.2 更好的 log 方式\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"相信大家都有过不停地加 \", _jsx(_components.code, {\n        children: \"printf\"\n      }), \", 删掉 \", _jsx(_components.code, {\n        children: \"printf\"\n      }), \" 的调试体验吧。这感觉可不太好，找了一大圈，最后发现一开始删掉的 \", _jsx(_components.code, {\n        children: \"printf\"\n      }), \" 打印的信息才是最有用的，不过一整天就已经过去了。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"你可以考虑使用一些预编译选项控制 log 的开关：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"ifdef\"\n          }), \" TRACE_F\"]\n        }), \"\\n    \", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"define\"\n          }), \" TRACE_ENTRY printf(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"[trace] %s:entry\\\\n\\\"\"\n          }), \", __func__)\"]\n        }), \"\\n    \", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"define\"\n          }), \" TRACE_EXIT printf(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"[trace] %s:exit\\\\n\\\"\"\n          }), \", __func__)\"]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"else\"\n          })]\n        }), \"\\n    \", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"define\"\n          }), \" TRACE_ENTRY ((void)0)\"]\n        }), \"\\n    \", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"define\"\n          }), \" TRACE_EXIT ((void)0)\"]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"endif\"\n          })]\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"f\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n  TRACE_ENTRY;\\n  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"printf\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"This is f.\\\\n\\\"\"\n        }), \");\\n  TRACE_EXIT;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当然你也可以使用一些变量控制 log 的开关，例如设置 \", _jsx(_components.code, {\n        children: \"print_registers_on_irq\"\n      }), \"。然后把这些开关控制统一放在程序的开头。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"4.3.3 使用调试器\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"让然，如果各种 \", _jsx(_components.code, {\n        children: \"printf\"\n      }), \" 和 log 都没办法帮你找到问题，也许上 gdb 是个不错的主意。框架代码里\", _jsx(_components.strong, {\n        children: \"故意\"\n      }), \"没有提供 \", _jsx(_components.code, {\n        children: \"make debug\"\n      }), \" 的选项，但我们已经频繁地在课上展示了如何调试，qemu 为我们提供了丰富的命令行选项：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"-gdb\"\n        }), \" 能启动调试模式；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"-S\"\n        }), \" 能让虚拟机在收到调试命令前不执行执行；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"在 gdb 中可以用 \", _jsx(_components.code, {\n          children: \"target\"\n        }), \" 命令连接远程调试；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"用 \", _jsx(_components.code, {\n          children: \".gdbinit\"\n        }), \" (或 \", _jsx(_components.code, {\n          children: \"-x\"\n        }), \", \", _jsx(_components.code, {\n          children: \"-ex\"\n        }), \" 选项) 能实现脚本的预先执行。在 Python 中 import gdb 即可获得完整控制 gdb 的能，例如我们轻松地实现了变速齿轮：\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Demo, {\n      path: \"virt/gear\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"QEMU 也包含 log 可以帮助你调试神秘的 CPU 重启。当你真正走投无路的时候，你会发现这些工具才是调试系统软件里最重要的设施。\"\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"一些过来人的经验\",\n      question: \"同学们调试代码的能力有差别；jyy 一定程度上提倡 “OJ 有害” 理论：Online Judge，尤其是固定解决算法题的 Online Judge，无论你习惯多么的坏，花时间多多少少总是能调试出来的。但如果想要维护更大的程序，不正确地使用工具是不可能的——这里有一个有趣的陷阱：工具通常都有一定的学习曲线，因此如果你总是只写几十行的 OJ 程序，你就会建立一种 “不需要工具” 的错误习惯。但如果你能花一些时间走出舒适区，就会看到新的天地。\",\n      options: [],\n      answer: \"0\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.3.4 保护自己不受伤害\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有些 bug 可能会非常难调试，这里举一个例子：栈溢出。也许已经有同学吃过苦头了：栈空间不是无限大的，而如果我们带着很大的局部变量或者递归很多层，栈就悄悄溢出了……在操作系统内核中，内核线程栈的溢出就显得更危险了，因为你可能会定义：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-class\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"struct\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"task_t\"\n          }), \" {\"]\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int32_t\"\n        }), \" id;\\n    ...\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"uint8_t\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"stack\"\n        }), \"[STK_SZ];\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"而栈溢出 (x86 的栈从高地址向低地址生长) 的后果就是线程的信息可能被覆盖，出现各种诡异 (难以理解) 的情况，而且有可能 bug 若隐若现，加一条 printf 也许就不触发了。如果想避免这种情况的发生，可以给栈的前后加一些栅栏缓冲 (fences)，或者金丝雀 (canaries)，我们上课时也讲解过。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"同理，我们可以在 kalloc/free 的时候做一些 hacking，这样可以帮助你检查出很多类型的 bugs，例如你可以在 free 以后将内存全部填为某一个 magic number，然后在关键的 pointer deference 的地方插入\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"define\"\n          }), \" uaf_check(ptr) \\\\\\n    panic_on(MAGIC == *(uint32_t *)(ptr), \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"use-after-free\\\"\"\n          }), \");\"]\n        }), \"\\n\\n*ptr ... \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// important pointer, e.g., current\"\n        }), \"\\nuaf_check(ptr)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这些 defensive 的编程方式，帮助你把代码中应该满足的 specification 明确地在代码中写出来——我们优先假设我们的代码是有 bug 的，而不是没有 bug 的。在此假设下，做的检查越多，越能减少 bug 对我们调试带来的痛苦。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"最后，这几节中介绍的知识都是\", _jsx(_components.strong, {\n        children: \"完全没有用\"\n      }), \"的——如果你不写够大的代码，做够系统的项目，你永远都不会用到这里的知识，永远都不会想把 C 语言的能力发挥到极致。这里的知识对理论考试几乎完全没有任何帮助。但正是在种种细节上追求完美才成就了大型软件系统的成功。优雅的代码赏心悦目。关于操作系统内核，xv6 绝对是一份了不起的佳作，看似平淡无奇的代码里参透着系统设计的智慧，值得大家品味。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4.4 实现能睡眠的互斥锁和信号量\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"自旋锁大家参考课堂讲解的代码和 xv6 实现即可。但自旋锁虽然保证了多处理器资源不会被完全浪费 (在没有死锁的前提下，至少有一个处理器能一直执行)，但关中断对于长临界区来说是非常糟糕的一件事：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"长时间关中断会导致中断丢失；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"其他处理器上试图获得锁的线程会大量浪费处理器资源自旋；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"互斥中的代码可能需要等待中断 (例如希望互斥访问 I/O 设备的代码)。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"因此，这个实验很重要的要求就是在进入临界区后允许中断和线程切换，从而避免处理器在没有获得锁的前提下消除 “空转”。进一步想，假如某个线程执行 \", _jsx(_components.code, {\n        children: \"lock(\u0026lk)\"\n      }), \" 已经获得了锁正在执行，此时另一个线程执行了 \", _jsx(_components.code, {\n        children: \"lock(\u0026lk)\"\n      }), \" 但需要等待——这个等待预期的时间会比较长，因此与其不停地自旋，我们不如在自旋失败的时候，主动切换到其他线程执行：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"lock\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"lock_t\"\n          }), \" *lk)\"]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"atomic_xchg\"\n        }), \"(\u0026lk-\u003elocked, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")) {\\n      yield(); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 切换    \"\n        }), \"\\n    }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"unlock\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"lock_t\"\n          }), \" *lk)\"]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"atomic_xchg\"\n        }), \"(\u0026lk-\u003elocked, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"大家可以考虑一下，如果在关闭中断的时候 \", _jsx(_components.code, {\n        children: \"yield()\"\n      }), \" 会发生什么。考虑清楚这个问题，请把计算机系统的执行想象成状态机；计算机的状态完全是由寄存器和内存的数值决定的，而控制中断开关的是处理器中的中断标志位。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"虽然 \", _jsx(_components.code, {\n        children: \"yield()\"\n      }), \" 能在一定程度上解决问题，但依然不够完美——如果等待锁的线程很多，轮着调度一遍也要花费很多的开销，我们不如做得彻底一点，给每个线程设置状态：\", _jsx(_components.code, {\n        children: \"BLOCKED\"\n      }), \" (在等待某个锁，此时不能被调度执行)；\", _jsx(_components.code, {\n        children: \"RUNNABLE\"\n      }), \" (可被调度执行)。由于决定下一个运行的线程完全是在中断处理函数中完成的，因此我们不妨为每一个线程增加一个 \", _jsx(_components.code, {\n        children: \"status\"\n      }), \" 变量 (在 \", _jsx(_components.code, {\n        children: \"Task\"\n      }), \" 中)，然后修改我们的调度程序，就可以让 \", _jsx(_components.code, {\n        children: \"BLOCKED\"\n      }), \" 的线程不再占用处理器执行。以 thread-os 为例，原本三行的 on_interrupt 只要作出如下修改即可：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [\"Context *\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"on_interrupt\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"(Event ev, Context *ctx)\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Save context.\"\n        }), \"\\n    current-\u003econtext = *ctx;\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Thread schedule.\"\n        }), \"\\n    current = current-\u003enext;\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (current-\u003estatus != RUNNING) {\\n        current = current-\u003enext;\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Restore current thread's context.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \u0026current-\u003econtext;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"没错，只要通过对 “进程状态” 的一个小小的 hacking，我们就可以进一步实现可以睡眠的互斥锁：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"互斥锁由一把自旋锁保护，这大幅简化了我们理解的难度——同一把自旋锁保护的区域满足原子性、顺序和可见性；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如果在互斥锁上锁时，锁未被占用，则更新锁的状态并直接返回；\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"如果在互斥锁上锁时，锁已经被别的线程持有，则把当前线程放到锁的队列中，然后把当前线程标记为不 \", _jsx(_components.code, {\n          children: \"RUNNABLE\"\n        }), \"。注意此时不能进入临界区执行，因此互斥锁函数不能立即返回。此时执行 \", _jsx(_components.code, {\n          children: \"yield()\"\n        }), \" “自陷” (trap) 进入中断处理程序，触发调度器执行；\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"在互斥锁释放时，如果有线程在队列中等待，直接唤醒它即可。如果没有线程在等待，把锁恢复到可用的状态。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mutex_lock\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"mutexlock_t\"\n          }), \" *lk)\"]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" acquired = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n    spin_lock(\u0026lk-\u003espinlock);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (lk-\u003elocked != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \") {\\n        enqueue(lk-\u003ewait_list, current);\\n        current-\u003estatus = BLOCKED;\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n        lk-\u003elocked = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n        acquired = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n    }\\n    spin_unlock(\u0026lk-\u003espinlock);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!acquired) yield(); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 主动切换到其他线程执行\"\n        }), \"\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mutex_unlock\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"mutexlock_t\"\n          }), \" *lk)\"]\n        }), \" {\\n  spin_lock(\u0026lk-\u003espinlock);\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!empty(lk-\u003ewait_list)) {\\n      \", _jsxs(_components.span, {\n          className: \"hljs-class\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"struct\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"task_t\"\n          }), \" *\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"task\"\n          }), \" =\"]\n        }), \" dequeue(lk-\u003ewait_list);\\n      task-\u003estatus = RUNNABLE; \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 唤醒之前睡眠的线程\"\n        }), \"\\n  } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n      lk-\u003elocked = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n  }\\n  spin_unlock(\u0026lk-\u003espinlock);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"理解算法的方式\",\n      question: \"防把线程想象成人、把共享内存想象成物理世界。\",\n      options: [],\n      answer: \"0\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在上述互斥锁的实现中个，如果 lock 调用失败，我们干脆不要自旋了，而是把自己加到一个等待的队列里，等到有人释放锁的时候再唤醒，这就好像是我们的lock/unlock 不再直接粗暴地去 “硬抢” (spin) 这把锁的使用权，而是类似于游泳馆那样的管理方法，现在先假设游泳池同一时间只能容纳一个人。每当同学 (线程) 试图获得锁 (试图进入游泳池) 时，都问管理员 (操作系统) 要手环。此时和管理员交谈的过程由一把自旋锁保护，防止其他同学强势插入打断。如果管理员 (操作系统) 此时有一个手环，就直接把手环给同学 (设置 \", _jsx(_components.code, {\n        children: \"locked = 1\"\n      }), \")，并且允许他进入游泳池 (\", _jsx(_components.code, {\n        children: \"mutex_lock\"\n      }), \" 返回)。否则，线程就需要在管理员处排队 (然后线程睡眠，你可以理解成在队伍里专心致志地玩手机)，直到上一个同学出游泳馆 (\", _jsx(_components.code, {\n        children: \"mutex_unlock\"\n      }), \") 的时候把手环交换给管理员，戳一戳在队首的线程 (唤醒它)，队首的同学 (线程) 获得锁。此时如果没有排队的同学，管理员会把手环放到柜子里。\"]\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"../../img/locker.webp\",\n          alt: \"\"\n        })\n      })\n    }), \"\\n\", _jsx(\"center\", {\n      children: \"获得手环，在游泳馆更衣室的同学。互斥锁保证了其他同学不能进入更衣室 (误\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"信号量和可以睡眠的互斥锁实现可以说是完全相同——只不过是我们的 \", _jsx(_components.code, {\n        children: \"locked\"\n      }), \" 不再是一个 0 或 1 的数值，而是允许是更多的数值，它代表了手环的数量。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"frontmatter":{"title":"L2: 内核线程管理 (kmt)"}},"__N_SSG":true},"page":"/[[...index]]","query":{"index":["OS","2024","labs","L2.md"]},"buildId":"a2FwJzUPGFGc0QcwaUr13","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body>
</html>