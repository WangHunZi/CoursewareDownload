<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>L0: 为计算机硬件编程</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css"/><meta name="next-head-count" content="5"/><link rel="preload" href="../../../_next/static/css/e993edd6a18ef4f0.css" as="style"/><link rel="stylesheet" href="../../../_next/static/css/e993edd6a18ef4f0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="../../../_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="../../../_next/static/chunks/webpack-f73d82589f972e7d.js" defer=""></script><script src="../../../_next/static/chunks/framework-66d32731bdd20e83.js" defer=""></script><script src="../../../_next/static/chunks/main-3929bf55b0f13a18.js" defer=""></script><script src="../../../_next/static/chunks/pages/_app-00b06920b385caf1.js" defer=""></script><script src="../../../_next/static/chunks/pages/[[...index]]-877ec949b69be209.js" defer=""></script><script src="../../../_next/static/a2FwJzUPGFGc0QcwaUr13/_buildManifest.js" defer=""></script><script src="../../../_next/static/a2FwJzUPGFGc0QcwaUr13/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-slate-300/10"><div class="sticky top-0 z-40 w-full backdrop-blur flex-none border-b border-slate-900/10 bg-white/75 supports-backdrop-blur:bg-white/60"><div class="max-w-8xl mx-auto"><div class="py-4 border-b border-slate-900/10 lg:px-8 lg:border-0 dark:border-slate-300/10 mx-4 lg:mx-0"><div class="relative flex items-center"><a href="../../../index.html">Yanyan&#x27;s wiki</a><form class="text-xs text-slate-500"> for <input type="text" name="token" class="font-mono text-xs w-16" maxLength="8"/></form><div class="relative hidden lg:flex items-center ml-4 pl-4 border-l"><nav class="text-sm leading-6 font-semibold text-slate-700 dark:text-slate-200"><ul class="flex space-x-8"><li><a class="hover:text-sky-500 dark:hover:text-sky-400" href="../../2025/index.html">操作系统 (2025 春)</a></li></ul></nav></div></div></div></div></div><div class="container mx-auto max-w-5xl flex flex-col min-h-screen px-4"><div class="wiki bg-neutral-200/10"><h1>L0: 为计算机硬件编程</h1>
<div class="box yellow-box"><div><span class="float-left text-4xl mr-3 mt-2">⏰</span><span class="font-serif text-lg border-b border-slate-600"><b>Soft Deadline: 2024 年 4 月 7 日 23:59:59</b></span><div class="font-serif pt-2"><p><strong><red>你需要首先阅读<a href="Labs.md">实验须知</a>，其中包含了代码获取方法、提交方法、如何查看提交结果等</red></strong>。在命令行中 <code>git pull origin L0</code> 下载框架代码。</p><p><strong>本次实验不需要实验报告。</strong></p></div></div></div>
<div class="box slate-box"><div><span class="float-left text-4xl mr-3 mt-2">⚖️</span><span class="font-serif text-lg border-b border-slate-600"><b>L0 - hello</b></span><div class="font-serif pt-2"><p>请输入 Token 登录。</p></div></div></div>
<h2>1. 背景</h2>
<p>如何为计算机硬件编程？我们的计算机硬件上可以直接运行我们编写的 C 代码，就像上课时展示的 Hello World：</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;am.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;klib.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, OS World\n&quot;</span>);
}
</code></pre>
<p>这个程序除了调用的库函数不同 (例如没有 stdio.h；多了 am.h) 之外，它就是一个完全符合 C 标准的普通程序，但因为没有操作系统和标准库的支持，我们需要编写所有的库函数。例如，printf 也来自我们的代码，它调用了 AbstractMachine 提供的 putch API:</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">putch</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>;
</code></pre>
<p>putch 会在调试终端上输出一个字符；对于 x86-qemu 平台来说，调试终端就是 QEMU 的串口。至于这个程序是如何在计算机硬件上运行起来的，可以借助视频回顾课堂调试代码的过程：</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2"><button class="hover:bg-blue-300 text-white font-bold px-2 rounded"><img class="w-10" src="../../img/vscode.svg"/></button></span><span class="font-serif text-lg border-b border-slate-600"><b></b></span><div class="font-serif pt-2"><div></div></div></div></div>
<h2>2. 实验描述</h2>
<h3>2.1 理解框架代码</h3>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>实验要求：阅读 AbstractMachine 文档</b></span><div class="font-serif pt-2"><p>想知道为什么能用你熟悉的方式编写操作系统？<a href="../../../AbstractMachine/index.html">阅读 AbstractMachine 的文档</a>。当然，文档很多，你不必一次看完，建立了一些基本概念后，就可以试着从样例代码出发开始编程了。另一个好消息是我们的实验框架中直接包含了 AbstractMachine 的代码并在 Makefile 中完成了配置 (RTFSC)，从而你无需额外配置/下载。</p></div></div></div>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>可选实验：实现 klib 中缺失的函数</b></span><div class="font-serif pt-2"><div class="py-1">我们课堂上演示的代码中，klib 已经被正确实现；但你的框架代码中，这部分实现是空缺的。如果你想只用 `putch` 打印，会使你连打印一个整数都麻烦到怀疑人生。框架中已经在 klib.h 列出了一些函数的原型供大家参考；我们不强制实现 klib 函数，但随着操作系统实验的进展，你会体会到不实现库函数的苦头。如果你对编程感到很苦恼，不妨按只实现一些简化版本的库，无需全部实现；随着实验的进展后续补齐。</div><ol class="quiz-card p-0 ml-8 my-1"></ol></div></div></div>
<p>如果你在《计算机系统基础》中已经实现了部分或全部 klib，你可以直接复制你的实现 (但要小心！你的库实现可能有 bug，或是不能在<strong>多处理器</strong>的情况下工作)。这部分代码非常重要——会一直使用到这学期的最后，因此也请你非常小心地编写代码，例如编写相当多的 assertions；klib 中的 bug 会使原本就已很困难的操作系统内核调试更加令人沮丧。</p>
<h3>2.2 在 AbstractMachine 中显示一张图片</h3>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>实验要求：显示一张图片</b></span><div class="font-serif pt-2"><p>你需要编写一个直接运行在 AbstractMachine 上 (仅仅启用 IOE 扩展，不使用其他硬件机制如中断/异常/虚拟存储/多处理器) 的程序，显示一张图片；满足：</p><ol>
<li>显示一张任何图片，但能适配不同的屏幕大小。确保你的图片在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>320</mn><mo>×</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">320\times 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">320</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">200</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>640</mn><mo>×</mo><mn>480</mn></mrow><annotation encoding="application/x-tex">640 \times 480</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">640</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">480</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>800</mn><mo>×</mo><mn>600</mn></mrow><annotation encoding="application/x-tex">800 \times 600</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">800</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">600</span></span></span></span> 等分辨率下均可以正常显示；</li>
<li>图片中包含不少于 10 种颜色。</li>
<li>程序使用的内存 (代码、静态数据总和不超过 4 MiB、堆区 <code>heap</code> 使用不超过 4 MiB)；</li>
<li>按 ESC 键后调用 <code>halt()</code> 退出；除此之外，按任何键程序都不应退出。</li>
</ol></div></div></div>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>移植性要求</b></span><div class="font-serif pt-2"><div class="py-1">你的代码应当有一定的可移植性：同 minilabs 一样，你的程序可能运行在 32/64-bit 平台，因此你应当使用 intptr_t 或 uintptr_t 来保存指针数值。</div><ol class="quiz-card p-0 ml-8 my-1"></ol></div></div></div>
<p>我们会在 x86_64-qemu (64-bit) 和 x86-qemu (32-bit) 两个环境下运行，你的程序必须在两个环境下都能正确编译并运行良好。此外，AbstractMachine 假设 bare-metal 不支持浮点数指令。在 x86_64 的编译选项中，我们添加了 <code>-mno-sse</code>。尽管有浮点数的程序在 <code>ARCH=native</code> 下可以正确编译运行，但可能在其他架构下失效。这么做的目的是使 AbstractMachine 程序能运行在各种 (简化) 的处理器上。</p>
<h2>3. 正确性标准</h2>
<p>Online Judge 会严格按照上面的要求来评测：</p>
<ul>
<li>我们会通过 qemu 的 <code>-m</code> 选项限制内存的大小；使用超过规定的内存可能导致程序崩溃。同学们可以用 size 命令查看二进制文件的大小。</li>
<li>我们会在不同的环境下 (x86-qemu 或 x86_64-qemu, native) 运行你的程序，并且可能修改屏幕的分辨率 (我们的 AbstractMachine 可能拥有和你不同的分辨率！)。</li>
<li>我们会向你的程序发送一定数量的随机键盘事件。</li>
</ul>
<p>没错，Online Judge 会自动运行你的程序——这意味着你也可以自动运行你的程序，实现本地的自动化测试。Online Judge 会作出如下正确性检查：</p>
<ol>
<li>除非按 ESC 键，我们假设程序不结束；如果检测到 <code>halt()</code> 的调用 (包括 assert 失败，我们可能会增加一些额外的合法性检查)，将判定为错 (Runtime Error 或 Wrong Answer)；</li>
<li>如果按 ESC 键后程序不结束，将判定为错；</li>
<li>如果虚拟机或进程发生崩溃、非预期的重启等 (由 undefined behavior 导致，例如访问某非法内存可能导致异常或 CPU Reset)，则被判定为错；</li>
<li>其他违反 specifications 的问题，如在 <code>ioe_init()</code> 之前调用 <code>io_read</code>/<code>io_write</code>，将被判定为错。</li>
</ol>
<p>此外，我们会链接我们 klib 的参考实现，因此你不必担心你的 klib 有些许问题；但你要保持 klib 库函数的行为与 libc 一致。注意 native 会链接系统本地的 glibc (而非 klib)。</p>
<h2>4. 实验指南</h2>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>阅读手册</b></span><div class="font-serif pt-2"><p>首先，<a href="https://jyywiki.cn/AbstractMachine">AbstractMachine 的文档</a> 是帮助你理解整个框架代码的核心。阅读它，了解到底为什么 “操作系统就是一个 C 程序”；你也可以参考<a href="../lect3.md">课程</a>中的调试技巧。</p></div></div></div>
<h3>4.1. 实现库函数</h3>
<p>实现库函数是普通的 C 语言练习题；互联网上也有很多代码可以参考；尤其是你可以多向大语言模型提问——但我们不建议大家直接使用来自任何其他人 (包括 AI) 的代码：“照抄” 会使你失去训练的机会：如果你独立编写，很可能会遇到各种 bugs，而解决这些 bug 时，你会不断提出假设、验证假设，直到你最终把 bug 定位到一个足够小的范围能够直接解决它。在这个过程中，你会积累 “应该如何提出和验证假设” 的经验，而这些第一手经验是很难通过阅读文档 (和正确的代码) 而获得的。</p>
<p>当然，在你实现完以后，我们也鼓励大家阅读一些其他人实现的代码，例如 <a href="https://musl.libc.org/">musl</a>，如果你参考一些早期版本 (例如 <a href="https://git.musl-libc.org/cgit/musl/tree/src/?h=v0.5.0">v0.5.0</a>)，再对比更新的版本，就会对库函数的实现有更深的认识。</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>想试试 malloc?</b></span><div class="font-serif pt-2"><p>没错。malloc/free 是实现更复杂系统极为重要的 API。你很想实现它——然后你发现 v0.5 的 malloc.c 就已经有 500 行了！接着你发现了 “__simple_malloc.c”：</p><pre><code class="hljs language-c"><span class="hljs-type">void</span> *__simple_malloc(<span class="hljs-type">size_t</span> n)
{
	<span class="hljs-type">static</span> <span class="hljs-type">uintptr_t</span> cur, brk;
	<span class="hljs-type">uintptr_t</span> base, new;
	<span class="hljs-type">static</span> <span class="hljs-type">int</span> lock;
	<span class="hljs-type">size_t</span> align=<span class="hljs-number">1</span>;

	<span class="hljs-keyword">if</span> (n &lt; SIZE_MAX - ALIGN)
		<span class="hljs-keyword">while</span> (align&lt;n &amp;&amp; align&lt;ALIGN)
			align += align;
	n = n + align - <span class="hljs-number">1</span> &amp; -align;

	LOCK(&amp;lock);
	<span class="hljs-keyword">if</span> (!cur) cur = brk = __brk(<span class="hljs-number">0</span>)+<span class="hljs-number">16</span>;
	<span class="hljs-keyword">if</span> (n &gt; SIZE_MAX - brk) <span class="hljs-keyword">goto</span> fail;

	base = cur + align<span class="hljs-number">-1</span> &amp; -align;
	<span class="hljs-keyword">if</span> (base+n &gt; brk) {
		new = base+n + PAGE_SIZE<span class="hljs-number">-1</span> &amp; -PAGE_SIZE;
		<span class="hljs-keyword">if</span> (__brk(new) != new) <span class="hljs-keyword">goto</span> fail;
		brk = new;
	}
	cur = base+n;
	UNLOCK(&amp;lock);

	<span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)base;

fail:
	UNLOCK(&amp;lock);
	errno = ENOMEM;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre><p>在 “实验作业” 的阶段，我们并没有做什么创新，但经过了你独立的思考，再参考他人的解决方案，就能获得很多启发。</p></div></div></div>
<p>注意你可以在本地通过修改 Makefile 绕过某些 warnings，使你的程序看起来正确地在多个平台上运行；但 Online Judge 会使用我们的 Makefile 和 AbstractMachine 实现，并且可能经过一定的修改 (例如设置为不同的屏幕分辨率)。</p>
<h3>4.2. 访问 I/O 设备</h3>
<p>没有库函数的 C 语言程序类似于状态机，只能完成纯粹的 “计算”。TRM 中唯一能够和外界交互的手段是 <code>putch()</code> 在调试终端上打印字符和 <code>halt()</code> 终止程序。我们的硬件提供了若干 I/O 设备，AbstractMachine 可以通过 IOE 访问它们。在调用 I/O 设备之前，需要调用 <code>ioe_init()</code> 初始化，然后就可以用</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">ioe_read</span> <span class="hljs-params">(<span class="hljs-type">int</span> reg, <span class="hljs-type">void</span> *buf)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">ioe_write</span><span class="hljs-params">(<span class="hljs-type">int</span> reg, <span class="hljs-type">void</span> *buf)</span>;
</code></pre>
<p>两个函数访问 AbstractMachine 中的 I/O “寄存器” 了。详情请参考 AbstractMachine 文档和框架代码。在 <code>klib-macros.h</code> 中包含了更简化的 I/O 寄存器访问方法 <code>io_read</code> 和 <code>io_write</code>，请大家查看。用这组 API 你就可以省去手工定义变量的麻烦，例如直接</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> width = io_read(AM_GPU_CONFIG).width;
</code></pre>
<p>到这里，大家可能会产生的一个疑问是：运行在 “裸机” 上的程序可以用哪些标准库？我们知道，libc 中相当一部分函数都调用操作系统，例如 <code>printf</code>, <code>malloc</code> 等，即便引用了 <code>stdio.h</code> 这样的头文件，它们的实现依然是缺失的；另一方面，我们引用了一些库的头文件，例如 <code>stdint.h</code> (包含诸如 <code>int32_t</code> 这些类型的定义)、<code>stdarg.h</code> 等，却可以正常工作。这是为什么？</p>
<p>事实上，AbstractMachine 的程序运行在 <a href="https://wiki.osdev.org/C_Library">freestanding 的环境下</a> (操作系统上的 C 程序运行在 hosted 环境下)：The <code>__STDC_HOSTED__</code> macro expands to <code>1</code> on hosted implementations, or 0 on freestanding ones. The freestanding headers are: <code>float.h</code>, <code>iso646.h</code>, <code>limits.h</code>, <code>stdalign.h</code>, <code>stdarg.h</code>, <code>stdbool.h</code>, <code>stddef.h</code>, <code>stdint.h</code>, and <code>stdnoreturn.h</code>. You should be familiar with these headers as they contain useful declarations you shouldn&#x27;t do yourself. GCC also comes with additional freestanding headers for CPUID, SSE and such.</p>
<p>这些头文件中包含了 freestanding 程序也可使用的声明。有兴趣的同学可以发现，可变参数经过预编译后生成了类似 <code>__builtin_va_arg</code> 的 builtin 调用，由编译器翻译成了特定的汇编代码。</p>
<h2>4.3. 绘制一个图片</h2>
<p>“绘制一个图片” 似乎是一个很奇怪的需求。然而，你很快也反应过来：“图片不过是计算机中保存的 01 数据”。那么我们是如何在 C 语言中保存程序运行前的数据的？答案是定义带初值的全局变量：</p>
<pre><code class="hljs language-c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *names = {
    <span class="hljs-string">&quot;Tom&quot;</span>,
    <span class="hljs-string">&quot;Jerry&quot;</span>,
    <span class="hljs-string">&quot;Spike&quot;</span>,
    ...
};
</code></pre>
<p>我们只要把图片的 RGB 数值写在代码里，不就可以显示图片了吗！没错。甚至我们的 xxd 工具都帮助大家实现了这一点：</p>
<pre><code class="hljs language-c"><span class="hljs-comment">// Generated by: xxd -i /bin/ls</span>
<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> _bin_ls[] = {
    <span class="hljs-number">0x7f</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,
    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x3e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,
    ...
    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>
};
<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _bin_ls_len = <span class="hljs-number">142144</span>;
</code></pre>
<p>xxd 可以将任何二进制文件转换成 C/C++ 可以接受的常量数组，而且把数组的长度也固定好。因此你可以在 “kernel” 的外部准备好任何的图片数据。至于同一个图片如何 “拉伸/缩放” 到不同分辨率，这就是你需要考虑的问题了——不过这也不难，说白了你是希望将一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span> 的矩形网格 “投影” 到一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>×</mo><msup><mi>m</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">n&#x27; \times m&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8352em;vertical-align:-0.0833em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7519em"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 的矩形网格上——因此最简单的方法就是在新网格上找到旧网格 “最靠近” 的那个位置对应的像素即可。</p></div></div><div class="bg-neutral-100 text-center text-neutral-600 dark:bg-neutral-600 dark:text-neutral-200 lg:text-left"><div class="bg-neutral-200 p-6 text-center dark:bg-neutral-700"><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons License: BY-NC 4.0</a><br/><a href="https://beian.miit.gov.cn/">苏 ICP 备 2020049101 号</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    pre: \"pre\",\n    span: \"span\",\n    h3: \"h3\",\n    ol: \"ol\",\n    li: \"li\",\n    math: \"math\",\n    semantics: \"semantics\",\n    mrow: \"mrow\",\n    mn: \"mn\",\n    mo: \"mo\",\n    annotation: \"annotation\",\n    ul: \"ul\",\n    mi: \"mi\",\n    msup: \"msup\"\n  }, _provideComponents(), props.components), {Box, Submission, Demo, Quiz} = _components;\n  if (!Box) _missingMdxReference(\"Box\", true);\n  if (!Demo) _missingMdxReference(\"Demo\", true);\n  if (!Quiz) _missingMdxReference(\"Quiz\", true);\n  if (!Submission) _missingMdxReference(\"Submission\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"L0: 为计算机硬件编程\"\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"⏰\",\n      title: \"Soft Deadline: 2024 年 4 月 7 日 23:59:59\",\n      children: [_jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: _jsxs(\"red\", {\n            children: [\"你需要首先阅读\", _jsx(_components.a, {\n              href: \"Labs.md\",\n              children: \"实验须知\"\n            }), \"，其中包含了代码获取方法、提交方法、如何查看提交结果等\"]\n          })\n        }), \"。在命令行中 \", _jsx(_components.code, {\n          children: \"git pull origin L0\"\n        }), \" 下载框架代码。\"]\n      }), _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"本次实验不需要实验报告。\"\n        })\n      })]\n    }), \"\\n\", _jsx(Submission, {\n      course: \"OS2024\",\n      module: \"L0\",\n      desc: \"L0 - hello\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 背景\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如何为计算机硬件编程？我们的计算机硬件上可以直接运行我们编写的 C 代码，就像上课时展示的 Hello World：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003cam.h\u003e\"\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003cklib.h\u003e\"\n          })]\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"printf\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello, OS World\\\\n\\\"\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个程序除了调用的库函数不同 (例如没有 stdio.h；多了 am.h) 之外，它就是一个完全符合 C 标准的普通程序，但因为没有操作系统和标准库的支持，我们需要编写所有的库函数。例如，printf 也来自我们的代码，它调用了 AbstractMachine 提供的 putch API:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"putch\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"char\"\n          }), \" ch)\"]\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"putch 会在调试终端上输出一个字符；对于 x86-qemu 平台来说，调试终端就是 QEMU 的串口。至于这个程序是如何在计算机硬件上运行起来的，可以借助视频回顾课堂调试代码的过程：\"\n    }), \"\\n\", _jsx(Demo, {\n      path: \"intro/debug-bootloader\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 实验描述\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.1 理解框架代码\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"🗒️\",\n      title: \"实验要求：阅读 AbstractMachine 文档\",\n      children: _jsxs(_components.p, {\n        children: [\"想知道为什么能用你熟悉的方式编写操作系统？\", _jsx(_components.a, {\n          href: \"/AbstractMachine/\",\n          children: \"阅读 AbstractMachine 的文档\"\n        }), \"。当然，文档很多，你不必一次看完，建立了一些基本概念后，就可以试着从样例代码出发开始编程了。另一个好消息是我们的实验框架中直接包含了 AbstractMachine 的代码并在 Makefile 中完成了配置 (RTFSC)，从而你无需额外配置/下载。\"]\n      })\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"可选实验：实现 klib 中缺失的函数\",\n      question: \"我们课堂上演示的代码中，klib 已经被正确实现；但你的框架代码中，这部分实现是空缺的。如果你想只用 `putch` 打印，会使你连打印一个整数都麻烦到怀疑人生。框架中已经在 klib.h 列出了一些函数的原型供大家参考；我们不强制实现 klib 函数，但随着操作系统实验的进展，你会体会到不实现库函数的苦头。如果你对编程感到很苦恼，不妨按只实现一些简化版本的库，无需全部实现；随着实验的进展后续补齐。\",\n      options: [],\n      answer: \"0\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果你在《计算机系统基础》中已经实现了部分或全部 klib，你可以直接复制你的实现 (但要小心！你的库实现可能有 bug，或是不能在\", _jsx(_components.strong, {\n        children: \"多处理器\"\n      }), \"的情况下工作)。这部分代码非常重要——会一直使用到这学期的最后，因此也请你非常小心地编写代码，例如编写相当多的 assertions；klib 中的 bug 会使原本就已很困难的操作系统内核调试更加令人沮丧。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.2 在 AbstractMachine 中显示一张图片\"\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"🗒️\",\n      title: \"实验要求：显示一张图片\",\n      children: [_jsx(_components.p, {\n        children: \"你需要编写一个直接运行在 AbstractMachine 上 (仅仅启用 IOE 扩展，不使用其他硬件机制如中断/异常/虚拟存储/多处理器) 的程序，显示一张图片；满足：\"\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"显示一张任何图片，但能适配不同的屏幕大小。确保你的图片在 \", _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mn, {\n                      children: \"320\"\n                    }), _jsx(_components.mo, {\n                      children: \"×\"\n                    }), _jsx(_components.mn, {\n                      children: \"200\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"320\\\\times 200\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.7278em\",\n                    verticalAlign: \"-0.0833em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"320\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mbin\",\n                  children: \"×\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.6444em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"200\"\n                })]\n              })]\n            })]\n          }), \"、\", _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mn, {\n                      children: \"640\"\n                    }), _jsx(_components.mo, {\n                      children: \"×\"\n                    }), _jsx(_components.mn, {\n                      children: \"480\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"640 \\\\times 480\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.7278em\",\n                    verticalAlign: \"-0.0833em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"640\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mbin\",\n                  children: \"×\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.6444em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"480\"\n                })]\n              })]\n            })]\n          }), \"、\", _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mn, {\n                      children: \"800\"\n                    }), _jsx(_components.mo, {\n                      children: \"×\"\n                    }), _jsx(_components.mn, {\n                      children: \"600\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"800 \\\\times 600\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.7278em\",\n                    verticalAlign: \"-0.0833em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"800\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mbin\",\n                  children: \"×\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.6444em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"600\"\n                })]\n              })]\n            })]\n          }), \" 等分辨率下均可以正常显示；\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"图片中包含不少于 10 种颜色。\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"程序使用的内存 (代码、静态数据总和不超过 4 MiB、堆区 \", _jsx(_components.code, {\n            children: \"heap\"\n          }), \" 使用不超过 4 MiB)；\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"按 ESC 键后调用 \", _jsx(_components.code, {\n            children: \"halt()\"\n          }), \" 退出；除此之外，按任何键程序都不应退出。\"]\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"移植性要求\",\n      question: \"你的代码应当有一定的可移植性：同 minilabs 一样，你的程序可能运行在 32/64-bit 平台，因此你应当使用 intptr_t 或 uintptr_t 来保存指针数值。\",\n      options: [],\n      answer: \"0\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们会在 x86_64-qemu (64-bit) 和 x86-qemu (32-bit) 两个环境下运行，你的程序必须在两个环境下都能正确编译并运行良好。此外，AbstractMachine 假设 bare-metal 不支持浮点数指令。在 x86_64 的编译选项中，我们添加了 \", _jsx(_components.code, {\n        children: \"-mno-sse\"\n      }), \"。尽管有浮点数的程序在 \", _jsx(_components.code, {\n        children: \"ARCH=native\"\n      }), \" 下可以正确编译运行，但可能在其他架构下失效。这么做的目的是使 AbstractMachine 程序能运行在各种 (简化) 的处理器上。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 正确性标准\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Online Judge 会严格按照上面的要求来评测：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"我们会通过 qemu 的 \", _jsx(_components.code, {\n          children: \"-m\"\n        }), \" 选项限制内存的大小；使用超过规定的内存可能导致程序崩溃。同学们可以用 size 命令查看二进制文件的大小。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"我们会在不同的环境下 (x86-qemu 或 x86_64-qemu, native) 运行你的程序，并且可能修改屏幕的分辨率 (我们的 AbstractMachine 可能拥有和你不同的分辨率！)。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"我们会向你的程序发送一定数量的随机键盘事件。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"没错，Online Judge 会自动运行你的程序——这意味着你也可以自动运行你的程序，实现本地的自动化测试。Online Judge 会作出如下正确性检查：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"除非按 ESC 键，我们假设程序不结束；如果检测到 \", _jsx(_components.code, {\n          children: \"halt()\"\n        }), \" 的调用 (包括 assert 失败，我们可能会增加一些额外的合法性检查)，将判定为错 (Runtime Error 或 Wrong Answer)；\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如果按 ESC 键后程序不结束，将判定为错；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如果虚拟机或进程发生崩溃、非预期的重启等 (由 undefined behavior 导致，例如访问某非法内存可能导致异常或 CPU Reset)，则被判定为错；\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"其他违反 specifications 的问题，如在 \", _jsx(_components.code, {\n          children: \"ioe_init()\"\n        }), \" 之前调用 \", _jsx(_components.code, {\n          children: \"io_read\"\n        }), \"/\", _jsx(_components.code, {\n          children: \"io_write\"\n        }), \"，将被判定为错。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"此外，我们会链接我们 klib 的参考实现，因此你不必担心你的 klib 有些许问题；但你要保持 klib 库函数的行为与 libc 一致。注意 native 会链接系统本地的 glibc (而非 klib)。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. 实验指南\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"☕️\",\n      title: \"阅读手册\",\n      children: _jsxs(_components.p, {\n        children: [\"首先，\", _jsx(_components.a, {\n          href: \"/AbstractMachine\",\n          children: \"AbstractMachine 的文档\"\n        }), \" 是帮助你理解整个框架代码的核心。阅读它，了解到底为什么 “操作系统就是一个 C 程序”；你也可以参考\", _jsx(_components.a, {\n          href: \"../lect3.md\",\n          children: \"课程\"\n        }), \"中的调试技巧。\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.1. 实现库函数\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"实现库函数是普通的 C 语言练习题；互联网上也有很多代码可以参考；尤其是你可以多向大语言模型提问——但我们不建议大家直接使用来自任何其他人 (包括 AI) 的代码：“照抄” 会使你失去训练的机会：如果你独立编写，很可能会遇到各种 bugs，而解决这些 bug 时，你会不断提出假设、验证假设，直到你最终把 bug 定位到一个足够小的范围能够直接解决它。在这个过程中，你会积累 “应该如何提出和验证假设” 的经验，而这些第一手经验是很难通过阅读文档 (和正确的代码) 而获得的。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当然，在你实现完以后，我们也鼓励大家阅读一些其他人实现的代码，例如 \", _jsx(_components.a, {\n        href: \"https://musl.libc.org/\",\n        children: \"musl\"\n      }), \"，如果你参考一些早期版本 (例如 \", _jsx(_components.a, {\n        href: \"https://git.musl-libc.org/cgit/musl/tree/src/?h=v0.5.0\",\n        children: \"v0.5.0\"\n      }), \")，再对比更新的版本，就会对库函数的实现有更深的认识。\"]\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"☕️\",\n      title: \"想试试 malloc?\",\n      children: [_jsx(_components.p, {\n        children: \"没错。malloc/free 是实现更复杂系统极为重要的 API。你很想实现它——然后你发现 v0.5 的 malloc.c 就已经有 500 行了！接着你发现了 “__simple_malloc.c”：\"\n      }), _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-c\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *__simple_malloc(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"size_t\"\n          }), \" n)\\n{\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"uintptr_t\"\n          }), \" cur, brk;\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"uintptr_t\"\n          }), \" base, new;\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" lock;\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"size_t\"\n          }), \" align=\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \";\\n\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (n \u003c SIZE_MAX - ALIGN)\\n\\t\\t\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"while\"\n          }), \" (align\u003cn \u0026\u0026 align\u003cALIGN)\\n\\t\\t\\talign += align;\\n\\tn = n + align - \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \" \u0026 -align;\\n\\n\\tLOCK(\u0026lock);\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (!cur) cur = brk = __brk(\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \")+\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"16\"\n          }), \";\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (n \u003e SIZE_MAX - brk) \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"goto\"\n          }), \" fail;\\n\\n\\tbase = cur + align\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"-1\"\n          }), \" \u0026 -align;\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (base+n \u003e brk) {\\n\\t\\tnew = base+n + PAGE_SIZE\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"-1\"\n          }), \" \u0026 -PAGE_SIZE;\\n\\t\\t\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (__brk(new) != new) \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"goto\"\n          }), \" fail;\\n\\t\\tbrk = new;\\n\\t}\\n\\tcur = base+n;\\n\\tUNLOCK(\u0026lock);\\n\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *)base;\\n\\nfail:\\n\\tUNLOCK(\u0026lock);\\n\\terrno = ENOMEM;\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \";\\n}\\n\"]\n        })\n      }), _jsx(_components.p, {\n        children: \"在 “实验作业” 的阶段，我们并没有做什么创新，但经过了你独立的思考，再参考他人的解决方案，就能获得很多启发。\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"注意你可以在本地通过修改 Makefile 绕过某些 warnings，使你的程序看起来正确地在多个平台上运行；但 Online Judge 会使用我们的 Makefile 和 AbstractMachine 实现，并且可能经过一定的修改 (例如设置为不同的屏幕分辨率)。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.2. 访问 I/O 设备\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"没有库函数的 C 语言程序类似于状态机，只能完成纯粹的 “计算”。TRM 中唯一能够和外界交互的手段是 \", _jsx(_components.code, {\n        children: \"putch()\"\n      }), \" 在调试终端上打印字符和 \", _jsx(_components.code, {\n        children: \"halt()\"\n      }), \" 终止程序。我们的硬件提供了若干 I/O 设备，AbstractMachine 可以通过 IOE 访问它们。在调用 I/O 设备之前，需要调用 \", _jsx(_components.code, {\n        children: \"ioe_init()\"\n      }), \" 初始化，然后就可以用\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ioe_read\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" reg, \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *buf)\"]\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ioe_write\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" reg, \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" *buf)\"]\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"两个函数访问 AbstractMachine 中的 I/O “寄存器” 了。详情请参考 AbstractMachine 文档和框架代码。在 \", _jsx(_components.code, {\n        children: \"klib-macros.h\"\n      }), \" 中包含了更简化的 I/O 寄存器访问方法 \", _jsx(_components.code, {\n        children: \"io_read\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"io_write\"\n      }), \"，请大家查看。用这组 API 你就可以省去手工定义变量的麻烦，例如直接\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" width = io_read(AM_GPU_CONFIG).width;\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"到这里，大家可能会产生的一个疑问是：运行在 “裸机” 上的程序可以用哪些标准库？我们知道，libc 中相当一部分函数都调用操作系统，例如 \", _jsx(_components.code, {\n        children: \"printf\"\n      }), \", \", _jsx(_components.code, {\n        children: \"malloc\"\n      }), \" 等，即便引用了 \", _jsx(_components.code, {\n        children: \"stdio.h\"\n      }), \" 这样的头文件，它们的实现依然是缺失的；另一方面，我们引用了一些库的头文件，例如 \", _jsx(_components.code, {\n        children: \"stdint.h\"\n      }), \" (包含诸如 \", _jsx(_components.code, {\n        children: \"int32_t\"\n      }), \" 这些类型的定义)、\", _jsx(_components.code, {\n        children: \"stdarg.h\"\n      }), \" 等，却可以正常工作。这是为什么？\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"事实上，AbstractMachine 的程序运行在 \", _jsx(_components.a, {\n        href: \"https://wiki.osdev.org/C_Library\",\n        children: \"freestanding 的环境下\"\n      }), \" (操作系统上的 C 程序运行在 hosted 环境下)：The \", _jsx(_components.code, {\n        children: \"__STDC_HOSTED__\"\n      }), \" macro expands to \", _jsx(_components.code, {\n        children: \"1\"\n      }), \" on hosted implementations, or 0 on freestanding ones. The freestanding headers are: \", _jsx(_components.code, {\n        children: \"float.h\"\n      }), \", \", _jsx(_components.code, {\n        children: \"iso646.h\"\n      }), \", \", _jsx(_components.code, {\n        children: \"limits.h\"\n      }), \", \", _jsx(_components.code, {\n        children: \"stdalign.h\"\n      }), \", \", _jsx(_components.code, {\n        children: \"stdarg.h\"\n      }), \", \", _jsx(_components.code, {\n        children: \"stdbool.h\"\n      }), \", \", _jsx(_components.code, {\n        children: \"stddef.h\"\n      }), \", \", _jsx(_components.code, {\n        children: \"stdint.h\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"stdnoreturn.h\"\n      }), \". You should be familiar with these headers as they contain useful declarations you shouldn't do yourself. GCC also comes with additional freestanding headers for CPUID, SSE and such.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"这些头文件中包含了 freestanding 程序也可使用的声明。有兴趣的同学可以发现，可变参数经过预编译后生成了类似 \", _jsx(_components.code, {\n        children: \"__builtin_va_arg\"\n      }), \" 的 builtin 调用，由编译器翻译成了特定的汇编代码。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4.3. 绘制一个图片\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"“绘制一个图片” 似乎是一个很奇怪的需求。然而，你很快也反应过来：“图片不过是计算机中保存的 01 数据”。那么我们是如何在 C 语言中保存程序运行前的数据的？答案是定义带初值的全局变量：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *names = {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Tom\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Jerry\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Spike\\\"\"\n        }), \",\\n    ...\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我们只要把图片的 RGB 数值写在代码里，不就可以显示图片了吗！没错。甚至我们的 xxd 工具都帮助大家实现了这一点：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Generated by: xxd -i /bin/ls\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"unsigned\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" _bin_ls[] = {\\n    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x7f\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x45\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x4c\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x46\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x02\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x01\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x01\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x03\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x3e\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x01\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \",\\n    ...\\n    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x00\"\n        }), \"\\n};\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"unsigned\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" _bin_ls_len = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"142144\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"xxd 可以将任何二进制文件转换成 C/C++ 可以接受的常量数组，而且把数组的长度也固定好。因此你可以在 “kernel” 的外部准备好任何的图片数据。至于同一个图片如何 “拉伸/缩放” 到不同分辨率，这就是你需要考虑的问题了——不过这也不难，说白了你是希望将一个 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"n\"\n                }), _jsx(_components.mo, {\n                  children: \"×\"\n                }), _jsx(_components.mi, {\n                  children: \"m\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"n\\\\times m\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6667em\",\n                verticalAlign: \"-0.0833em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"n\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mbin\",\n              children: \"×\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.4306em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"m\"\n            })]\n          })]\n        })]\n      }), \" 的矩形网格 “投影” 到一个 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsxs(_components.msup, {\n                  children: [_jsx(_components.mi, {\n                    children: \"n\"\n                  }), _jsx(_components.mo, {\n                    mathvariant: \"normal\",\n                    lspace: \"0em\",\n                    rspace: \"0em\",\n                    children: \"′\"\n                  })]\n                }), _jsx(_components.mo, {\n                  children: \"×\"\n                }), _jsxs(_components.msup, {\n                  children: [_jsx(_components.mi, {\n                    children: \"m\"\n                  }), _jsx(_components.mo, {\n                    mathvariant: \"normal\",\n                    lspace: \"0em\",\n                    rspace: \"0em\",\n                    children: \"′\"\n                  })]\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"n' \\\\times m'\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.8352em\",\n                verticalAlign: \"-0.0833em\"\n              }\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mord mathnormal\",\n                children: \"n\"\n              }), _jsx(_components.span, {\n                className: \"msupsub\",\n                children: _jsx(_components.span, {\n                  className: \"vlist-t\",\n                  children: _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.7519em\"\n                      },\n                      children: _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.063em\",\n                          marginRight: \"0.05em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"2.7em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"sizing reset-size6 size3 mtight\",\n                          children: _jsx(_components.span, {\n                            className: \"mord mtight\",\n                            children: _jsx(_components.span, {\n                              className: \"mord mtight\",\n                              children: \"′\"\n                            })\n                          })\n                        })]\n                      })\n                    })\n                  })\n                })\n              })]\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mbin\",\n              children: \"×\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.7519em\"\n              }\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mord mathnormal\",\n                children: \"m\"\n              }), _jsx(_components.span, {\n                className: \"msupsub\",\n                children: _jsx(_components.span, {\n                  className: \"vlist-t\",\n                  children: _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.7519em\"\n                      },\n                      children: _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.063em\",\n                          marginRight: \"0.05em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"2.7em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"sizing reset-size6 size3 mtight\",\n                          children: _jsx(_components.span, {\n                            className: \"mord mtight\",\n                            children: _jsx(_components.span, {\n                              className: \"mord mtight\",\n                              children: \"′\"\n                            })\n                          })\n                        })]\n                      })\n                    })\n                  })\n                })\n              })]\n            })]\n          })]\n        })]\n      }), \" 的矩形网格上——因此最简单的方法就是在新网格上找到旧网格 “最靠近” 的那个位置对应的像素即可。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"frontmatter":{"title":"L0: 为计算机硬件编程"}},"__N_SSG":true},"page":"/[[...index]]","query":{"index":["OS","2024","labs","L0.md"]},"buildId":"a2FwJzUPGFGc0QcwaUr13","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>