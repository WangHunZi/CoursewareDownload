<!DOCTYPE html><html>
<head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>M1: 打印进程树 (pstree)</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/><link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css"/><meta name="next-head-count" content="5"/><link rel="preload" href="../../../_next/static/css/e993edd6a18ef4f0.css" as="style"/><link rel="stylesheet" href="../../../_next/static/css/e993edd6a18ef4f0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="../../../_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="../../../_next/static/chunks/webpack-f73d82589f972e7d.js" defer=""></script><script src="../../../_next/static/chunks/framework-66d32731bdd20e83.js" defer=""></script><script src="../../../_next/static/chunks/main-3929bf55b0f13a18.js" defer=""></script><script src="../../../_next/static/chunks/pages/_app-00b06920b385caf1.js" defer=""></script><script src="../../../_next/static/chunks/pages/%5b%5b...index%5d%5d-877ec949b69be209.js" defer=""></script><script src="../../../_next/static/a2FwJzUPGFGc0QcwaUr13/_buildManifest.js" defer=""></script><script src="../../../_next/static/a2FwJzUPGFGc0QcwaUr13/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-slate-300/10"><div class="sticky top-0 z-40 w-full backdrop-blur flex-none border-b border-slate-900/10 bg-white/75 supports-backdrop-blur:bg-white/60"><div class="max-w-8xl mx-auto"><div class="py-4 border-b border-slate-900/10 lg:px-8 lg:border-0 dark:border-slate-300/10 mx-4 lg:mx-0"><div class="relative flex items-center"><a href="../../../index.html">Yanyan's wiki</a><form class="text-xs text-slate-500"> for <input type="text" name="token" class="font-mono text-xs w-16" maxLength="8"/></form><div class="relative hidden lg:flex items-center ml-4 pl-4 border-l"><nav class="text-sm leading-6 font-semibold text-slate-700 dark:text-slate-200"><ul class="flex space-x-8"><li><a class="hover:text-sky-500 dark:hover:text-sky-400" href="../../2025/index.html">操作系统 (2025 春)</a></li></ul></nav></div></div></div></div></div><div class="container mx-auto max-w-5xl flex flex-col min-h-screen px-4"><div class="wiki bg-neutral-200/10"><h1>M1: 打印进程树 (pstree)</h1>
<p>计算机世界有趣的地方在于，你可以动手构建任何你认为应该可以实现的东西。我们的热身实验是一个很简单的代码练习——但我们并不是实现类似于排序、最短路径这样的算法习题，而是一个真正有意义的 “实用工具”：了解操作系统中运行的程序 (进程) 之间的层级关系，并打印进程树。</p>
<div class="box yellow-box"><div><span class="float-left text-4xl mr-3 mt-2">⏰</span><span class="font-serif text-lg border-b border-slate-600"><b>Soft Deadline: 2024 年 3 月 24 日 23:59:59</b></span><div class="font-serif pt-2"><p><strong><red>你需要首先阅读<a href="Labs.html">实验须知</a>，其中包含了代码获取方法、提交方法、如何查看提交结果等</red></strong>。在命令行中 <code>git pull origin M1</code> 下载框架代码。</p></div></div></div>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>学术诚信 (Academic Integrity)</b></span><div class="font-serif pt-2"><p>正如课堂上所说，主动 “参考” 他人的代码、使用他人测试用例都是不严格要求自己的行为。为了使你变得更强，遵守学术诚信可以使你获得真正的训练。坚信<strong>计算机世界里没有玄学</strong>，无论是 C 代码、汇编代码还是处理器，都可以看作是严格的数学对象，可以使你在遇到问题时少一些焦躁，冷静下来分析下一步应该做什么。</p><p>具体到这个实验，你应当主动地避免阅读任何人 (包括互联网) 上打印进程树或进程列表的代码，但可以查看 API (如 readdir 等) 的使用方法和例程。遇到问题时尽量自己调试解决，但可以向他人 (包括人工智能) 请教调试的技巧，例如 “我遇到了 XX 现象”，但不知道下一步应该怎么做。</p><p>为了确保你对操作系统有真实的了解，<red><strong>本课程禁止直接使用 AI 生成的代码和直接复制互联网上的代码</strong>。</red>你应当主动不要求 AI 写代码或从互联网上复制代码，但你可以询问 AI 或在互联网上搜索 API 的使用方法。</p></div></div></div>
<div class="box slate-box"><div><span class="float-left text-4xl mr-3 mt-2">⚖️</span><span class="font-serif text-lg border-b border-slate-600"><b>M1 - pstree</b></span><div class="font-serif pt-2"><p>请输入 Token 登录。</p></div></div></div>
<h2>1. 背景</h2>
<p>我们早已熟知操作系统拥有同时运行多个的应用程序的能力——我们可以同时玩游戏的时候聊 QQ、放音乐……那么，管理这些同时运行的程序就是一项 “应该可以实现” 的功能，于是我们就来实现它。今天的操作系统都提供<a href="https://www.cyberciti.biz/tips/top-linux-monitoring-tools.html">任务管理器</a>工具监测程序运行状态，例如显示在一段时间内，各个程序 (进程、状态机) 的活跃程度、占用的内存等等。下面的图片展示了 Plasma Desktop 的任务管理器，能够显示系统资源的使用情况和进程的信息。</p>
<p><img src="../../img/plasma-system-monitor.jpg" alt=""/></p>
<h2>2. 实验描述</h2>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>实验要求：实现 pstree 打印进程之间的树状的父子关系</b></span><div class="font-serif pt-2"><p>Linux 系统中可以同时运行多个程序。运行的程序称为<strong>进程</strong>。除了所有进程的根之外，每个进程都有它唯一的父进程，你的任务就是把这棵树在命令行中输出。你可以自由选择展示树的方式 (例如使用缩进表示父子关系)。</p></div></div></div>
<p>Linux 系统自带了 <code>pstree</code> 命令，进程树会以非常漂亮的格式排版 (每个进程的第一个孩子都与它处在同一行，之后的孩子保持相同的缩进)：</p>
<pre><code class="hljs language-text">systemd─┬─accounts-daemon─┬─{gdbus}
        │                 └─{gmain}
        ├─acpid
        ├─agetty
        ├─atd
        ├─cron
        ├─dbus-daemon
        ├─dhclient
        ├─2*[iscsid]
        ├─lvmetad
        ├─lxcfs───10*[{lxcfs}]
        ├─mdadm
        ├─polkitd─┬─{gdbus}
        │         └─{gmain}
        ├─rsyslogd─┬─{in:imklog}
        │          ├─{in:imuxsock}
        │          └─{rs:main Q:Reg}
        ...
</code></pre>
<p>Linux 的 psmisc 中 <code>pstree</code> 的实现大约有 1,300 行，支持多种命令行参数——但在这个实验中，我们希望大家避免不必要的麻烦，<red>使用最简单的绘制方法</red>。大家可以先玩一下 Linux 的 <code>pstree</code>，使用 <code>man</code> 命令查看 <code>pstree</code> 支持的功能，并试一试。在这个实验中，我们需要实现它的简化版：</p>
<h3>2.1 总览</h3>
<center>pstree [<u>OPTION</u>]…</center>
<h3>2.2 描述</h3>
<p>把系统中的进程按照父亲-孩子的树状结构打印到终端。</p>
<ul>
<li><code>-p</code> 或 <code>--show-pids</code>: 打印每个进程的进程号。</li>
<li><code>-n</code> 或 <code>--numeric-sort</code>: 按照pid的数值从小到大顺序输出一个进程的直接孩子。</li>
<li><code>-V</code> 或 <code>--version</code>: 打印版本信息。</li>
</ul>
<p>你可以在命令行中观察系统的 <code>pstree</code> 的执行行为 (如执行 <code>pstree -V</code>、<code>pstree --show-pids</code> 等)。这些参数可能任意组合，但你不需要处理单字母参数合并的情况，例如 <code>-np</code>。</p>
<h3>2.3 解释</h3>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>对上面的描述感到困惑？</b></span><div class="font-serif pt-2"><p>上述实验要求描述是参照 man page 的格式写出的，其中有很多 UNIX 命令行工具遵守的共同约定 (UNIX 的资深用户对此了如指掌；但对给初学者，尤其是从出生以来就生活在 GUI 环境中而不是遇事就读手册的大家造成了很大的困扰)，例如 <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html">POSIX 对命令行参数有一定的约定</a>。</p><p>觉得文档很长？让人工智能帮你做个总结吧，它能提取出其中最重要的部分，~500 字的总结就已经非常到位了！<strong>读完以后，你立即发现你对手册的理解增加了</strong> (手册的格式竟然也是 POSIX 标准的一部分！)</p></div></div></div>
<p>以下对 pstree 总览和描述的一些解释：</p>
<ol>
<li>中括号扩起的参数是可选参数，<code>[]</code> 后的 <code>…</code> 代表参数的 0 次或多次重复。因此 <code>-p</code>, <code>-n</code>, <code>-V</code> 都是可选的参数。</li>
<li>同一个选项可以有别名。在 <code>pstree</code> 中，<code>-p</code> 和 <code>--show-pids</code> 的含义是一样的。</li>
<li>若不另行说明，整数范围在 32 位有符号整数范围内；但如果数值和文件大小有关，则其合法的范围是是 0 到系统最大支持的文件大小。</li>
</ol>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>请遵守 UNIX 对返回值的约定</b></span><div class="font-serif pt-2"><p><code>main</code> 函数的返回值代表了命令执行的状态，其中 <code>EXIT_SUCCESS</code> 表示命令执行成功，<code>EXIT_FAILURE</code> 表示执行失败。对于 POSIX 来说，0 代表成功，非 0 代表失败：例如 <code>diff</code> 返回 1 表示比较的文件不同，返回 2 表示读取文件失败 (<code>cmp</code> 的行为也类似)。</p><p>按照 UNIX 惯例，<code>main</code> 函数返回非 0 将在 Online Judge 中被判定为 Runtime Error。</p></div></div></div>
<p><strong>如果不知道这些约定，使用 Linux/Unix 的时候就会举步维艰。Unix 世界有一套自己定义的 “游戏规则”</strong>。也难怪会有笑话：</p>
<blockquote>
<p>Unix is <em>user-friendly</em> — it's just choosy about who its friends are.</p>
</blockquote>
<p>当然，在渐渐熟悉游戏规则以后就会发现，这套设计在 1970 年代有限的计算机算力和使用者的负担之间达成了优雅的平衡——Shell 总是可以帮助你用最短的时间把 quick and dirty 的事情搞定：UNIX 哲学强调 <em>Keep it simple, stupid</em> 和 <em>Everything is a file</em>.</p>
<h2>3. 正确性标准</h2>
<p>你可以任意选择树的形态，以下输出都是合法的：</p>
<pre><code class="hljs language-text">$ ./pstree-64
systemd─┬─accounts-daemon─┬─
        │
        ...
</code></pre>
<pre><code class="hljs language-text">$ ./pstree-64
systemd
 |
 +--accounts-daemon-
 |
 ...
</code></pre>
<pre><code class="hljs language-text">$ ./pstree-64
systemd
  accounts-daemon
    ...
</code></pre>
<p>只要输出系统中的进程即可；此外，允许进程列表有轻微出入。细心的同学可能发现你第一个版本的 <code>pstree</code> 可能和系统输出不太一样。在线评测会容忍你输出的一些缺陷；此外，作为第一个实验，我们会手下留情，没有非常强劲的测试数据。但你仍然需要确保：</p>
<ol>
<li>正确列出系统中的进程，并正确实现参数组合的行为；</li>
<li>编写可移植的代码。我们会同时测试 32-bit 和 64-bit 的版本。</li>
</ol>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>在 Hard Test 上 Wrong Answer 的提示</b></span><div class="font-serif pt-2"><p>试一试 <code>pstree -V > /dev/null</code>，你会发现输出并没有到 <code>/dev/null</code>。我们希望你的行为和系统中的 <code>pstree -V</code> 基本一致：输出到正确的输出流、包含 “pstree” 字符串，其他描述可以不同。</p></div></div></div>
<h2>4. 问题分析</h2>
<p>根据《操作系统》课程重要的基本原理：<red>合理的需求一定有合适的方法满足</red>，操作系统一定会提供进程相关的对象和获取信息的 API。</p>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>暂停一下，想一想再继续！</b></span><div class="font-serif pt-2"><div class="py-1">如果你是操作系统的设计者，你会提供怎样的 API (syscall)？</div><ol class="quiz-card p-0 ml-8 my-1"></ol></div></div></div>
<p>一个可行的想法是操作系统可以提供类似迭代器的 API，可以在某个时刻对进程列表进行 “快照”，然后程序可以通过 API 迭代快照里的进程。</p>
<pre><code class="hljs language-c">Snapshot *<span class="hljs-title function_">CreateProcessSnapshot</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 迭代开始</span>
Process *<span class="hljs-title function_">FirstProcess</span><span class="hljs-params">(Snapshot *snapshot)</span>; <span class="hljs-comment">// 取得第一个进程</span>
Process *<span class="hljs-title function_">NextProcess</span><span class="hljs-params">(Process *process)</span>; <span class="hljs-comment">// 获得下一个进程</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">ReleaseProcessSnapshot</span><span class="hljs-params">(Snapshot *snapshot)</span>; <span class="hljs-comment">// 迭代结束</span>
</code></pre>
<p>高级语言可以进一步封装，例如借助 WMI (Windows Management Instrumentation) 库：</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> wmi
<span class="hljs-keyword">for</span> proc <span class="hljs-keyword">in</span> wmi.WMI().Win32_Process():
    ...
</code></pre>
<p>UNIX 操作系统的设计者用另一种方法使应用程序能访问进程列表：操作系统会不断更新一个对象 (文本文件) 的内容，这样应用程序就能用文件 API (open, read, close) 来获取进程列表，例如大家可以用熟悉的 C 语言 <code>FILE *</code> 访问。</p>
<p>今天我们可以考虑在系统里创建一个名为 <code>/system/processes.json</code> 的文本文件，每当进程创建或退出，这个文件的内容就会更新 (当然，操作系统保证更新在瞬间完成)：</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"pid"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"parent"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/bin/init"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"pid"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"parent"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/bin/bash"</span>
    <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">]</span>
</code></pre>
<p>UNIX 采用了 Everything is a File 的设计。换句话说，我们可以<strong>把操作系统的状态变成文件系统的一部分</strong>，从而可以使用我们熟悉的 read, write 等 API 访问操作系统中的各类信息。在这个实验中，我们学习 UNIX/Linux 是如何把操作系统的状态放在文件系统中的。虽然这个实验里你只需要读取进程列表和进程之间的父子关系，但用类似的办法，也可以从 Linux 系统中读取出 CPU 占用率、内存使用等信息——于是你也可以实现自己的任务管理器了！</p>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>思考题：两种机制的优点和缺点 🌶️</b></span><div class="font-serif pt-2"><div class="py-1">两种机制，到底谁好谁坏？</div><ol class="quiz-card p-0 ml-8 my-1"><li class="hover:cursor-pointer hover:bg-slate-200">我想好啦！答案揭晓！</li></ol></div></div></div>
<h2>5. 实验指南</h2>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>解决问题的一般方法</b></span><div class="font-serif pt-2"><p>因为人的脑容量有限，通常解决问题的办法就是把比较复杂的问题分解成小问题，再把小问题继续分解下去。而在学校里所做的训练就是<strong>建立问题分解的思路和培养解决问题的能力</strong>。如果想自己尝试，我们也鼓励大家忽略下面的教程，自己动手搞定，遇到不明白的地方可以求助 Google (Bing, Stackoverflow, ...)；但对于这样的简单任务，大语言模型的表现就有些太好了 (请不要用它们！)。完成之后可以看一下实验指南，看自己的理解是否有可以改进的空间。</p></div></div></div>
<p>如果你觉得打印进程树这个问题比较困难，我们也把问题分解一下：</p>
<ol>
<li>得到命令行的参数，根据要求设置标志变量的数值；</li>
<li>得到系统中所有进程的编号 (每个进程都会有唯一的编号) 保存到列表里；</li>
<li>对列表里的每个编号，得到它的的父亲是谁；</li>
<li>在内存中把树建好，按命令行参数要求排序；</li>
<li>把树打印到终端上。</li>
</ol>
<h3>5.1. 命令行参数</h3>
<p>main 函数的参数是进程 “初始状态” 的一部分，它是由进程的创建者决定的，操作系统负责把它们放在内存中适当的位置；作为 C 语言的程序员，我们只要直接访问 main 函数的参数即可：</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string"><stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string"><assert.h></span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i < argc; i++) {
    assert(argv[i]); <span class="hljs-comment">// C 标准保证</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv[%d] = %s\n"</span>, i, argv[i]);
  }
  assert(!argv[argc]); <span class="hljs-comment">// C 标准保证</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>你可以尝试编译运行这个程序，并且这个程序传入不同，并且观察程序的输出。你会确认 <code>argv[0], ..., argv[argc-1]</code> 就是所有命令行的参数，这是操作系统与 C 程序之间的约定。getopt (<code>man 3 getopt</code>) 库可以处理命令行参数；当然，你也可以直接自己动手解析。</p>
<h3>5.2. 开始做实验</h3>
<p>回想一下大家做 OJ 题的过程。在编程的过程中，难免会经历修改代码 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> 编译 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> 运行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">→</span></span></span></span> 修改代码……这样的循环。你会选择怎么做呢？新手每次都键入命令 (或者他发现 Ctrl-p 可以重复命令)。</p>
<ul>
<li>之后，有同学人发现，可以把命令写在一行里，比如 <code>gcc a.c && ./a.out</code>，一键就能编译运行了。</li>
<li>再之后会发现可以写个 Makefile (就像这个实验一样)，用 <code>make test</code> 跑完所有测试。</li>
<li>再之后会发现可以每次在文件改动以后自动运行所有测试……有个神奇的命令叫 <code>inotifywait</code> (我们并不推荐)。</li>
</ul>
<p>即便现在有 IDE 和丰富的插件，UNIX 哲学依然是无处不在的 (甚至是这些 IDE 的组成基础)，说得更具体一点，“只要你敢想，就一定能做到”。是的，因为之后会反复编译运行这个程序，所以<strong>编译和测试自动化</strong>非常重要。常见的 C 项目组织是编写 Makefile，在命令行中使用 <code>make</code> 实现编译，<code>make test</code> 完成测试。我们已经为大家提供了 Makefile，欢迎大家仔细阅读 (但不是强制的)。</p>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>请用给定的 Makefile 编译程序</b></span><div class="font-serif pt-2"><p>只有用 make 命令编译，才会留下你的开发历史——实验的编译迟早会复杂到无法 “手工键入命令” 完成。我们非常鼓励你在 IDE (例如 vscode) 中配置好 build script，这样可以一键编译/调试/运行。</p><p>以下两点有助于调试时放平心态：(1) <strong>机器永远是对的</strong>；(2) <strong>未测代码永远是错的</strong>。祝大家编程愉快！</p></div></div></div>
<h3>5.3. 得到系统中进程的编号</h3>
<p>进程是操作系统中的对象，因此操作系统一定提供了 API 访问它们。已经剧透过，系统里的<strong>每个进程都有唯一的编号</strong>，它在 C 语言中的类型是 <code>pid_t</code>。不知道这是什么？当然是想办法啦！除了找人工智能 “拿来” 一个答案，在互联网上能找到更权威的定义：glibc 对它的<a href="https://www.gnu.org/software/libc/manual/html_node/Process-Identification.html">官方文档解释</a>。以后遇到问题要自己找答案哦！</p>
<p>操作系统以什么样的方式让你获取系统里的进程呢？之前也提示过：</p>
<blockquote>
<p>Everything is a file.</p>
</blockquote>
<p>一切皆文件，进程信息当然也可以是 “一切” 的一部分。Linux 提供了 <a href="https://en.wikipedia.org/wiki/Procfs">procfs</a>，目录是 <code>/proc</code>。如果你进去看一眼，就会发现除了一些比如 <code>cpuinfo</code> 这样的文件，还有很多以数字命名的目录——聪明的你也许已经猜到了，每个目录的名字就是进程号，目录里存储了进程相关的运行时数据。</p>
<p>我们鼓励大家先玩一玩 procfs，里面可有很多有趣的东西！你可以用 <code>cat</code> 可以打印文件的内容，对照文档 (或者 ChatGPT)，你会发现原来我们以为离我们很遥远的 “观测进程执行”，简单得只要解析文本文件就可以了！例如，每个进程的父进程也隐藏在 <code>/proc/[pid]/</code> 中的某个文件里。试试 <code>man 5 proc</code>，里面有详细的文档。很多 Online Judge 都使用 procfs 读取进程的运行时间/内存数据。</p>
<h3>5.4. 遍历所有进程</h3>
<p>了解了 procfs 之后，我们的问题就变得简单一些了：只要能得到 <code>/proc</code> 目录下的所有以数字为开头的目录，我们就遍历了系统中的进程。因此你会去互联网上搜索如何用 C 语言遍历目录。之后，你可以用你熟悉的方式打开 procfs 里的文件：</p>
<pre><code class="hljs language-c">    FILE *fp = fopen(filename, <span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">if</span> (!fp) <span class="hljs-keyword">goto</span> release;

    <span class="hljs-comment">// 用fscanf, fgets等函数读取</span>

release:
    <span class="hljs-keyword">if</span> (fp) fclose(fp);
</code></pre>
<p>procfs 里的信息足够让你写一个非常不错的任务管理器。那么，“真正” 的任务管理器，例如 ps 命令，是否也是基于 procfs 实现的呢？这就是一个典型的 “好问题”：他帮助你建立你的实验作业和真实系统之间的联系。操作系统课程也给了大家足够的工具，使得同学们可以把任务管理器打开，查看它调用的操作系统 API。我们在课堂上已经演示过 gcc 和 xedit 的例子，就用 strace 工具就能查看进程运行时的系统调用序列：</p>
<pre><code class="hljs language-text">$ strace ps
...
openat(AT_FDCWD, "/proc/1/stat", O_RDONLY)           = 6
read(6, "1 (systemd) S 0 1 1 0 -1 4194560"..., 1024) = 190
close(6)                                             = 0
...
</code></pre>
<h3>5.5. 建树和打印</h3>
<p>终于，在得到进程编号 (名字) 和父子关系的基础上，我们就有了一个 “算法题”，它输入由有向边构成的树，要求输出图形化表示的树结构：</p>
<pre><code class="hljs language-text">1 2
2 3
2 4
3 5
4 6
3 7
</code></pre>
<p>我们不妨把有根树理解成一个 “括号序列” (前序遍历)：</p>
<pre><code class="hljs language-text">1(2(3(5,7),4(6)),8)
</code></pre>
<p>按照从左到右的顺序，输出每一个节点的编号——需要打印多少空格呢？答案是括号嵌套的深度，我们不妨试试看：</p>
<pre><code class="hljs language-text">1
  2
    3
      5
      7
    4
      6
  8
</code></pre>
<p>看起来挺正确的！你就得到了一个 “基本款” 的 pstree。如果你想好看一些，你只要考虑在空间里填上什么样的字符就行了——没错，我们只要 “向左走”，找到它的父亲所在的列 (边向左走边画 “-”)，最后画上垂直的线，我们就得到了树状的结构！</p>
<pre><code class="hljs language-text">1
+-2
| +-3
| | +-5
| | +-7
| +-4
|   +-6
+-8
</code></pre>
<p>看起来不错呢！我们找到问题正确的切入点，就可以简化问题。</p>
<h3>5.6. 写出正确的代码</h3>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>完成了？</b></span><div class="font-serif pt-2"><p>是时候问问自己：我的程序对吗？</p></div></div></div>
<p>虽然在这个实验里，我们的测试用例相对简单；但在未来的实验中，Online Judge 可能会在各种奇葩的条件下运行你的程序哦！除了你们做的 OJ 题中会有复杂的逻辑 (参数的组合) 导致 bug 之外，和系统打交道的编程可有更多的麻烦之处：</p>
<ol>
<li>你的程序遵守 POSIX 的返回值规定吗？如果你的 main 函数返回了非 0 的数值，我们将认为程序报告了错误——在非法的输入上返回 0，以及在合法的输入上返回非 0 都将导致 Wrong Answer。</li>
<li>程序够 robust 吗？它会不会在一些非法的输入上 crash？如果系统里的进程很多呢？如果内存不够了呢？如果 <code>open</code> 或者 <code>malloc</code> 失败了呢？要知道，crash 一般是因为 <a href="https://en.wikipedia.org/wiki/Undefined_behavior">undefined behavior (UB)</a> 导致的——UB 没把所有的文件都删掉真是谢天谢地了。</li>
<li>万一我得到进程号以后，进去发现文件没了 (进程终止了)，怎么办？会不会有这种情况？万一有我的程序会不会 crash……？</li>
<li>进程的信息一直在变，文件的内容也一直在变 (两次 <code>cat</code> 的结果不同)。那我会不会读到不一致的信息 (前一半是旧信息、新一半是新信息)？这两个问题都是 race condition 导致的；我们将会在并发部分回到这个话题。</li>
<li>如果我不确信这些事会不会发生，我有没有写一个程序，至少在压力环境下测试一下它们有没有可能发生？嗯，如果我同时运行很多程序，每个程序都不断扫描目录、读取文件，也观察不到这个问题，至少应该可以放点心。</li>
</ol>
<p>随着课程的深入，这些问题都会得到解答。</p>
<p>当你的程序越来越复杂，这些问题也许将会成为你挥之不去的阴影。这就对了——从 Intel 的 CPU 到 Linux Kernel 都有数不清的 bug。你也许听说过 “形式化验证”，但事实也证明，经过验证正确的编译器 (CertComp) 和操作系统 (seL4, FSCQ, ...) 都依然存在 bug，尽管它们的可靠性依然比程序员手写的高得多。</p>
<p>写出正确的代码远比想象中困难——目前地球上还没人能保证复杂的系统没有 bug 和漏洞。我们切盼望着没有 bug 的那一天的到来——我们离这个终极的答案似乎越来越近，但依然虚无缥缈。不过也不用太绝望，这门课里会教给大家一些有关 “写代码” 的知识，更重要的是正确的解决问题的思维方式 (“世界观”)。</p>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>思考题：用 Windows 的任务管理器 “画图” 🌶️</b></span><div class="font-serif pt-2"><div class="py-1">假设我们在一个完全空载的系统中 (系统中所有的进程都几乎不占用 CPU)。Windows 任务管理器提供 “处理器占用曲线” 的功能；假设系统中只有一个 CPU，如何绘制出正弦波的图案？如果系统中有多个 CPU (例如，64 个)，每个 CPU 都根据占用率的不同显示不同的深浅。我们如何绘制出图片甚至动画？如果系统并不是完全空载，而是有一定的负载，才能 “尽可能” 地绘制出图片或动画 (此时，绘制图片不总是能做到，例如所有 CPU 都满载时，就只能看到全部深色的图案)？在此过程中，你会注意到我们希望操作系统为我们提供一些 API。</div><ol class="quiz-card p-0 ml-8 my-1"><li class="hover:cursor-pointer hover:bg-slate-200">我想好啦！答案揭晓！</li></ol></div></div></div></div></div><div class="bg-neutral-100 text-center text-neutral-600 dark:bg-neutral-600 dark:text-neutral-200 lg:text-left"><div class="bg-neutral-200 p-6 text-center dark:bg-neutral-700"><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons License: BY-NC 4.0</a><br/><a href="https://beian.miit.gov.cn/">苏 ICP 备 2020049101 号</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    img: \"img\",\n    pre: \"pre\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    ol: \"ol\",\n    blockquote: \"blockquote\",\n    em: \"em\",\n    span: \"span\",\n    math: \"math\",\n    semantics: \"semantics\",\n    mrow: \"mrow\",\n    mo: \"mo\",\n    annotation: \"annotation\"\n  }, _provideComponents(), props.components), {Box, Submission, Quiz} = _components;\n  if (!Box) _missingMdxReference(\"Box\", true);\n  if (!Quiz) _missingMdxReference(\"Quiz\", true);\n  if (!Submission) _missingMdxReference(\"Submission\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"M1: 打印进程树 (pstree)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"计算机世界有趣的地方在于，你可以动手构建任何你认为应该可以实现的东西。我们的热身实验是一个很简单的代码练习——但我们并不是实现类似于排序、最短路径这样的算法习题，而是一个真正有意义的 “实用工具”：了解操作系统中运行的程序 (进程) 之间的层级关系，并打印进程树。\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⏰\",\n      title: \"Soft Deadline: 2024 年 3 月 24 日 23:59:59\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: _jsxs(\"red\", {\n            children: [\"你需要首先阅读\", _jsx(_components.a, {\n              href: \"Labs.md\",\n              children: \"实验须知\"\n            }), \"，其中包含了代码获取方法、提交方法、如何查看提交结果等\"]\n          })\n        }), \"。在命令行中 \", _jsx(_components.code, {\n          children: \"git pull origin M1\"\n        }), \" 下载框架代码。\"]\n      })\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"⚠️\",\n      title: \"学术诚信 (Academic Integrity)\",\n      children: [_jsxs(_components.p, {\n        children: [\"正如课堂上所说，主动 “参考” 他人的代码、使用他人测试用例都是不严格要求自己的行为。为了使你变得更强，遵守学术诚信可以使你获得真正的训练。坚信\", _jsx(_components.strong, {\n          children: \"计算机世界里没有玄学\"\n        }), \"，无论是 C 代码、汇编代码还是处理器，都可以看作是严格的数学对象，可以使你在遇到问题时少一些焦躁，冷静下来分析下一步应该做什么。\"]\n      }), _jsx(_components.p, {\n        children: \"具体到这个实验，你应当主动地避免阅读任何人 (包括互联网) 上打印进程树或进程列表的代码，但可以查看 API (如 readdir 等) 的使用方法和例程。遇到问题时尽量自己调试解决，但可以向他人 (包括人工智能) 请教调试的技巧，例如 “我遇到了 XX 现象”，但不知道下一步应该怎么做。\"\n      }), _jsxs(_components.p, {\n        children: [\"为了确保你对操作系统有真实的了解，\", _jsxs(\"red\", {\n          children: [_jsx(_components.strong, {\n            children: \"本课程禁止直接使用 AI 生成的代码和直接复制互联网上的代码\"\n          }), \"。\"]\n        }), \"你应当主动不要求 AI 写代码或从互联网上复制代码，但你可以询问 AI 或在互联网上搜索 API 的使用方法。\"]\n      })]\n    }), \"\\n\", _jsx(Submission, {\n      course: \"OS2024\",\n      module: \"M1\",\n      desc: \"M1 - pstree\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 背景\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们早已熟知操作系统拥有同时运行多个的应用程序的能力——我们可以同时玩游戏的时候聊 QQ、放音乐……那么，管理这些同时运行的程序就是一项 “应该可以实现” 的功能，于是我们就来实现它。今天的操作系统都提供\", _jsx(_components.a, {\n        href: \"https://www.cyberciti.biz/tips/top-linux-monitoring-tools.html\",\n        children: \"任务管理器\"\n      }), \"工具监测程序运行状态，例如显示在一段时间内，各个程序 (进程、状态机) 的活跃程度、占用的内存等等。下面的图片展示了 Plasma Desktop 的任务管理器，能够显示系统资源的使用情况和进程的信息。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"../../img/plasma-system-monitor.jpg\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 实验描述\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"🗒️\",\n      title: \"实验要求：实现 pstree 打印进程之间的树状的父子关系\",\n      children: _jsxs(_components.p, {\n        children: [\"Linux 系统中可以同时运行多个程序。运行的程序称为\", _jsx(_components.strong, {\n          children: \"进程\"\n        }), \"。除了所有进程的根之外，每个进程都有它唯一的父进程，你的任务就是把这棵树在命令行中输出。你可以自由选择展示树的方式 (例如使用缩进表示父子关系)。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Linux 系统自带了 \", _jsx(_components.code, {\n        children: \"pstree\"\n      }), \" 命令，进程树会以非常漂亮的格式排版 (每个进程的第一个孩子都与它处在同一行，之后的孩子保持相同的缩进)：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"systemd─┬─accounts-daemon─┬─{gdbus}\\n        │                 └─{gmain}\\n        ├─acpid\\n        ├─agetty\\n        ├─atd\\n        ├─cron\\n        ├─dbus-daemon\\n        ├─dhclient\\n        ├─2*[iscsid]\\n        ├─lvmetad\\n        ├─lxcfs───10*[{lxcfs}]\\n        ├─mdadm\\n        ├─polkitd─┬─{gdbus}\\n        │         └─{gmain}\\n        ├─rsyslogd─┬─{in:imklog}\\n        │          ├─{in:imuxsock}\\n        │          └─{rs:main Q:Reg}\\n        ...\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Linux 的 psmisc 中 \", _jsx(_components.code, {\n        children: \"pstree\"\n      }), \" 的实现大约有 1,300 行，支持多种命令行参数——但在这个实验中，我们希望大家避免不必要的麻烦，\", _jsx(\"red\", {\n        children: \"使用最简单的绘制方法\"\n      }), \"。大家可以先玩一下 Linux 的 \", _jsx(_components.code, {\n        children: \"pstree\"\n      }), \"，使用 \", _jsx(_components.code, {\n        children: \"man\"\n      }), \" 命令查看 \", _jsx(_components.code, {\n        children: \"pstree\"\n      }), \" 支持的功能，并试一试。在这个实验中，我们需要实现它的简化版：\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.1 总览\"\n    }), \"\\n\", _jsxs(\"center\", {\n      children: [\"pstree [\", _jsx(\"u\", {\n        children: \"OPTION\"\n      }), \"]…\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.2 描述\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"把系统中的进程按照父亲-孩子的树状结构打印到终端。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"-p\"\n        }), \" 或 \", _jsx(_components.code, {\n          children: \"--show-pids\"\n        }), \": 打印每个进程的进程号。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"-n\"\n        }), \" 或 \", _jsx(_components.code, {\n          children: \"--numeric-sort\"\n        }), \": 按照pid的数值从小到大顺序输出一个进程的直接孩子。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"-V\"\n        }), \" 或 \", _jsx(_components.code, {\n          children: \"--version\"\n        }), \": 打印版本信息。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"你可以在命令行中观察系统的 \", _jsx(_components.code, {\n        children: \"pstree\"\n      }), \" 的执行行为 (如执行 \", _jsx(_components.code, {\n        children: \"pstree -V\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"pstree --show-pids\"\n      }), \" 等)。这些参数可能任意组合，但你不需要处理单字母参数合并的情况，例如 \", _jsx(_components.code, {\n        children: \"-np\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.3 解释\"\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"☕️\",\n      title: \"对上面的描述感到困惑？\",\n      children: [_jsxs(_components.p, {\n        children: [\"上述实验要求描述是参照 man page 的格式写出的，其中有很多 UNIX 命令行工具遵守的共同约定 (UNIX 的资深用户对此了如指掌；但对给初学者，尤其是从出生以来就生活在 GUI 环境中而不是遇事就读手册的大家造成了很大的困扰)，例如 \", _jsx(_components.a, {\n          href: \"http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html\",\n          children: \"POSIX 对命令行参数有一定的约定\"\n        }), \"。\"]\n      }), _jsxs(_components.p, {\n        children: [\"觉得文档很长？让人工智能帮你做个总结吧，它能提取出其中最重要的部分，~500 字的总结就已经非常到位了！\", _jsx(_components.strong, {\n          children: \"读完以后，你立即发现你对手册的理解增加了\"\n        }), \" (手册的格式竟然也是 POSIX 标准的一部分！)\"]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下对 pstree 总览和描述的一些解释：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"中括号扩起的参数是可选参数，\", _jsx(_components.code, {\n          children: \"[]\"\n        }), \" 后的 \", _jsx(_components.code, {\n          children: \"…\"\n        }), \" 代表参数的 0 次或多次重复。因此 \", _jsx(_components.code, {\n          children: \"-p\"\n        }), \", \", _jsx(_components.code, {\n          children: \"-n\"\n        }), \", \", _jsx(_components.code, {\n          children: \"-V\"\n        }), \" 都是可选的参数。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"同一个选项可以有别名。在 \", _jsx(_components.code, {\n          children: \"pstree\"\n        }), \" 中，\", _jsx(_components.code, {\n          children: \"-p\"\n        }), \" 和 \", _jsx(_components.code, {\n          children: \"--show-pids\"\n        }), \" 的含义是一样的。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"若不另行说明，整数范围在 32 位有符号整数范围内；但如果数值和文件大小有关，则其合法的范围是是 0 到系统最大支持的文件大小。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"⚠️\",\n      title: \"请遵守 UNIX 对返回值的约定\",\n      children: [_jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"main\"\n        }), \" 函数的返回值代表了命令执行的状态，其中 \", _jsx(_components.code, {\n          children: \"EXIT_SUCCESS\"\n        }), \" 表示命令执行成功，\", _jsx(_components.code, {\n          children: \"EXIT_FAILURE\"\n        }), \" 表示执行失败。对于 POSIX 来说，0 代表成功，非 0 代表失败：例如 \", _jsx(_components.code, {\n          children: \"diff\"\n        }), \" 返回 1 表示比较的文件不同，返回 2 表示读取文件失败 (\", _jsx(_components.code, {\n          children: \"cmp\"\n        }), \" 的行为也类似)。\"]\n      }), _jsxs(_components.p, {\n        children: [\"按照 UNIX 惯例，\", _jsx(_components.code, {\n          children: \"main\"\n        }), \" 函数返回非 0 将在 Online Judge 中被判定为 Runtime Error。\"]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"如果不知道这些约定，使用 Linux/Unix 的时候就会举步维艰。Unix 世界有一套自己定义的 “游戏规则”\"\n      }), \"。也难怪会有笑话：\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Unix is \", _jsx(_components.em, {\n          children: \"user-friendly\"\n        }), \" — it's just choosy about who its friends are.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当然，在渐渐熟悉游戏规则以后就会发现，这套设计在 1970 年代有限的计算机算力和使用者的负担之间达成了优雅的平衡——Shell 总是可以帮助你用最短的时间把 quick and dirty 的事情搞定：UNIX 哲学强调 \", _jsx(_components.em, {\n        children: \"Keep it simple, stupid\"\n      }), \" 和 \", _jsx(_components.em, {\n        children: \"Everything is a file\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 正确性标准\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"你可以任意选择树的形态，以下输出都是合法的：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ ./pstree-64\\nsystemd─┬─accounts-daemon─┬─\\n        │\\n        ...\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ ./pstree-64\\nsystemd\\n |\\n +--accounts-daemon-\\n |\\n ...\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ ./pstree-64\\nsystemd\\n  accounts-daemon\\n    ...\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"只要输出系统中的进程即可；此外，允许进程列表有轻微出入。细心的同学可能发现你第一个版本的 \", _jsx(_components.code, {\n        children: \"pstree\"\n      }), \" 可能和系统输出不太一样。在线评测会容忍你输出的一些缺陷；此外，作为第一个实验，我们会手下留情，没有非常强劲的测试数据。但你仍然需要确保：\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"正确列出系统中的进程，并正确实现参数组合的行为；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"编写可移植的代码。我们会同时测试 32-bit 和 64-bit 的版本。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Box, {\n      logo: \"☕️\",\n      title: \"在 Hard Test 上 Wrong Answer 的提示\",\n      children: _jsxs(_components.p, {\n        children: [\"试一试 \", _jsx(_components.code, {\n          children: \"pstree -V \u003e /dev/null\"\n        }), \"，你会发现输出并没有到 \", _jsx(_components.code, {\n          children: \"/dev/null\"\n        }), \"。我们希望你的行为和系统中的 \", _jsx(_components.code, {\n          children: \"pstree -V\"\n        }), \" 基本一致：输出到正确的输出流、包含 “pstree” 字符串，其他描述可以不同。\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. 问题分析\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"根据《操作系统》课程重要的基本原理：\", _jsx(\"red\", {\n        children: \"合理的需求一定有合适的方法满足\"\n      }), \"，操作系统一定会提供进程相关的对象和获取信息的 API。\"]\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"暂停一下，想一想再继续！\",\n      question: \"如果你是操作系统的设计者，你会提供怎样的 API (syscall)？\",\n      options: [],\n      answer: \"0\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一个可行的想法是操作系统可以提供类似迭代器的 API，可以在某个时刻对进程列表进行 “快照”，然后程序可以通过 API 迭代快照里的进程。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [\"Snapshot *\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"CreateProcessSnapshot\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \"; \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 迭代开始\"\n        }), \"\\nProcess *\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"FirstProcess\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"(Snapshot *snapshot)\"\n        }), \"; \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 取得第一个进程\"\n        }), \"\\nProcess *\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"NextProcess\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"(Process *process)\"\n        }), \"; \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 获得下一个进程\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ReleaseProcessSnapshot\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"(Snapshot *snapshot)\"\n        }), \"; \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 迭代结束\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"高级语言可以进一步封装，例如借助 WMI (Windows Management Instrumentation) 库：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" wmi\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" proc \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" wmi.WMI().Win32_Process():\\n    ...\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"UNIX 操作系统的设计者用另一种方法使应用程序能访问进程列表：操作系统会不断更新一个对象 (文本文件) 的内容，这样应用程序就能用文件 API (open, read, close) 来获取进程列表，例如大家可以用熟悉的 C 语言 \", _jsx(_components.code, {\n        children: \"FILE *\"\n      }), \" 访问。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"今天我们可以考虑在系统里创建一个名为 \", _jsx(_components.code, {\n        children: \"/system/processes.json\"\n      }), \" 的文本文件，每当进程创建或退出，这个文件的内容就会更新 (当然，操作系统保证更新在瞬间完成)：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-json\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"[\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"{\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"pid\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"parent\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-1\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"command\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/bin/init\\\"\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"}\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"{\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"pid\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"parent\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"command\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/bin/bash\\\"\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"]\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"UNIX 采用了 Everything is a File 的设计。换句话说，我们可以\", _jsx(_components.strong, {\n        children: \"把操作系统的状态变成文件系统的一部分\"\n      }), \"，从而可以使用我们熟悉的 read, write 等 API 访问操作系统中的各类信息。在这个实验中，我们学习 UNIX/Linux 是如何把操作系统的状态放在文件系统中的。虽然这个实验里你只需要读取进程列表和进程之间的父子关系，但用类似的办法，也可以从 Linux 系统中读取出 CPU 占用率、内存使用等信息——于是你也可以实现自己的任务管理器了！\"]\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"思考题：两种机制的优点和缺点 🌶️\",\n      question: \"两种机制，到底谁好谁坏？\",\n      options: ['我想好啦！答案揭晓！'],\n      answer: \"0\",\n      comment: \"Everything is a file 和提供 type-safe 的 API 都不是完美的。前者对人类用户来说更好用，例如可以用 UNIX 命令行工具任意解析而不需要写代码，但带来系统中很多 “隐藏在角落里的特性”；后者把规约写在 API 里，可以在你犯错时更好地保护你、运行也更高效，但 “上手” 也稍稍困难一些：Windows Kernel + GDI 的 Windows API 就在 1,000 个以上。但是，我们预见到大语言模型和程序合成 (“低代码”) 技术能够从根本上改变我们开发的方式，操作系统 API 会逐渐成为一种只有库函数使用的 “汇编语言”。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"5. 实验指南\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"☕️\",\n      title: \"解决问题的一般方法\",\n      children: _jsxs(_components.p, {\n        children: [\"因为人的脑容量有限，通常解决问题的办法就是把比较复杂的问题分解成小问题，再把小问题继续分解下去。而在学校里所做的训练就是\", _jsx(_components.strong, {\n          children: \"建立问题分解的思路和培养解决问题的能力\"\n        }), \"。如果想自己尝试，我们也鼓励大家忽略下面的教程，自己动手搞定，遇到不明白的地方可以求助 Google (Bing, Stackoverflow, ...)；但对于这样的简单任务，大语言模型的表现就有些太好了 (请不要用它们！)。完成之后可以看一下实验指南，看自己的理解是否有可以改进的空间。\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果你觉得打印进程树这个问题比较困难，我们也把问题分解一下：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"得到命令行的参数，根据要求设置标志变量的数值；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"得到系统中所有进程的编号 (每个进程都会有唯一的编号) 保存到列表里；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"对列表里的每个编号，得到它的的父亲是谁；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"在内存中把树建好，按命令行参数要求排序；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"把树打印到终端上。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"5.1. 命令行参数\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"main 函数的参数是进程 “初始状态” 的一部分，它是由进程的创建者决定的，操作系统负责把它们放在内存中适当的位置；作为 C 语言的程序员，我们只要直接访问 main 函数的参数即可：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003cstdio.h\u003e\"\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003cassert.h\u003e\"\n          })]\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" argc, \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"char\"\n          }), \" *argv[])\"]\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" i = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"; i \u003c argc; i++) {\\n    assert(argv[i]); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// C 标准保证\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"printf\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"argv[%d] = %s\\\\n\\\"\"\n        }), \", i, argv[i]);\\n  }\\n  assert(!argv[argc]); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// C 标准保证\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"你可以尝试编译运行这个程序，并且这个程序传入不同，并且观察程序的输出。你会确认 \", _jsx(_components.code, {\n        children: \"argv[0], ..., argv[argc-1]\"\n      }), \" 就是所有命令行的参数，这是操作系统与 C 程序之间的约定。getopt (\", _jsx(_components.code, {\n        children: \"man 3 getopt\"\n      }), \") 库可以处理命令行参数；当然，你也可以直接自己动手解析。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"5.2. 开始做实验\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"回想一下大家做 OJ 题的过程。在编程的过程中，难免会经历修改代码 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mo, {\n                  children: \"→\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"\\\\to\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.3669em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"→\"\n            })]\n          })\n        })]\n      }), \" 编译 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mo, {\n                  children: \"→\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"\\\\to\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.3669em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"→\"\n            })]\n          })\n        })]\n      }), \" 运行 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mo, {\n                  children: \"→\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"\\\\to\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.3669em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"→\"\n            })]\n          })\n        })]\n      }), \" 修改代码……这样的循环。你会选择怎么做呢？新手每次都键入命令 (或者他发现 Ctrl-p 可以重复命令)。\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"之后，有同学人发现，可以把命令写在一行里，比如 \", _jsx(_components.code, {\n          children: \"gcc a.c \u0026\u0026 ./a.out\"\n        }), \"，一键就能编译运行了。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"再之后会发现可以写个 Makefile (就像这个实验一样)，用 \", _jsx(_components.code, {\n          children: \"make test\"\n        }), \" 跑完所有测试。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"再之后会发现可以每次在文件改动以后自动运行所有测试……有个神奇的命令叫 \", _jsx(_components.code, {\n          children: \"inotifywait\"\n        }), \" (我们并不推荐)。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"即便现在有 IDE 和丰富的插件，UNIX 哲学依然是无处不在的 (甚至是这些 IDE 的组成基础)，说得更具体一点，“只要你敢想，就一定能做到”。是的，因为之后会反复编译运行这个程序，所以\", _jsx(_components.strong, {\n        children: \"编译和测试自动化\"\n      }), \"非常重要。常见的 C 项目组织是编写 Makefile，在命令行中使用 \", _jsx(_components.code, {\n        children: \"make\"\n      }), \" 实现编译，\", _jsx(_components.code, {\n        children: \"make test\"\n      }), \" 完成测试。我们已经为大家提供了 Makefile，欢迎大家仔细阅读 (但不是强制的)。\"]\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"⚠️\",\n      title: \"请用给定的 Makefile 编译程序\",\n      children: [_jsx(_components.p, {\n        children: \"只有用 make 命令编译，才会留下你的开发历史——实验的编译迟早会复杂到无法 “手工键入命令” 完成。我们非常鼓励你在 IDE (例如 vscode) 中配置好 build script，这样可以一键编译/调试/运行。\"\n      }), _jsxs(_components.p, {\n        children: [\"以下两点有助于调试时放平心态：(1) \", _jsx(_components.strong, {\n          children: \"机器永远是对的\"\n        }), \"；(2) \", _jsx(_components.strong, {\n          children: \"未测代码永远是错的\"\n        }), \"。祝大家编程愉快！\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"5.3. 得到系统中进程的编号\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"进程是操作系统中的对象，因此操作系统一定提供了 API 访问它们。已经剧透过，系统里的\", _jsx(_components.strong, {\n        children: \"每个进程都有唯一的编号\"\n      }), \"，它在 C 语言中的类型是 \", _jsx(_components.code, {\n        children: \"pid_t\"\n      }), \"。不知道这是什么？当然是想办法啦！除了找人工智能 “拿来” 一个答案，在互联网上能找到更权威的定义：glibc 对它的\", _jsx(_components.a, {\n        href: \"https://www.gnu.org/software/libc/manual/html_node/Process-Identification.html\",\n        children: \"官方文档解释\"\n      }), \"。以后遇到问题要自己找答案哦！\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"操作系统以什么样的方式让你获取系统里的进程呢？之前也提示过：\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Everything is a file.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"一切皆文件，进程信息当然也可以是 “一切” 的一部分。Linux 提供了 \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Procfs\",\n        children: \"procfs\"\n      }), \"，目录是 \", _jsx(_components.code, {\n        children: \"/proc\"\n      }), \"。如果你进去看一眼，就会发现除了一些比如 \", _jsx(_components.code, {\n        children: \"cpuinfo\"\n      }), \" 这样的文件，还有很多以数字命名的目录——聪明的你也许已经猜到了，每个目录的名字就是进程号，目录里存储了进程相关的运行时数据。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们鼓励大家先玩一玩 procfs，里面可有很多有趣的东西！你可以用 \", _jsx(_components.code, {\n        children: \"cat\"\n      }), \" 可以打印文件的内容，对照文档 (或者 ChatGPT)，你会发现原来我们以为离我们很遥远的 “观测进程执行”，简单得只要解析文本文件就可以了！例如，每个进程的父进程也隐藏在 \", _jsx(_components.code, {\n        children: \"/proc/[pid]/\"\n      }), \" 中的某个文件里。试试 \", _jsx(_components.code, {\n        children: \"man 5 proc\"\n      }), \"，里面有详细的文档。很多 Online Judge 都使用 procfs 读取进程的运行时间/内存数据。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"5.4. 遍历所有进程\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"了解了 procfs 之后，我们的问题就变得简单一些了：只要能得到 \", _jsx(_components.code, {\n        children: \"/proc\"\n      }), \" 目录下的所有以数字为开头的目录，我们就遍历了系统中的进程。因此你会去互联网上搜索如何用 C 语言遍历目录。之后，你可以用你熟悉的方式打开 procfs 里的文件：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [\"    FILE *fp = fopen(filename, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"r\\\"\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!fp) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"goto\"\n        }), \" release;\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 用fscanf, fgets等函数读取\"\n        }), \"\\n\\nrelease:\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (fp) fclose(fp);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"procfs 里的信息足够让你写一个非常不错的任务管理器。那么，“真正” 的任务管理器，例如 ps 命令，是否也是基于 procfs 实现的呢？这就是一个典型的 “好问题”：他帮助你建立你的实验作业和真实系统之间的联系。操作系统课程也给了大家足够的工具，使得同学们可以把任务管理器打开，查看它调用的操作系统 API。我们在课堂上已经演示过 gcc 和 xedit 的例子，就用 strace 工具就能查看进程运行时的系统调用序列：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ strace ps\\n...\\nopenat(AT_FDCWD, \\\"/proc/1/stat\\\", O_RDONLY)           = 6\\nread(6, \\\"1 (systemd) S 0 1 1 0 -1 4194560\\\"..., 1024) = 190\\nclose(6)                                             = 0\\n...\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"5.5. 建树和打印\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"终于，在得到进程编号 (名字) 和父子关系的基础上，我们就有了一个 “算法题”，它输入由有向边构成的树，要求输出图形化表示的树结构：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"1 2\\n2 3\\n2 4\\n3 5\\n4 6\\n3 7\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我们不妨把有根树理解成一个 “括号序列” (前序遍历)：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"1(2(3(5,7),4(6)),8)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"按照从左到右的顺序，输出每一个节点的编号——需要打印多少空格呢？答案是括号嵌套的深度，我们不妨试试看：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"1\\n  2\\n    3\\n      5\\n      7\\n    4\\n      6\\n  8\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"看起来挺正确的！你就得到了一个 “基本款” 的 pstree。如果你想好看一些，你只要考虑在空间里填上什么样的字符就行了——没错，我们只要 “向左走”，找到它的父亲所在的列 (边向左走边画 “-”)，最后画上垂直的线，我们就得到了树状的结构！\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"1\\n+-2\\n| +-3\\n| | +-5\\n| | +-7\\n| +-4\\n|   +-6\\n+-8\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"看起来不错呢！我们找到问题正确的切入点，就可以简化问题。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"5.6. 写出正确的代码\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"☕️\",\n      title: \"完成了？\",\n      children: _jsx(_components.p, {\n        children: \"是时候问问自己：我的程序对吗？\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"虽然在这个实验里，我们的测试用例相对简单；但在未来的实验中，Online Judge 可能会在各种奇葩的条件下运行你的程序哦！除了你们做的 OJ 题中会有复杂的逻辑 (参数的组合) 导致 bug 之外，和系统打交道的编程可有更多的麻烦之处：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"你的程序遵守 POSIX 的返回值规定吗？如果你的 main 函数返回了非 0 的数值，我们将认为程序报告了错误——在非法的输入上返回 0，以及在合法的输入上返回非 0 都将导致 Wrong Answer。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"程序够 robust 吗？它会不会在一些非法的输入上 crash？如果系统里的进程很多呢？如果内存不够了呢？如果 \", _jsx(_components.code, {\n          children: \"open\"\n        }), \" 或者 \", _jsx(_components.code, {\n          children: \"malloc\"\n        }), \" 失败了呢？要知道，crash 一般是因为 \", _jsx(_components.a, {\n          href: \"https://en.wikipedia.org/wiki/Undefined_behavior\",\n          children: \"undefined behavior (UB)\"\n        }), \" 导致的——UB 没把所有的文件都删掉真是谢天谢地了。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"万一我得到进程号以后，进去发现文件没了 (进程终止了)，怎么办？会不会有这种情况？万一有我的程序会不会 crash……？\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"进程的信息一直在变，文件的内容也一直在变 (两次 \", _jsx(_components.code, {\n          children: \"cat\"\n        }), \" 的结果不同)。那我会不会读到不一致的信息 (前一半是旧信息、新一半是新信息)？这两个问题都是 race condition 导致的；我们将会在并发部分回到这个话题。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如果我不确信这些事会不会发生，我有没有写一个程序，至少在压力环境下测试一下它们有没有可能发生？嗯，如果我同时运行很多程序，每个程序都不断扫描目录、读取文件，也观察不到这个问题，至少应该可以放点心。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"随着课程的深入，这些问题都会得到解答。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当你的程序越来越复杂，这些问题也许将会成为你挥之不去的阴影。这就对了——从 Intel 的 CPU 到 Linux Kernel 都有数不清的 bug。你也许听说过 “形式化验证”，但事实也证明，经过验证正确的编译器 (CertComp) 和操作系统 (seL4, FSCQ, ...) 都依然存在 bug，尽管它们的可靠性依然比程序员手写的高得多。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"写出正确的代码远比想象中困难——目前地球上还没人能保证复杂的系统没有 bug 和漏洞。我们切盼望着没有 bug 的那一天的到来——我们离这个终极的答案似乎越来越近，但依然虚无缥缈。不过也不用太绝望，这门课里会教给大家一些有关 “写代码” 的知识，更重要的是正确的解决问题的思维方式 (“世界观”)。\"\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"思考题：用 Windows 的任务管理器 “画图” 🌶️\",\n      question: \"假设我们在一个完全空载的系统中 (系统中所有的进程都几乎不占用 CPU)。Windows 任务管理器提供 “处理器占用曲线” 的功能；假设系统中只有一个 CPU，如何绘制出正弦波的图案？如果系统中有多个 CPU (例如，64 个)，每个 CPU 都根据占用率的不同显示不同的深浅。我们如何绘制出图片甚至动画？如果系统并不是完全空载，而是有一定的负载，才能 “尽可能” 地绘制出图片或动画 (此时，绘制图片不总是能做到，例如所有 CPU 都满载时，就只能看到全部深色的图案)？在此过程中，你会注意到我们希望操作系统为我们提供一些 API。\",\n      options: ['我想好啦！答案揭晓！'],\n      answer: \"0\",\n      comment: \"\u003cp\u003eGPT-4-turbo 回复：要在Windows任务管理器的“处理器占用曲线”中绘制出正弦波图案或者更复杂的图片甚至动画，我们需要通过编程手段控制CPU的占用率。这个过程大致可以分为以下几个步骤：\u003c/p\u003e \u003ch3\u003e单个CPU绘制正弦波\u003c/h3\u003e \u003col\u003e \u003cli\u003e \u003cp\u003e\u003cstrong\u003e计算正弦波值\u003c/strong\u003e：首先，我们需要一个循环，每次循环计算出一个正弦波的值。这个值将代表CPU的目标占用率。\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003e\u003cstrong\u003e调整CPU占用\u003c/strong\u003e：根据计算出的正弦波值，我们通过编程手段让CPU忙碌或者空闲。例如，如果正弦波的值是高的，我们就让CPU执行一些计算密集型的任务（如计算素数），以增加CPU的占用率；如果正弦波的值是低的，我们就让CPU休息，通过\u003ccode\u003esleep\u003c/code\u003e函数来减少CPU的占用率。\u003c/p\u003e \u003c/li\u003e \u003c/ol\u003e \u003ch3\u003e多个CPU绘制图片或动画\u003c/h3\u003e \u003col\u003e \u003cli\u003e \u003cp\u003e\u003cstrong\u003e分配任务\u003c/strong\u003e：对于多个CPU，我们可以将每个CPU视为画布上的一个像素点，根据每个CPU的占用率来控制该像素点的深浅。因此，我们需要将图片或动画分解为多个像素点，每个点对应一个CPU。\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003e\u003cstrong\u003e并行控制\u003c/strong\u003e：通过多线程或多进程的方式，为每个CPU分配一个独立的任务，根据该CPU对应的像素点的亮度来调整其占用率。亮度高的像素点对应的CPU需要更高的占用率，而亮度低的则相反。\u003c/p\u003e \u003c/li\u003e \u003c/ol\u003e \u003ch3\u003e面对系统负载的挑战\u003c/h3\u003e \u003cp\u003e当系统不是完全空载时，要绘制出准确的图片或动画会更加困难。此时，我们需要操作系统提供的一些API来帮助我们：\u003c/p\u003e \u003col\u003e \u003cli\u003e \u003cp\u003e\u003cstrong\u003e查询CPU占用率\u003c/strong\u003e：我们需要API来实时查询每个CPU的当前占用率，以便我们可以根据实际情况调整我们的控制策略。\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003e\u003cstrong\u003e调整进程优先级\u003c/strong\u003e：通过提高我们控制CPU占用的进程的优先级，尽可能确保我们的进程能够按照预定的计划执行。\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003e\u003cstrong\u003e核心亲和性（Affinity）设置\u003c/strong\u003e：通过设置进程或线程的核心亲和性，确保它们只在特定的CPU上运行，这样可以更精确地控制每个CPU的占用率。\u003c/p\u003e \u003c/li\u003e \u003c/ol\u003e \u003ch3\u003e实现注意事项\u003c/h3\u003e \u003col\u003e \u003cli\u003e \u003cp\u003e\u003cstrong\u003e实时性\u003c/strong\u003e：绘制动画需要高度的实时性，因此需要精心设计你的程序，确保它能够快速响应。\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003e\u003cstrong\u003e系统影响\u003c/strong\u003e：这种方法可能会对系统性能产生影响，特别是在多CPU系统上绘制复杂图片或动画时。\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003e\u003cstrong\u003eAPI选择\u003c/strong\u003e：Windows提供了如\u003ccode\u003eSetThreadAffinityMask\u003c/code\u003e、\u003ccode\u003eSetPriorityClass\u003c/code\u003e等API来帮助控制线程的执行和优先级，这些都是实现上述功能时可能需要用到的。\u003c/p\u003e \u003c/li\u003e \u003c/ol\u003e \u003cp\u003e总之，通过编程手段控制CPU占用率来在任务管理器中绘制图案是一个有趣但挑战性的任务，需要对操作系统的调度机制有深入的理解。\u003c/p\u003e\u003cp\u003ejyy 点评：是不是觉得自己还不如上知天文、下知地理的人工智能？但其实最简单的方法并不是试图 “规划” 好每个 CPU 的利用率，而是直接注入 (可以理解为调试并修改) 任务管理器进程。GPT 还是太善良了。\u003c/p\u003e\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"frontmatter":{"title":"M1: 打印进程树 (pstree)"}},"__N_SSG":true},"page":"/[[...index]]","query":{"index":["OS","2024","labs","M1.md"]},"buildId":"a2FwJzUPGFGc0QcwaUr13","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body>
</html>