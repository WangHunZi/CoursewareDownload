<!DOCTYPE html><html>
<head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>M4: C Read-Eval-Print-Loop (crepl)</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/><link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css"/><meta name="next-head-count" content="5"/><link rel="preload" href="../../../_next/static/css/e993edd6a18ef4f0.css" as="style"/><link rel="stylesheet" href="../../../_next/static/css/e993edd6a18ef4f0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="../../../_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="../../../_next/static/chunks/webpack-f73d82589f972e7d.js" defer=""></script><script src="../../../_next/static/chunks/framework-66d32731bdd20e83.js" defer=""></script><script src="../../../_next/static/chunks/main-3929bf55b0f13a18.js" defer=""></script><script src="../../../_next/static/chunks/pages/_app-00b06920b385caf1.js" defer=""></script><script src="../../../_next/static/chunks/pages/%5b%5b...index%5d%5d-877ec949b69be209.js" defer=""></script><script src="../../../_next/static/a2FwJzUPGFGc0QcwaUr13/_buildManifest.js" defer=""></script><script src="../../../_next/static/a2FwJzUPGFGc0QcwaUr13/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-slate-300/10"><div class="sticky top-0 z-40 w-full backdrop-blur flex-none border-b border-slate-900/10 bg-white/75 supports-backdrop-blur:bg-white/60"><div class="max-w-8xl mx-auto"><div class="py-4 border-b border-slate-900/10 lg:px-8 lg:border-0 dark:border-slate-300/10 mx-4 lg:mx-0"><div class="relative flex items-center"><a href="../../../index.html">Yanyan's wiki</a><form class="text-xs text-slate-500"> for <input type="text" name="token" class="font-mono text-xs w-16" maxLength="8"/></form><div class="relative hidden lg:flex items-center ml-4 pl-4 border-l"><nav class="text-sm leading-6 font-semibold text-slate-700 dark:text-slate-200"><ul class="flex space-x-8"><li><a class="hover:text-sky-500 dark:hover:text-sky-400" href="../../2025/index.html">操作系统 (2025 春)</a></li></ul></nav></div></div></div></div></div><div class="container mx-auto max-w-5xl flex flex-col min-h-screen px-4"><div class="wiki bg-neutral-200/10"><h1>M4: C Read-Eval-Print-Loop (crepl)</h1>
<div class="box yellow-box"><div><span class="float-left text-4xl mr-3 mt-2">⏰</span><span class="font-serif text-lg border-b border-slate-600"><b>Soft Deadline: 2024 年 5 月 19 日 23:59:59</b></span><div class="font-serif pt-2"><p><strong><red>你需要首先阅读<a href="Labs.html">实验须知</a>，其中包含了代码获取方法、提交方法、如何查看提交结果等</red></strong>。在命令行中 <code>git pull origin M4</code> 下载框架代码。</p></div></div></div>
<div class="box slate-box"><div><span class="float-left text-4xl mr-3 mt-2">⚖️</span><span class="font-serif text-lg border-b border-slate-600"><b>M4 - crepl</b></span><div class="font-serif pt-2"><p>请输入 Token 登录。</p></div></div></div>
<h2>1. 背景</h2>
<p>现代编程语言提供交互式语言运行环境 <a href="https://en.wikipedia.org/wiki/Read–eval–print_loop">read-eval-print-loop</a> (REPL): python, node, 就连 Java 都引入了 jshell。例如 Python Shell (以及更方便的 Jupyter Notebook) 可以快速帮助大家解决高等数学作业、高精度计算等烦恼：</p>
<center><p><img src="../../img/python-repl.svg" alt=""/></p></center>
<p>你会预期 C 语言同样也可以实现 “交互式” 的 shell，支持即时定义函数，而且能计算 C 表达式的数值。如果你输入一行代码，比如<code>strlen("Hello World")</code>，这段代码会经历 gcc 编译、动态加载、调用执行，最终把代码执行得到的数值 <code>11</code> 打印到屏幕上。这就是本实验的内容。</p>
<h2>2. 实验描述</h2>
<p><code>crepl</code> - 逐行从 stdin 中输入单行 C 语言代码，并根据输入内容分别处理：</p>
<ul>
<li>如果输入一个 C 函数的定义，则把函数编译并加载到进程的地址空间中；</li>
<li>如果输入是一个 C 语言表达式，则把它的值输出。</li>
</ul>
<h3>总览</h3>
<center>crepl</center>
<h3>描述</h3>
<p>解释执行每一行标准输入中的 C <span class="red">“单行”</span> 代码 (假设我们只使用 <code>int</code> 类型，即所有输入的表达式都是整数；定义函数的返回值也永远是整数)，分如下两种情况：</p>
<h4>(1) 函数</h4>
<p>为了简化实验与操作系统无关的细节，如果输入的字符串 (一行) 以 <code>int</code> 开头，我们就认为它是一个函数。</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> { <span class="hljs-keyword">return</span> (n <= <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>); }
</code></pre>
<p>函数接收若干 <code>int</code> 类型的参数，返回一个 <code>int</code> 数值。如果一行是一个函数，我们希望它将会经过 gcc 编译，并被加载到当前进程的地址空间中。函数可以引用之前定义过的函数。</p>
<h4>(2) 表达式</h4>
<p>如果一行不是以 <code>int</code> 开头，我们就认为这一行是一个 C 语言的<strong>表达式</strong>，其类型为 <code>int</code>，例如</p>
<pre><code class="hljs language-c"><span class="hljs-number">1</span> + <span class="hljs-number">2</span> || (fib(<span class="hljs-number">3</span>) * fib(<span class="hljs-number">4</span>))
</code></pre>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>实验要求：函数和表达式均可以调用之前定义过的函数</b></span><div class="font-serif pt-2"><p>这对于交互式的 C Shell 来说是 “自然” 的需求。我们假设，函数和表达式都不会访问全局的状态 (变量) 或调用任何库函数。如果一行既不是合法的函数 (例如调用了不允许调用的函数)，也不是合法的表达式，<code>crepl</code> 可以不保证它们执行的结果 (不一定要报告错误，例如你的程序依然可以照常编译或执行，但你的程序要尽量不会 crash)；重复定义重名函数你也可以当做 undefined behavior 不必做出过多处理——我们的测试用例中没有这样的情况。</p></div></div></div>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>实现交互式的 REPL</b></span><div class="font-serif pt-2"><p>在本实验中，我们要求你实现交互式的 REPL，即主进程能即时获得所有表达式的值，因此请保证你<strong>在接收到表达式后立即打印，并使用 <code>fflush(stdout)</code> 清空缓冲区</strong>。偷懒的做法是把所有表达式拼接起来成一个程序打印；但本实验中不能这么做。</p></div></div></div>
<p>以下是我们的参考实现：</p>
<center><p><img src="../../img/crepl-demo.gif" alt=""/></p></center>
<p>我们的参考实现调用了 pygments 实现了语法高亮，展示了一种可能性，但你完全没有做这件事情的必要，我们也不鼓励这么做。我们对大家只有最简的实验要求：你只要你为每一个函数或表达式输出一行 (包含结果) 即可，例如你可以把你的 crepl 实现成这样：</p>
<pre><code class="hljs language-text">$ ./crepl-64
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
OK.
gcd(256, 144) * gcd(56, 84)
= 448.
</code></pre>
<p>这个实验表明，编译和解释并没有明确的边界——在 OpenJDK 的实现中，即便是 “解释器” 也是编译的 (只是没有经过优化)。动态 (just-in-time) 技术在程序运行时 (而非程序执行前) 进行编译，并将编译得到的二进制代码 (指令/数据) 动态加载。其中最成功的案例之一是 Sun (现在是 Oracle) 的 Java 虚拟机 <a href="https://wiki.openjdk.java.net/display/HotSpot/Main">HotSpot</a> (现在是OpenJDK的一部分)，它使 Java 彻底摆脱了 “性能低下” 的诟病，也是引领 Web 热潮的核心后端技术。另一个最成功的案例是 JavaScript 的 <a href="https://v8.dev/">V8 引擎</a>。借助 Webkit/v8，Chrome 成功地把微软公司的 Internet Explorer 拖下神坛，并且奠定了 Google 在互联网技术领域的霸主地位。</p>
<h2>3. 正确性标准</h2>
<p>你只要能正确解析单行的函数 (以 <code>int</code> 开头)，并且默认其他输入都是表达式即可。我们可能会输入不合法的 C 代码 (例如不合法的表达式)；你的程序应该给出错误提示而不应该 crash。你可以做出比较友好的假设——不像之前的实验，会为了 “强迫” 你掌握某些知识而使你疯狂 Wrong Answer。这个实验纯属放松，Online Judge 没有刁难你的测试用例，都和 demo 中的差不多。</p>
<ul>
<li>注意我们允许函数和表达式调用之前 (在 crepl 中) 定义过的函数；</li>
<li>你可以假设我们输入的命令/表达式数量不超过 100 个；</li>
<li>注意你处在的运行目录可能没有写入的权限。建议你将创建的临时文件都放在 <code>/tmp/</code> 目录下。建议使用 <code>mkstemp</code> family API 创建临时文件；</li>
<li>主进程确实求出了所有表达式的值。</li>
<li>禁止使用 C 标准库 system 和 popen。这稍稍增加了实验的难度，不过并没有增加多少。请把这个限制理解成强迫大家掌握操作系统知识的训练。</li>
</ul>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>实禁止使用 system() 和 popen()</b></span><div class="font-serif pt-2"><p>为了 “强迫” 大家实现正确的 REPL，调用 system 和 popen 会导致编译错误。好消息是这个实验我们不禁止 <code>exec</code> family 的系统调用：execl, execlp, execle, execv, execvp, execvpe 都是允许的。</p></div></div></div>
<h2>4. 实验指南</h2>
<h3>4.1 解析读入的命令</h3>
<p>框架代码里已经包含了读入命令的循环 (看起来像是一个小 shell)，它打印出一个提示符，然后接受输入并解析：</p>
<pre><code class="hljs language-c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"crepl> "</span>);
    fflush(<span class="hljs-built_in">stdout</span>);

    <span class="hljs-keyword">if</span> (!fgets(line, <span class="hljs-keyword">sizeof</span>(line), <span class="hljs-built_in">stdin</span>)) {
        <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-comment">// To be implemented.</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %zu chars.\n"</span>, <span class="hljs-built_in">strlen</span>(line));
}
</code></pre>
<p>当你在终端里按下 Ctrl-d，会结束 stdin 输入流，fgets 会得到 <code>NULL</code>。</p>
<p>这段代码里一个有趣的小细节是对 fflush 的调用：你会发现把它去掉对程序的运行并没有什么影响。但如果你在 fgets 之前插入一些延迟，例如 <code>sleep(1)</code>，你会发现 fgets 会 flush stdout 的缓冲区。但 C 标准并没有规定这个行为，glibc 只是因为大家用错得太多，为大家贴心地兜了——其实 System 领域这种 “事实行为” 并不少见，大家错得多了，我们的库函数、编译器等不得不做出防御性的行为容忍大家犯错。一个例子是某一时期本的 gcc 会非常激进地对能证明的 undefined behavior 进行优化，但却导致不少以前 “正确” 工作的代码的崩溃，到新版本里反而不再做这些激进的优化了。</p>
<p>回到实验，在上面的代码里，如果读入的字符串以 <code>int</code> 开头，你就可以假设是一个函数；否则就可以假设是一个表达式。</p>
<h3>4.2 把函数编译成共享库</h3>
<p>这个实验最核心的技术处理，就是在程序的外部，通过另一个进程完成一小段代码到二进制代码的编译。对于一个一行的函数，比如：</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> { <span class="hljs-keyword">return</span> b ? gcd(b, a % b) : a; }
</code></pre>
<p>编译器可以将它翻译成如下指令序列：</p>
<pre><code class="hljs language-assembly">   0:    endbr64 
   4:    mov    %edi,%eax
   6:    test   %esi,%esi
   8:    je     13
   a:    cltd   
   b:    idiv   %esi
   d:    mov    %esi,%eax
   f:    mov    %edx,%esi
  11:    jmp    6
  13:    ret    
</code></pre>
<p>我只要试图将这些代码封装在一个动态连接库 (共享库, shared object) 中，这个库就 (gdb 的汇编代码) 就可以被其他程序在运行时加载了。没错，你只需要 <a href="M2.html">M2 (libco)</a> 中的编译选项即可。</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>选取合适的路径和文件名</b></span><div class="font-serif pt-2"><p>如果你的工具在当前目录下创建文件，有可能会失败——例如，你可能在一个没有访问权限的工作目录上 (例如文件系统的根 <code>/</code>)。在 <code>/tmp</code> 中创建临时文件是更安全的做法。此外，glibc 还为我们提供了 <code>mkstemp</code> family API 调用，能够帮助我们生成名称唯一的临时文件。</p></div></div></div>
<p>除了编译和命名的问题，大家可能会感到困惑是，如果我的函数调用了其他函数怎么办？</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> bar() + baz(); }
</code></pre>
<p>你不妨试着编译这个程序……它竟然可以被编译！所以忽略所有的 warnings 就好了！最后，为了巩固大家在上一个实验中学过的知识，我们限制你不能使用 libc 中的 system 和 popen——它们会让实验变得有些过于简单。</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>并不总是可以编译 😂</b></span><div class="font-serif pt-2"><p>有些编译器 (例如 Linux gcc/clang) 会给出一个警告，但警告嘛，我们可以无视。有些编译器的默认行为则是拒绝编译 (例如 macOS clang)。你猜想编译器应该能调控这个行为。于是甚至不用翻手册，AI 就会告诉你 <code>-Wno-implicit-function-declaration</code> 能够绕过这个检查。</p></div></div></div>
<h3>4.3 把表达式编译成共享库</h3>
<p>把函数编译成共享库是常规操作——库函数。但表达式怎么办？又用到我们这门课里反复用的小技巧了：我们可以做一个 wrapper 呀！每当我们收到一个表达式，例如 <code>gcd(256, 144)</code> 的时候，我们都可以 “人工生成” 一段 C 代码</p>
<pre><code class="hljs language-c"><span class="hljs-type">int</span> __expr_wrapper_4() {
    <span class="hljs-keyword">return</span> gcd(<span class="hljs-number">256</span>, <span class="hljs-number">144</span>);
}
</code></pre>
<p>注意到函数名里的数字——我们通过加上数字为表达式生成不一样的名字。我们的表达式变成一个函数，我们就可以把它编译成共享库了。把动态库加载到地址空间并得到 <code>__expr_wrapper_4</code> 的地址，直接进行函数调用就能得到表达式的值了。这是一个小小的 hack——但实际上真正的 REPL 也会用类似的方式处理动态生成的代码：给它一个临时的 “名字”。</p>
<h3>4.4 共享库的加载</h3>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>看看 GPT 是怎么回答的？</b></span><div class="font-serif pt-2"><p>Q: 我有一个 .so 文件。我如何在 C 语言里加载它，并且调用其中定义的函数foo？</p></div></div></div>
<p>GPT-4-turbo 回复 (无删节)：在 C 语言中，你可以使用动态链接库 (Dynamic Linking Library) 的功能来加载 <code>.so</code> 文件并调用其中的函数。<code>.so</code> 文件是在类 Unix 系统 (如 Linux) 中使用的共享库 (Shared Library) 格式。下面是如何在C语言中加载 <code>.so</code> 文件并调用其中的 <code>foo</code> 函数的步骤：</p>
<ol>
<li><strong>包含必要的头文件</strong>：你需要包含 <code><dlfcn.h></code> 头文件，它提供了动态加载库所需的 <code>dlopen</code>、<code>dlsym</code> 和 <code>dlclose</code> 函数。</li>
<li><strong>打开共享库</strong>：使用 <code>dlopen()</code> 函数加载 <code>.so</code> 文件。你需要提供库的路径和加载模式（通常是 <code>RTLD_LAZY</code> 或 <code>RTLD_NOW</code>）。</li>
<li><strong>获取函数指针</strong>：使用 <code>dlsym()</code> 函数获取共享库中函数的地址。你需要提供 <code>dlopen</code> 返回的句柄和函数名。</li>
<li><strong>调用函数</strong>：通过函数指针调用函数。</li>
<li><strong>关闭共享库</strong>：使用 <code>dlclose()</code> 关闭加载的库。</li>
</ol>
<p>下面是一个示例代码，展示如何实现上述步骤：</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string"><stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string"><dlfcn.h></span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">void</span> *handle;
    <span class="hljs-type">void</span> (*foo)(<span class="hljs-type">void</span>);  <span class="hljs-comment">// 假设foo是一个无参数且返回void的函数</span>
    <span class="hljs-type">char</span> *error;

    <span class="hljs-comment">// 打开共享库</span>
    handle = dlopen(<span class="hljs-string">"libfoo.so"</span>, RTLD_LAZY);
    <span class="hljs-keyword">if</span> (!handle) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s\n"</span>, dlerror());
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// 清除现有的错误</span>
    dlerror();

    <span class="hljs-comment">// 获取foo函数的地址</span>
    *(<span class="hljs-type">void</span> **) (&foo) = dlsym(handle, <span class="hljs-string">"foo"</span>);
    <span class="hljs-keyword">if</span> ((error = dlerror()) != <span class="hljs-literal">NULL</span>)  {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s\n"</span>, error);
        dlclose(handle);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// 调用函数</span>
    foo();

    <span class="hljs-comment">// 关闭共享库</span>
    dlclose(handle);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li>确保在调用 <code>dlopen()</code> 时提供正确的库路径。如果库不在标准路径中，你需要提供完整路径。</li>
<li>使用 <code>dlsym()</code> 时，你需要正确地处理类型转换，确保函数指针的类型与实际函数的类型匹配。</li>
<li>在生产环境中，应该检查每个动态链接函数的返回值以确保操作成功。</li>
</ul>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>点评</b></span><div class="font-serif pt-2"><p>AI 生成的代码会给你一种 “我也行” 的错觉——实际上 jyy 在时间压力下，面对必须完成的任务，也经常被迫不加思考地使用 AI 生成的各类代码/命令。但无论如何，在学习阶段，手册都是不可替代的：去读一读 dlopen 相关库函数的手册、elf (5)，“遍历” 式的学习可以让你不仅了解 “这一个知识”，还可以发散地理解与它相关的概念体系。因此，我们不推荐直接让 AI 解决问题。即便你使用了 AI 生成的代码，好好研读和学习也是很有必要的。</p></div></div></div></div></div><div class="bg-neutral-100 text-center text-neutral-600 dark:bg-neutral-600 dark:text-neutral-200 lg:text-left"><div class="bg-neutral-200 p-6 text-center dark:bg-neutral-700"><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons License: BY-NC 4.0</a><br/><a href="https://beian.miit.gov.cn/">苏 ICP 备 2020049101 号</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\",\n    h4: \"h4\",\n    pre: \"pre\",\n    span: \"span\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components), {Box, Submission} = _components;\n  if (!Box) _missingMdxReference(\"Box\", true);\n  if (!Submission) _missingMdxReference(\"Submission\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"M4: C Read-Eval-Print-Loop (crepl)\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⏰\",\n      title: \"Soft Deadline: 2024 年 5 月 19 日 23:59:59\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: _jsxs(\"red\", {\n            children: [\"你需要首先阅读\", _jsx(_components.a, {\n              href: \"Labs.md\",\n              children: \"实验须知\"\n            }), \"，其中包含了代码获取方法、提交方法、如何查看提交结果等\"]\n          })\n        }), \"。在命令行中 \", _jsx(_components.code, {\n          children: \"git pull origin M4\"\n        }), \" 下载框架代码。\"]\n      })\n    }), \"\\n\", _jsx(Submission, {\n      course: \"OS2024\",\n      module: \"M4\",\n      desc: \"M4 - crepl\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 背景\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"现代编程语言提供交互式语言运行环境 \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop\",\n        children: \"read-eval-print-loop\"\n      }), \" (REPL): python, node, 就连 Java 都引入了 jshell。例如 Python Shell (以及更方便的 Jupyter Notebook) 可以快速帮助大家解决高等数学作业、高精度计算等烦恼：\"]\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"../../img/python-repl.svg\",\n          alt: \"\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"你会预期 C 语言同样也可以实现 “交互式” 的 shell，支持即时定义函数，而且能计算 C 表达式的数值。如果你输入一行代码，比如\", _jsx(_components.code, {\n        children: \"strlen(\\\"Hello World\\\")\"\n      }), \"，这段代码会经历 gcc 编译、动态加载、调用执行，最终把代码执行得到的数值 \", _jsx(_components.code, {\n        children: \"11\"\n      }), \" 打印到屏幕上。这就是本实验的内容。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 实验描述\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"crepl\"\n      }), \" - 逐行从 stdin 中输入单行 C 语言代码，并根据输入内容分别处理：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"如果输入一个 C 函数的定义，则把函数编译并加载到进程的地址空间中；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如果输入是一个 C 语言表达式，则把它的值输出。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"总览\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: \"crepl\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"描述\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"解释执行每一行标准输入中的 C \", _jsx(\"span\", {\n        class: \"red\",\n        children: \"“单行”\"\n      }), \" 代码 (假设我们只使用 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 类型，即所有输入的表达式都是整数；定义函数的返回值也永远是整数)，分如下两种情况：\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"(1) 函数\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"为了简化实验与操作系统无关的细节，如果输入的字符串 (一行) 以 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 开头，我们就认为它是一个函数。\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fib\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" n)\"]\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (n \u003c= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") ? \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" : fib(n - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") + fib(n - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"); }\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"函数接收若干 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 类型的参数，返回一个 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 数值。如果一行是一个函数，我们希望它将会经过 gcc 编译，并被加载到当前进程的地址空间中。函数可以引用之前定义过的函数。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"(2) 表达式\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果一行不是以 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 开头，我们就认为这一行是一个 C 语言的\", _jsx(_components.strong, {\n        children: \"表达式\"\n      }), \"，其类型为 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \"，例如\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" || (fib(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \") * fib(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"))\\n\"]\n      })\n    }), \"\\n\", _jsx(Box, {\n      logo: \"🗒️\",\n      title: \"实验要求：函数和表达式均可以调用之前定义过的函数\",\n      children: _jsxs(_components.p, {\n        children: [\"这对于交互式的 C Shell 来说是 “自然” 的需求。我们假设，函数和表达式都不会访问全局的状态 (变量) 或调用任何库函数。如果一行既不是合法的函数 (例如调用了不允许调用的函数)，也不是合法的表达式，\", _jsx(_components.code, {\n          children: \"crepl\"\n        }), \" 可以不保证它们执行的结果 (不一定要报告错误，例如你的程序依然可以照常编译或执行，但你的程序要尽量不会 crash)；重复定义重名函数你也可以当做 undefined behavior 不必做出过多处理——我们的测试用例中没有这样的情况。\"]\n      })\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⚠️\",\n      title: \"实现交互式的 REPL\",\n      children: _jsxs(_components.p, {\n        children: [\"在本实验中，我们要求你实现交互式的 REPL，即主进程能即时获得所有表达式的值，因此请保证你\", _jsxs(_components.strong, {\n          children: [\"在接收到表达式后立即打印，并使用 \", _jsx(_components.code, {\n            children: \"fflush(stdout)\"\n          }), \" 清空缓冲区\"]\n        }), \"。偷懒的做法是把所有表达式拼接起来成一个程序打印；但本实验中不能这么做。\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下是我们的参考实现：\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"../../img/crepl-demo.gif\",\n          alt: \"\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我们的参考实现调用了 pygments 实现了语法高亮，展示了一种可能性，但你完全没有做这件事情的必要，我们也不鼓励这么做。我们对大家只有最简的实验要求：你只要你为每一个函数或表达式输出一行 (包含结果) 即可，例如你可以把你的 crepl 实现成这样：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ ./crepl-64\\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\\nOK.\\ngcd(256, 144) * gcd(56, 84)\\n= 448.\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"这个实验表明，编译和解释并没有明确的边界——在 OpenJDK 的实现中，即便是 “解释器” 也是编译的 (只是没有经过优化)。动态 (just-in-time) 技术在程序运行时 (而非程序执行前) 进行编译，并将编译得到的二进制代码 (指令/数据) 动态加载。其中最成功的案例之一是 Sun (现在是 Oracle) 的 Java 虚拟机 \", _jsx(_components.a, {\n        href: \"https://wiki.openjdk.java.net/display/HotSpot/Main\",\n        children: \"HotSpot\"\n      }), \" (现在是OpenJDK的一部分)，它使 Java 彻底摆脱了 “性能低下” 的诟病，也是引领 Web 热潮的核心后端技术。另一个最成功的案例是 JavaScript 的 \", _jsx(_components.a, {\n        href: \"https://v8.dev/\",\n        children: \"V8 引擎\"\n      }), \"。借助 Webkit/v8，Chrome 成功地把微软公司的 Internet Explorer 拖下神坛，并且奠定了 Google 在互联网技术领域的霸主地位。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 正确性标准\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"你只要能正确解析单行的函数 (以 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 开头)，并且默认其他输入都是表达式即可。我们可能会输入不合法的 C 代码 (例如不合法的表达式)；你的程序应该给出错误提示而不应该 crash。你可以做出比较友好的假设——不像之前的实验，会为了 “强迫” 你掌握某些知识而使你疯狂 Wrong Answer。这个实验纯属放松，Online Judge 没有刁难你的测试用例，都和 demo 中的差不多。\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"注意我们允许函数和表达式调用之前 (在 crepl 中) 定义过的函数；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"你可以假设我们输入的命令/表达式数量不超过 100 个；\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"注意你处在的运行目录可能没有写入的权限。建议你将创建的临时文件都放在 \", _jsx(_components.code, {\n          children: \"/tmp/\"\n        }), \" 目录下。建议使用 \", _jsx(_components.code, {\n          children: \"mkstemp\"\n        }), \" family API 创建临时文件；\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"主进程确实求出了所有表达式的值。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"禁止使用 C 标准库 system 和 popen。这稍稍增加了实验的难度，不过并没有增加多少。请把这个限制理解成强迫大家掌握操作系统知识的训练。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⚠️\",\n      title: \"实禁止使用 system() 和 popen()\",\n      children: _jsxs(_components.p, {\n        children: [\"为了 “强迫” 大家实现正确的 REPL，调用 system 和 popen 会导致编译错误。好消息是这个实验我们不禁止 \", _jsx(_components.code, {\n          children: \"exec\"\n        }), \" family 的系统调用：execl, execlp, execle, execv, execvp, execvpe 都是允许的。\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. 实验指南\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.1 解析读入的命令\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"框架代码里已经包含了读入命令的循环 (看起来像是一个小 shell)，它打印出一个提示符，然后接受输入并解析：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"printf\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"crepl\u003e \\\"\"\n        }), \");\\n    fflush(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"stdout\"\n        }), \");\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!fgets(line, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"sizeof\"\n        }), \"(line), \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"stdin\"\n        }), \")) {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"break\"\n        }), \";\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// To be implemented.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"printf\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Got %zu chars.\\\\n\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"strlen\"\n        }), \"(line));\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当你在终端里按下 Ctrl-d，会结束 stdin 输入流，fgets 会得到 \", _jsx(_components.code, {\n        children: \"NULL\"\n      }), \"。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"这段代码里一个有趣的小细节是对 fflush 的调用：你会发现把它去掉对程序的运行并没有什么影响。但如果你在 fgets 之前插入一些延迟，例如 \", _jsx(_components.code, {\n        children: \"sleep(1)\"\n      }), \"，你会发现 fgets 会 flush stdout 的缓冲区。但 C 标准并没有规定这个行为，glibc 只是因为大家用错得太多，为大家贴心地兜了——其实 System 领域这种 “事实行为” 并不少见，大家错得多了，我们的库函数、编译器等不得不做出防御性的行为容忍大家犯错。一个例子是某一时期本的 gcc 会非常激进地对能证明的 undefined behavior 进行优化，但却导致不少以前 “正确” 工作的代码的崩溃，到新版本里反而不再做这些激进的优化了。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"回到实验，在上面的代码里，如果读入的字符串以 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 开头，你就可以假设是一个函数；否则就可以假设是一个表达式。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.2 把函数编译成共享库\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个实验最核心的技术处理，就是在程序的外部，通过另一个进程完成一小段代码到二进制代码的编译。对于一个一行的函数，比如：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"gcd\"\n        }), _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" a, \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" b)\"]\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" b ? gcd(b, a % b) : a; }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"编译器可以将它翻译成如下指令序列：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-assembly\",\n        children: \"   0:    endbr64 \\n   4:    mov    %edi,%eax\\n   6:    test   %esi,%esi\\n   8:    je     13\\n   a:    cltd   \\n   b:    idiv   %esi\\n   d:    mov    %esi,%eax\\n   f:    mov    %edx,%esi\\n  11:    jmp    6\\n  13:    ret    \\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我只要试图将这些代码封装在一个动态连接库 (共享库, shared object) 中，这个库就 (gdb 的汇编代码) 就可以被其他程序在运行时加载了。没错，你只需要 \", _jsx(_components.a, {\n        href: \"M2.md\",\n        children: \"M2 (libco)\"\n      }), \" 中的编译选项即可。\"]\n    }), \"\\n\", _jsx(Box, {\n      logo: \"☕️\",\n      title: \"选取合适的路径和文件名\",\n      children: _jsxs(_components.p, {\n        children: [\"如果你的工具在当前目录下创建文件，有可能会失败——例如，你可能在一个没有访问权限的工作目录上 (例如文件系统的根 \", _jsx(_components.code, {\n          children: \"/\"\n        }), \")。在 \", _jsx(_components.code, {\n          children: \"/tmp\"\n        }), \" 中创建临时文件是更安全的做法。此外，glibc 还为我们提供了 \", _jsx(_components.code, {\n          children: \"mkstemp\"\n        }), \" family API 调用，能够帮助我们生成名称唯一的临时文件。\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"除了编译和命名的问题，大家可能会感到困惑是，如果我的函数调用了其他函数怎么办？\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"foo\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" bar() + baz(); }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"你不妨试着编译这个程序……它竟然可以被编译！所以忽略所有的 warnings 就好了！最后，为了巩固大家在上一个实验中学过的知识，我们限制你不能使用 libc 中的 system 和 popen——它们会让实验变得有些过于简单。\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"☕️\",\n      title: \"并不总是可以编译 😂\",\n      children: _jsxs(_components.p, {\n        children: [\"有些编译器 (例如 Linux gcc/clang) 会给出一个警告，但警告嘛，我们可以无视。有些编译器的默认行为则是拒绝编译 (例如 macOS clang)。你猜想编译器应该能调控这个行为。于是甚至不用翻手册，AI 就会告诉你 \", _jsx(_components.code, {\n          children: \"-Wno-implicit-function-declaration\"\n        }), \" 能够绕过这个检查。\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.3 把表达式编译成共享库\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"把函数编译成共享库是常规操作——库函数。但表达式怎么办？又用到我们这门课里反复用的小技巧了：我们可以做一个 wrapper 呀！每当我们收到一个表达式，例如 \", _jsx(_components.code, {\n        children: \"gcd(256, 144)\"\n      }), \" 的时候，我们都可以 “人工生成” 一段 C 代码\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" __expr_wrapper_4() {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" gcd(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"256\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"144\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"注意到函数名里的数字——我们通过加上数字为表达式生成不一样的名字。我们的表达式变成一个函数，我们就可以把它编译成共享库了。把动态库加载到地址空间并得到 \", _jsx(_components.code, {\n        children: \"__expr_wrapper_4\"\n      }), \" 的地址，直接进行函数调用就能得到表达式的值了。这是一个小小的 hack——但实际上真正的 REPL 也会用类似的方式处理动态生成的代码：给它一个临时的 “名字”。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.4 共享库的加载\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"☕️\",\n      title: \"看看 GPT 是怎么回答的？\",\n      children: _jsx(_components.p, {\n        children: \"Q: 我有一个 .so 文件。我如何在 C 语言里加载它，并且调用其中定义的函数foo？\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"GPT-4-turbo 回复 (无删节)：在 C 语言中，你可以使用动态链接库 (Dynamic Linking Library) 的功能来加载 \", _jsx(_components.code, {\n        children: \".so\"\n      }), \" 文件并调用其中的函数。\", _jsx(_components.code, {\n        children: \".so\"\n      }), \" 文件是在类 Unix 系统 (如 Linux) 中使用的共享库 (Shared Library) 格式。下面是如何在C语言中加载 \", _jsx(_components.code, {\n        children: \".so\"\n      }), \" 文件并调用其中的 \", _jsx(_components.code, {\n        children: \"foo\"\n      }), \" 函数的步骤：\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"包含必要的头文件\"\n        }), \"：你需要包含 \", _jsx(_components.code, {\n          children: \"\u003cdlfcn.h\u003e\"\n        }), \" 头文件，它提供了动态加载库所需的 \", _jsx(_components.code, {\n          children: \"dlopen\"\n        }), \"、\", _jsx(_components.code, {\n          children: \"dlsym\"\n        }), \" 和 \", _jsx(_components.code, {\n          children: \"dlclose\"\n        }), \" 函数。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"打开共享库\"\n        }), \"：使用 \", _jsx(_components.code, {\n          children: \"dlopen()\"\n        }), \" 函数加载 \", _jsx(_components.code, {\n          children: \".so\"\n        }), \" 文件。你需要提供库的路径和加载模式（通常是 \", _jsx(_components.code, {\n          children: \"RTLD_LAZY\"\n        }), \" 或 \", _jsx(_components.code, {\n          children: \"RTLD_NOW\"\n        }), \"）。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"获取函数指针\"\n        }), \"：使用 \", _jsx(_components.code, {\n          children: \"dlsym()\"\n        }), \" 函数获取共享库中函数的地址。你需要提供 \", _jsx(_components.code, {\n          children: \"dlopen\"\n        }), \" 返回的句柄和函数名。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"调用函数\"\n        }), \"：通过函数指针调用函数。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"关闭共享库\"\n        }), \"：使用 \", _jsx(_components.code, {\n          children: \"dlclose()\"\n        }), \" 关闭加载的库。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"下面是一个示例代码，展示如何实现上述步骤：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003cstdio.h\u003e\"\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"#\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"include\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\u003cdlfcn.h\u003e\"\n          })]\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" *handle;\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" (*foo)(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \");  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 假设foo是一个无参数且返回void的函数\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" *error;\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 打开共享库\"\n        }), \"\\n    handle = dlopen(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"libfoo.so\\\"\"\n        }), \", RTLD_LAZY);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!handle) {\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"fprintf\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"stderr\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"%s\\\\n\\\"\"\n        }), \", dlerror());\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 清除现有的错误\"\n        }), \"\\n    dlerror();\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 获取foo函数的地址\"\n        }), \"\\n    *(\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"void\"\n        }), \" **) (\u0026foo) = dlsym(handle, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"foo\\\"\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" ((error = dlerror()) != \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \")  {\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"fprintf\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"stderr\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"%s\\\\n\\\"\"\n        }), \", error);\\n        dlclose(handle);\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 调用函数\"\n        }), \"\\n    foo();\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 关闭共享库\"\n        }), \"\\n    dlclose(handle);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"注意\"\n      }), \"：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"确保在调用 \", _jsx(_components.code, {\n          children: \"dlopen()\"\n        }), \" 时提供正确的库路径。如果库不在标准路径中，你需要提供完整路径。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"使用 \", _jsx(_components.code, {\n          children: \"dlsym()\"\n        }), \" 时，你需要正确地处理类型转换，确保函数指针的类型与实际函数的类型匹配。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"在生产环境中，应该检查每个动态链接函数的返回值以确保操作成功。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⚠️\",\n      title: \"点评\",\n      children: _jsx(_components.p, {\n        children: \"AI 生成的代码会给你一种 “我也行” 的错觉——实际上 jyy 在时间压力下，面对必须完成的任务，也经常被迫不加思考地使用 AI 生成的各类代码/命令。但无论如何，在学习阶段，手册都是不可替代的：去读一读 dlopen 相关库函数的手册、elf (5)，“遍历” 式的学习可以让你不仅了解 “这一个知识”，还可以发散地理解与它相关的概念体系。因此，我们不推荐直接让 AI 解决问题。即便你使用了 AI 生成的代码，好好研读和学习也是很有必要的。\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"frontmatter":{"title":"M4: C Read-Eval-Print-Loop (crepl)"}},"__N_SSG":true},"page":"/[[...index]]","query":{"index":["OS","2024","labs","M4.md"]},"buildId":"a2FwJzUPGFGc0QcwaUr13","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body>
</html>