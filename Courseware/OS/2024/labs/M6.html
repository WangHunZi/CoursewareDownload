<!DOCTYPE html><html>
<head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>M6: 文件系统格式化恢复 (fsrecov)</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/><link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css"/><meta name="next-head-count" content="5"/><link rel="preload" href="../../../_next/static/css/e993edd6a18ef4f0.css" as="style"/><link rel="stylesheet" href="../../../_next/static/css/e993edd6a18ef4f0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="../../../_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="../../../_next/static/chunks/webpack-f73d82589f972e7d.js" defer=""></script><script src="../../../_next/static/chunks/framework-66d32731bdd20e83.js" defer=""></script><script src="../../../_next/static/chunks/main-3929bf55b0f13a18.js" defer=""></script><script src="../../../_next/static/chunks/pages/_app-00b06920b385caf1.js" defer=""></script><script src="../../../_next/static/chunks/pages/%5b%5b...index%5d%5d-877ec949b69be209.js" defer=""></script><script src="../../../_next/static/a2FwJzUPGFGc0QcwaUr13/_buildManifest.js" defer=""></script><script src="../../../_next/static/a2FwJzUPGFGc0QcwaUr13/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-slate-300/10"><div class="sticky top-0 z-40 w-full backdrop-blur flex-none border-b border-slate-900/10 bg-white/75 supports-backdrop-blur:bg-white/60"><div class="max-w-8xl mx-auto"><div class="py-4 border-b border-slate-900/10 lg:px-8 lg:border-0 dark:border-slate-300/10 mx-4 lg:mx-0"><div class="relative flex items-center"><a href="../../../index.html">Yanyan's wiki</a><form class="text-xs text-slate-500"> for <input type="text" name="token" class="font-mono text-xs w-16" maxLength="8"/></form><div class="relative hidden lg:flex items-center ml-4 pl-4 border-l"><nav class="text-sm leading-6 font-semibold text-slate-700 dark:text-slate-200"><ul class="flex space-x-8"><li><a class="hover:text-sky-500 dark:hover:text-sky-400" href="../../2025/index.html">操作系统 (2025 春)</a></li></ul></nav></div></div></div></div></div><div class="container mx-auto max-w-5xl flex flex-col min-h-screen px-4"><div class="wiki bg-neutral-200/10"><h1>M6: 文件系统格式化恢复 (fsrecov)</h1>
<div class="box yellow-box"><div><span class="float-left text-4xl mr-3 mt-2">⏰</span><span class="font-serif text-lg border-b border-slate-600"><b>Soft Deadline: 同 Hard Deadline</b></span><div class="font-serif pt-2"><p>在命令行中 <code>git pull origin M6</code> 下载框架代码。</p></div></div></div>
<div class="box slate-box"><div><span class="float-left text-4xl mr-3 mt-2">⚖️</span><span class="font-serif text-lg border-b border-slate-600"><b>M6 - fsrecov</b></span><div class="font-serif pt-2"><p>请输入 Token 登录。</p></div></div></div>
<h2>1. 背景</h2>
<p>今天，我们倾向于把重要的文件备份或保存到云端，大大增加了数据的可靠性。但如果你不小心快速格式化了 SD 卡 (现在的相机为了保持兼容性，依然默认是 FAT 文件系统)，文件系统的目录结构被重置，数据块仍然存在，原则上我们可以把数据抢救回来！</p>
<p>想要抢救数据，我们需要理解磁盘是如何格式化的。注意到文件系统是磁盘上的数据结构，如果你希望重置一个数据结构，你就只需要：</p>
<pre><code class="hljs language-c">root->left = root->right = <span class="hljs-literal">NULL</span>;
</code></pre>
<p>数据结构的其他部分也就永久地丢失了——数据结构就完成了一次完美的 “内存泄漏”。当然，因为整个数据结构都被摧毁，你也可以重置内存分配器的状态，这样所有磁盘上的空间就变得可以被分配，磁盘也就 “焕然一新” (被格式化) 了。这解释了为什么 1TB 磁盘的快速格式化瞬间就可以完成。操作系统也提供了多种格式化的选项，包括更安全、也更慢 (更伤存储设备) 覆盖数据的格式化。</p>
<h2>2. 实验描述</h2>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">🗒️</span><span class="font-serif text-lg border-b border-slate-600"><b>实验要求：从快速格式化的 FAT32 文件系统中恢复图片数据</b></span><div class="font-serif pt-2"><p>实现命令行工具 <code>fsrecov</code>，给定一个经过快速格式化 (mkfs.vfat) 的 FAT32 文件系统镜像，镜像格式化前绝大部分文件都是以 BMP 格式存储的，你需要尽可能地从文件系统中恢复出完整的图片文件。</p></div></div></div>
<h3>2.1 总览</h3>
<center>fsrecov <u>FILE</u></center>
<p>FILE 是一个 FAT-32 文件系统的镜像。每恢复一张图片文件 (完整的文件，包含 BMP 头和所有数据)，调用系统中的 <code>sha1sum</code> 命令获得它的校验和，在标准输出中逐行输出图片文件的校验和以及你恢复出的文件名。只有校验和与文件名<strong>都恢复正确且一致</strong>，才被认为正确恢复了一个文件。</p>
<h3>2.2 文件系统</h3>
<p>作为一个 “小实验”，我们对恢复文件的任务作出了一些简化。首先，我们保证我们的文件系统镜像使用如下方法创建的 (主要使用 <code>mkfs.fat</code> 工具):</p>
<p>首先，创建一个空文件 (例如在下面的例子中，文件系统镜像的大小是 64 MiB)，例如：</p>
<pre><code class="hljs language-text">$ cat /dev/zero | head -c $(( 1024 * 1024 * 64 )) > fs.img
</code></pre>
<p>得到 fs.img，然后在这个文件上创建 FAT-32 文件系统：</p>
<pre><code class="hljs language-text">$ mkfs.fat -v -F 32 -S 512 -s 8 fs.img
mkfs.fat 4.2 (2021-01-31)
WARNING: Number of clusters for 32 bit FAT is less then suggested minimum.
fs.img has 8 heads and 32 sectors per track,
hidden sectors 0x0000;
logical sector size is 512,
using 0xf8 media descriptor, with 131072 sectors;
drive number 0x80;
filesystem has 2 32-bit FATs and 8 sectors per cluster.
FAT size is 128 sectors, and provides 16348 clusters.
There are 32 reserved sectors.
Volume ID is 80121567, no volume label.
</code></pre>
<p>注意我们使用的选项：<code>-S 512</code> 表示 sector 大小是 512, <code>-s 8</code> 表示每个 cluster 有 8 个 sectors。这个信息对大家正确编程非常重要——如果你想偷懒，可以假设我们总是用这种方式创建文件系统镜像 (即硬编码这个信息)，但我们更推荐你阅读手册，写出兼容 FAT 标准的 fsrecov。如果你用 <code>file</code> 命令，可以查看到镜像已经被正确格式化：</p>
<pre><code class="hljs language-text">$ file fs.img
fs.img: DOS/MBR boot sector, code offset 0x58+2, OEM-ID "mkfs.fat", sectors/cluster 8, Media descriptor 0xf8, sectors/track 32, heads 8, sectors 131072 (volumes > 32 MB), FAT (32 bit), sectors/FAT 128, serial number 0x80121567, unlabeled
</code></pre>
<p>我们会挂载这个镜像 (一个空的文件系统)，并在根目录下创建 <code>DCIM</code> 目录。现在仍然有很多相机延续了这个命名习惯。然后我们会在 DCIM 目录中进行很多次如下的文件操作。尽管图片文件分辨率、大小可能不同，但都<strong>保证是真实世界中有意义的图片</strong> (而不是随机数生成器生成的随机数据)：</p>
<ul>
<li>向 DCIM 中复制图片文件 (文件名为大/小写字母和数字、减号、下划线，以 “.bmp” 或 “.BMP” 结尾)</li>
<li>删除 DCIM 中的图片文件</li>
<li>……</li>
<li>(反复操作之后，文件系统中可能存在一些碎片化的情况)</li>
</ul>
<p>操作完成后，我们会 unmount 文件系统镜像，然后再进行一次文件系统的快速格式化，通过使用同样的选项再次调用 <code>mkfs.fat</code>：</p>
<pre><code class="hljs language-text">$ mkfs.fat -v -F 32 -S 512 -s 8 fs.img
</code></pre>
<p>此时的 <code>fs.img</code> 就是你要恢复的文件系统镜像。此外，你可以假设所有的 BMP 文件，都是使用 Python PIL 库创建的 24-bit 位图：</p>
<pre><code>$ file 0M15CwG1yP32UPCp.bmp 
0M15CwG1yP32UPCp.bmp: PC bitmap, Windows 3.x format, 364 x 448 x 24
</code></pre>
<h3>2.2 输出格式</h3>
<p>试图恢复出 DCIM 目录下尽可能多的图片文件。对于每个恢复出的文件，输出一行，第一个字符串是该文件的 SHA1 fingerprint (通过调用系统的 <code>sha1sum</code> 命令得到)，然后可以输出一个或多个空格，接下来输出图片的文件名，例如：</p>
<pre><code class="hljs language-text">d60e7d3d2b47d19418af5b0ba52406b86ec6ef83  0M15CwG1yP32UPCp.bmp
1ab8c4f2e61903ae2a00d0820ea0111fac04d9d3  1yh0sw8n6.bmp
1681e23d7b8bb0b36c399c065514bc04badfde79  2Kbg82NaSqPga.bmp
...
</code></pre>
<h2>3. 正确性标准</h2>
<div class="box red-box"><div><span class="float-left text-4xl mr-3 mt-2">⚠️</span><span class="font-serif text-lg border-b border-slate-600"><b>严格按照要求输出</b></span><div class="font-serif pt-2"><p>只有一行同时包含 40 字节的 sha1sum 之后是文件名，这一行才会被 Online Judge 解析。你的输出中可能带有一些调试信息，我们会忽略它 (不要输出太多调试信息，否则会导致 output limit exceeded)。</p></div></div></div>
<h3>3.1 评测说明</h3>
<p>我们会使用不超过 128 MiB 的镜像文件来测试你的文件，时间限制为 10s。</p>
<ul>
<li>超过 10% 的文件名被恢复正确，可以通过所有 easy test cases；</li>
<li>超过 50% 的文件名被恢复正确，可以通过一个 hard test case；</li>
<li>超过 75% 的文件名和 50% 的图片被恢复正确，可以通过所有 hard test cases。</li>
</ul>
<p>不必把图片恢复任务想象得太困难——大文件在文件系统中是倾向于连续存储的，就像在下面参考镜像的 FAT 表中看到的那样。此外，Online Judge 会把你的输出作为一个 utf-8 字符串进行读取。因此，如果你输出了非法的字符 (例如不经检查地输出恢复的文件名，但其实并不是合法的文件名)，将有可能导致解码失败。因此，你输出时请只保留文件名中的可打印 ASCII 字符。</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>Time Limit Exceeded?</b></span><div class="font-serif pt-2"><p>你的程序可能无法在时限内恢复出所有的图片；首先，你可以在每恢复出一个图片后打印，并 flush stdout (超时的程序会被终止，但只要恢复的文件名/图片正确即判定为正确)。此外，你还可以使用 fork 创建多个进程并行恢复。我们的 Online Judge 有 4 个处理器核心。</p></div></div></div>
<h3>3.2 参考镜像</h3>
<p>我们为大家提供了一个参考文件系统镜像。实际测试的图像来自同一个数据集 (WikiArt)，但我们可能会挑选不同的图片、赋予文件其他的随机名称或改变图像的大小，但所有随机的参数都与我们给出的镜像相同 (例如随机的文件名长度的分布等)。镜像请<a href="https://box.nju.edu.cn/f/66a41ec46a334e8d8203/">点这里下载</a>。</p>
<p>镜像下载完毕后可以直接在文件系统中挂载 (你可能需要 root 权限)，这个镜像文件就成为了文件系统的一部分：</p>
<pre><code class="hljs language-text">$ mount /tmp/fsrecov.img /mnt/
$ tree /mnt/
/mnt
└── DCIM
    ├── 0M15CwG1yP32UPCp.bmp
    ├── 1yh0sw8n6.bmp
    ├── 2Kbg82NaSqPga.bmp
    ...
</code></pre>
<p>你可以查看其中的图片文件，例如 <code>3DhTVVP9avTrH.bmp</code> 是下面的图片：</p>
<center><p><img src="../../img/3DhTVVP9avTrH.webp" alt=""/></p></center>
<p>如果你用二进制工具 (例如我们使用的是 xxd) 查看镜像文件，你能发现正确的 FAT 表，以链表的形式保存了每个图像文件的下一个数据块 (在 FAT 系统中，是 cluster 的编号)：</p>
<pre><code class="hljs language-text">00004000: f8ff ff0f ffff ff0f f8ff ff0f 1720 0000  ............. ..
00004010: 0500 0000 0600 0000 0700 0000 0800 0000  ................
00004020: 0900 0000 0a00 0000 0b00 0000 0c00 0000  ................
00004030: 0d00 0000 0e00 0000 0f00 0000 1000 0000  ................
00004040: 1100 0000 1200 0000 1300 0000 1400 0000  ................
</code></pre>
<p>接下来，你可以模拟 Online Judge 在测试你的代码前所做的操作：使用 <code>mkfs.fat</code> 快速格式化这个磁盘镜像：</p>
<pre><code class="hljs language-text">$ mkfs.fat -v -F 32 -S 512 -s 8 fsrecov.img
mkfs.fat 4.1 (2017-01-24)
WARNING: Not enough clusters for a 32 bit FAT!
/tmp/fsrecov.img has 64 heads and 32 sectors per track,
hidden sectors 0x0000;
logical sector size is 512,
using 0xf8 media descriptor, with 131072 sectors;
drive number 0x80;
filesystem has 2 32-bit FATs and 8 sectors per cluster.
FAT size is 128 sectors, and provides 16348 clusters.
There are 32 reserved sectors.
Volume ID is a332d0ad, no volume label.
</code></pre>
<p>如果你接下来再次挂载这个镜像，将会看到完全空白的目录，仿佛磁盘镜像上的所有文件都被删除了：</p>
<pre><code class="hljs language-text">$ tree /mnt/
/mnt/

0 directories, 0 files
</code></pre>
<p>如果再次查看 <code>fsrecov.img</code> 二进制文件，你会发现分区表已经被 “抹除” 了：</p>
<pre><code class="hljs language-text">00004000: f8ff ff0f ffff ff0f f8ff ff0f 0000 0000  ................
00004010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00004020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00004030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00004040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</code></pre>
<p>虽然操作系统已经看不到磁盘上的文件了，但如果你仔细地搜索 (使用 “查找” 工具) 一下，还是可以发现一些蛛丝马迹：</p>
<pre><code class="hljs language-text">00025ae0: 4250 0043 0070 002e 0062 000f 0089 6d00  BP.C.p...b....m.
00025af0: 7000 0000 ffff ffff ffff 0000 ffff ffff  p...............
00025b00: 0130 004d 0031 0035 0043 000f 0089 7700  .0.M.1.5.C....w.
00025b10: 4700 3100 7900 5000 3300 0000 3200 5500  G.1.y.P.3...2.U.
00025b20: 304d 3135 4357 7e31 424d 5020 0064 2b5a  0M15CW~1BMP .d+Z
00025b30: ac50 ac50 0000 2b5a ac50 6915 3677 0700  .P.P..+Z.Pi.6w..
</code></pre>
<p>这好像以某种格式 (FAT32 的 directory entry) 存储了 “<code>0M15CwG1yP32UPCp.bmp</code>” 相关的信息。此外，bitmap 图片文件的文件头也被完整地在数据区里保留下来：</p>
<pre><code class="hljs language-text">000fb000: 424d 2ecf 0f00 0000 0000 3600 0000 2800  BM........6...(.
000fb010: 0000 0202 0000 9f02 0000 0100 1800 0000  ................
000fb020: 0000 f8ce 0f00 c40e 0000 c40e 0000 0000  ................
000fb030: 0000 0000 0000 7d74 9986 7ba3 6c61 8888  ......}t..{.la..
000fb040: 7ea4 8076 9d84 7ca2 766d 9469 6187 6a64  ~..v..|.vm.ia.jd
</code></pre>
<p>你的 <code>fsrecov</code> 会被调用，运行在这个格式化后的镜像上，然后预期会得到一定的输出：</p>
<pre><code class="hljs language-text">d60e7d3d2b47d19418af5b0ba52406b86ec6ef83  0M15CwG1yP32UPCp.bmp
...
</code></pre>
<p>如果你挂载没有被格式化过的 <code>fsrecov.img</code>，你可以查看所有图片的 sha1sum，从而检查你正确恢复了哪些图片。</p>
<pre><code class="hljs language-text">$ cd /mnt/DCIM && sha1sum *.bmp
d60e7d3d2b47d19418af5b0ba52406b86ec6ef83  0M15CwG1yP32UPCp.bmp
1ab8c4f2e61903ae2a00d0820ea0111fac04d9d3  1yh0sw8n6.bmp
1681e23d7b8bb0b36c399c065514bc04badfde79  2Kbg82NaSqPga.bmp
aabd1ef8a2371dd64fb64fc7f10a0a31047d1023  2pxHTrpI.bmp
...
</code></pre>
<h2>4. 实验指南</h2>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>这个实验的目的</b></span><div class="font-serif pt-2"><p>这是一个阅读手册的训练。你可以使用传统的方法 (直接阅读)，或是使用 AI Copilot 的方式。FAT32 手册体量不大，精读手册也在你的掌控范围，这将会给你未来克服 “阅读更长的手册” 的恐惧打下良好的基础。</p></div></div></div>
<h3>4.1 格式化数据恢复</h3>
<p>如果数据结构的格式化使用：</p>
<pre><code class="hljs language-c">root->left = root->right = <span class="hljs-literal">NULL</span>;
</code></pre>
<p>那么，undelete 就只要找回两个指针，整个二叉树就全都回来了 (假设其他部分的数据没有被覆盖掉)：</p>
<pre><code class="hljs language-c">root->left = find_left();
root->right = find_right();
</code></pre>
<p>“删除” 总是相当危险的操作。在某个月黑风高的夜晚修改了代码，以为 <code>OBJ_DIR</code> 这个变量不再使用，遂删除。结果没有料到，Makefile 里还有这么一手：</p>
<pre><code>clean:
    rm -rf ... $(OBJ_DIR)/* ...
</code></pre>
<p>在另一个月黑风高的夜晚，<code>make clean</code> 之后，<code>rm -rf /*</code> 开始了……每个人 (包括 jyy) 都有过在脑抽的时候误删过文件的经历。那可真是相当惨痛的经历——类似的还有把重要数据保存在优盘上，然后文件系统发生了损坏……当然，数据其实并没有从存储器上消失，因此如果有数据恢复的软件，那真是救命了！</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2">☕️</span><span class="font-serif text-lg border-b border-slate-600"><b>保护好你的数据</b></span><div class="font-serif pt-2"><p>自从用上了 git、养成按时 git push 的习惯之后，重要数据的损失就降低到最小了——至少可以保证在任何时候，如果瞬间某台电脑彻底损坏，损失的工作量不会超过几个小时。每当 git push 成功以后，心里都会觉得很踏实。你在 809 的门上看到：</p><center><img src="../../img/git-fire.webp" alt=""/></center><p>此外，现在的网络云盘也会保留一定的编辑历史。“保存历史版本” 其实是一个相当自然、符合直觉的设计。当然，未来也许所有服务都在云端，我们也再也不用担心数据的丢失。</p></div></div></div>
<p>数据对每个人来说都是非常宝贵的。在数码相机等设备的存储卡中，FAT (exFAT) 这样的文件系统依然广泛使用。再加上 “追加写入” 的特点，大部分照片是直接连续存储在存储卡中，也意味着相片是相对更容易恢复的。如果你不小心删除了一整天拍摄的照片，当你恢复出它们的时候，一定感受到文件系统设计者的不杀之恩。但同时，这也意味着不法分子有了可乘之机。文件系统中总有一些你不想让别人看到的文件——你不仅想在文件系统中删除它，还希望别人即便拿到你的磁盘做数据恢复，也不能恢复出文件的内容：明文存放了各大网站密码的文件、不能见人的照片……别有用心的人用 “修电脑” 摧毁了冠希哥和一众演艺界明星的事业和生活。格式化过的 SD 卡、恢复出厂设置的手机，都可能是不法分子敲诈勒索的筹码。幸运的是，随着文件系统加密(在文件系统层写入数据前即执行数据的加密)的普及，大家越来越不用担心这些问题了。</p>
<div class="box purple-box"><div><span class="float-left text-4xl mr-3 mt-2">💡</span><span class="font-serif text-lg border-b border-slate-600"><b>文件粉碎</b></span><div class="font-serif pt-2"><div class="py-1">有些系统软件提供了 “文件粉碎” 的功能。文件粉碎的一个实现方法是用覆盖写的方式把文件的数据清除 (即找到磁盘上所有存储了该文件数据的块，并且向块内写入随机数据)，然后再删除。今天的 SSD FTL 可以在逻辑上把数据块标记为可用，实现快速的格式化和逻辑上的全盘擦除。</div><ol class="quiz-card p-0 ml-8 my-1"></ol></div></div></div>
<h3>4.2 FAT32 文件系统</h3>
<p>我们提供了一份 <a href="../../manuals/MSFAT-spec.pdf">Microsoft FAT Specification</a> 的 local copy。此外，参考代码也展示了如何遍历文件系统。但我们<red>强烈建议大家不要复制其中的代码而是自己编写</red>，以得到最好的训练。</p>
<div class="box blue-box"><div><span class="float-left text-4xl mr-3 mt-2"><button class="hover:bg-blue-300 text-white font-bold px-2 rounded"><img class="w-10" src="../../img/vscode.svg"/></button></span><span class="font-serif text-lg border-b border-slate-600"><b></b></span><div class="font-serif pt-2"><div></div></div></div></div>
<p>FAT 文件系统是由一些头部信息 (元数据)、FAT (文件分配表) 和数据 (cluster, 微软的官方翻译是 “簇”) 组成的。如果你做一些分析，你会知道：</p>
<ol>
<li>FAT 文件的头部是可用的——我们用同样的方式进行两次格式化；</li>
<li>FAT 表将被清空，此部分的数据相当于全部丢失；</li>
<li>数据区几乎没有变化——我们执行的是 “快速” 格式化。</li>
</ol>
<p>接下来，你就可以开始照抄手册，进行 FAT 文件系统的解析了，例如手册已经详细地规定好了 FAT32 文件系统前 512 个字节的格式，我们也在框架代码中提供了 fat32.h:</p>
<pre><code class="hljs language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fat32hdr</span> {</span>
    u8  BS_jmpBoot[<span class="hljs-number">3</span>];
    u8  BS_OEMName[<span class="hljs-number">8</span>];
    u16 BPB_BytsPerSec;
    u8  BPB_SecPerClus;
    ...
    u8  __padding_1[<span class="hljs-number">420</span>];
    u16 Signature_word;
} __attribute__((packed));
</code></pre>
<p>你可以自己动手做一些实验 (用我们下发的镜像，或是自己动手创建镜像)，看看能不能在文件系统中找到一些有用的数据。虽然真实的文件系统存储在磁盘 (块设备) 上，但当我们完成 mmap 以后，它就真的是一个内存里的数据结构了，除了有些 “指针” 需要经过额外的计算才能得到它指向的地址。</p>
<h3>4.3 BMP 文件格式</h3>
<p>为了完成实验，你还需要了解 BMP 文件的格式，请大家独立完成 BMP 文件格式的理解。好消息是这部分你们需要查阅的资料很简单，由于我们的 BMP 都是以同样的方式创建的，你可以忽略其中大部分的 fields，只需关注：</p>
<ol>
<li>bitmap 存储区域开始的 offset；</li>
<li>图片的宽度和高度。</li>
</ol>
<p>互联网上也有充足的资料帮助我们理解：</p>
<p><img src="../../img/bitmap-format.webp" alt=""/></p>
<center>(希望以后 AI 能够创造更多这样的内容)</center>
<h3>4.4 扫描 Clusters</h3>
<p>在你对 FAT32 文件系统有了足够的认识以后，你会发现在我们的问题中，数据区的 clusters 分成以下几种情况：</p>
<ol>
<li>目录文件，存储若干目录项 (directory entry)，对应手册 Sections 6 和 7 描述的内容。注意 Section 7 是非常重要的，因为你必须恢复出完整的文件名；</li>
<li>BMP 文件的头部，以 “<code>424d</code> (<code>BM</code>)” 开头；</li>
<li>BMP 文件的实际数据，按照 3 字节一组按顺序存储了图片中的所有像素；</li>
<li>未使用的 cluster。</li>
</ol>
<p>在 FAT 表被清除后，我们已经无法根据 FAT 恢复出目录的树状结构了。因此接下来我们要做的是一个分类问题：我们需要依次扫描磁盘中的所有 clusters，并将它们标记为以上 4 类。你不需要使用任何机器学习——你可以手工硬编码一些特征，就足够完成识别了，例如目录文件里总是包含大量的 “BMP” 字符，这是数据和 bitmap 文件头所没有的。你不需要做得 100% 准确，因为你只要恢复相当一部分文件即可；但你要小心地编写健壮的代码，使得分类错误发生时程序不会发生太大的问题——你的程序可能在分类错误时 (例如将位图数据解析为目录时) 因为非法的输入而 crash。</p>
<h3>4.5 图片数据恢复</h3>
<p>接下来，你需要的是恢复目录文件中的目录项，从而得到文件名。手册上对目录文件中的目录项给出了精确的定义。当你需要写代码解析文件时，手册就比 blog posts 靠谱得多了。在这里，你要小心目录项可能跨过 cluster 的情况——当然简单起见，你可以放弃这个文件的恢复，只要你的程序不会因此 crash 就行。</p>
<p><img src="../../img/fat-filename.webp" alt=""/></p>
<p>当你恢复出一个目录项以后，你不仅得到了正确的文件名，而且得到了一个非常有用的信息：这个文件名对应的 cluster ID，你根据这个块的编号就可以找到一个保证是 BMP header 的 cluster——你可以和你在扫描 clusters 时的分类结果进行匹配，如果这个 cluster 不是一个 bitmap header，你可能需要放弃这个文件的恢复。</p>
<p>接下来剩下的工作就是恢复图片的剩下部分了！最简单地，你可以假设图片剩下的部分 (clusters) 都连续地存储在文件中。因此你只要正确知道文件的大小 (这个信息在目录项中也有)，你就可以直接恢复出一张图片了。</p>
<p>如果想要更进一步，就需要做出一些数学上的分析。我们丢失的是 FAT 表，也就是所有的 “链接” 关系。例如，我们可以把文件恢复建模成一个图问题：</p>
<ul>
<li>建立有向图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">G</span></span></span></span>，其中每一个 cluster 是一个顶点。</li>
<li>对于两个顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>，建立一条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \to v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>，权值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span> 作为同一个文件连续两块的概率。</li>
<li>图中每一条 “概率足够大” 的路径就对应了一个文件。</li>
</ul>
<p>那么，计算机世界如何处理图像呢？一个最基本的想法是<strong>把图片的像素值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.04398em">z</span></span></span></span> 看成是坐标的函数</strong>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">z = f(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.04398em">z</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mclose">)</span></span></span></span>。在此基础上，我们不妨假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.04398em">z</span></span></span></span> 是连续的，从而求它的导数：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>d</mi><mi>z</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>z</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>z</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \frac{dz}{dt} = \frac{\partial z}{\partial x} \frac{dx}{dt} + \frac{\partial z}{\partial y} \frac{dy}{dt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord" style="margin-right:0.05556em">∂</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord" style="margin-right:0.05556em">∂</span><span class="mord mathnormal" style="margin-right:0.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:2.2519em;vertical-align:-0.8804em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord" style="margin-right:0.05556em">∂</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord" style="margin-right:0.05556em">∂</span><span class="mord mathnormal" style="margin-right:0.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>当然，在计算机世界里，只要近似求解即可，实际求的可能是查分。这些想法启发我们设计许多有趣的技术，例如各类卷积核。卷积 (卷积神经网络) 也是掀起深度学习浪潮的幕后英雄。当然，我们不用做得那么复杂，你只要开动脑筋，用启发式的算法去考虑 “哪一块” 更像是 “这一块” 的后继即可，但你逐渐会在更深刻的意义上 (例如卷积神经网络) 上解释你的直觉和算法。</p>
<h3>4.5 计算校验和</h3>
<p>终于，你得到了文件名、文件的大小和文件的所有数据——是时候把它的校验和输出了。在这个实验中，你需要调用外部工具 sha1sum 计算校验和。sha1sum 的命令行工具可以从 stdin (或者文件) 读取数据，然后把 hash digest 输出到标准输出：</p>
<pre><code class="hljs language-text">$ echo "Hello, World" | sha1sum
4ab299c8ad6ed14f31923dd94f8b5f5cb89dfb54  -
</code></pre>
<p>sha1sum 是一种计算字节序列 “指纹” 的算法。指纹 (fingerprint) 也称为校验和 (checksum)，它是一个单向的 hash function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.08125em">H</span></span></span></span>，能把一个很大空间里的字符串映射到很小的空间中 (计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.08125em">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>)，并且目前而言，给定一个 fingerprint 后的字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span></span></span></span>，人类很难计算出一个字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">H(x)=t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.08125em">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span></span></span></span>。指纹能在不传输整个文件的前提下，快速比较两个文件是否相等。除了校验文件的完整性之外，指纹还可以用来做数据的去重——例如大家在即时通信软件中传送文件 (例如 QQ) 时，服务器会用校验和检查是否已经存在文件的副本，如果是就可以立即结束传输 (所以你们在上传一些别人可能已经上传过文件时会出现大文件 “秒传” 的情况)。</p>
<p>如果你不希望在这个实验里重复 pipe-fork-execve 的流程，popen 可以很好地解决这个问题：我们可以把恢复出的图像写入文件系统中的任何位置 (当然是某个临时目录)，然后用 popen 读取 sha1sum 的输出到缓冲区中，然后再将它输出：</p>
<pre><code class="hljs language-c">fp = popen(<span class="hljs-string">"sha1sum /tmp/your-tmp-filename"</span>, <span class="hljs-string">"r"</span>);
panic_on(fp < <span class="hljs-number">0</span>, <span class="hljs-string">"popen"</span>);
<span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">"%s"</span>, buf); <span class="hljs-comment">// Get it!</span>
pclose(fp);
</code></pre>
<h3>4.6 调试你的程序</h3>
<p>这次的程序稍微有些长。你可能需要一些 logging 才能比较好地帮助你完成任务。记录日志时要小心干扰 Online Judge。注意你依然只能编写一个 <code>.c</code> 文件，因此注意你的代码风格，适当地使用 IDE 和代码折叠能最大程度地提高你的编码效率。</p>
<p>除此之外，这个实验中一个常见的问题是你很多时候不知道你的程序 “为什么” 没有恢复出正确的图片——虽然你知道每一个图片的 sha1sum，但这些数值看起来就像是随机的数字，只要你有一个字节的差异，它们就会看起来完全不同。</p>
<p>一个调试的好办法是 “visualization”: 在调试时将恢复出的图片输出到某个目录中，然后直接 “肉眼” 观察恢复的结果，你会发现有些图片得到了正确的恢复，有些则没有。你能解释为什么会看到下面那样错误的图形吗？</p>
<p><img src="../../img/frecov-example.webp" alt=""/></p></div></div><div class="bg-neutral-100 text-center text-neutral-600 dark:bg-neutral-600 dark:text-neutral-200 lg:text-left"><div class="bg-neutral-200 p-6 text-center dark:bg-neutral-700"><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons License: BY-NC 4.0</a><br/><a href="https://beian.miit.gov.cn/">苏 ICP 备 2020049101 号</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    code: \"code\",\n    h2: \"h2\",\n    pre: \"pre\",\n    span: \"span\",\n    h3: \"h3\",\n    strong: \"strong\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    img: \"img\",\n    ol: \"ol\",\n    math: \"math\",\n    semantics: \"semantics\",\n    mrow: \"mrow\",\n    mi: \"mi\",\n    annotation: \"annotation\",\n    mo: \"mo\",\n    mstyle: \"mstyle\",\n    mfrac: \"mfrac\"\n  }, _provideComponents(), props.components), {Box, Submission, Quiz, Demo} = _components;\n  if (!Box) _missingMdxReference(\"Box\", true);\n  if (!Demo) _missingMdxReference(\"Demo\", true);\n  if (!Quiz) _missingMdxReference(\"Quiz\", true);\n  if (!Submission) _missingMdxReference(\"Submission\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"M6: 文件系统格式化恢复 (fsrecov)\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⏰\",\n      title: \"Soft Deadline: 同 Hard Deadline\",\n      children: _jsxs(_components.p, {\n        children: [\"在命令行中 \", _jsx(_components.code, {\n          children: \"git pull origin M6\"\n        }), \" 下载框架代码。\"]\n      })\n    }), \"\\n\", _jsx(Submission, {\n      course: \"OS2024\",\n      module: \"M6\",\n      desc: \"M6 - fsrecov\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 背景\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"今天，我们倾向于把重要的文件备份或保存到云端，大大增加了数据的可靠性。但如果你不小心快速格式化了 SD 卡 (现在的相机为了保持兼容性，依然默认是 FAT 文件系统)，文件系统的目录结构被重置，数据块仍然存在，原则上我们可以把数据抢救回来！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"想要抢救数据，我们需要理解磁盘是如何格式化的。注意到文件系统是磁盘上的数据结构，如果你希望重置一个数据结构，你就只需要：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [\"root-\u003eleft = root-\u003eright = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"数据结构的其他部分也就永久地丢失了——数据结构就完成了一次完美的 “内存泄漏”。当然，因为整个数据结构都被摧毁，你也可以重置内存分配器的状态，这样所有磁盘上的空间就变得可以被分配，磁盘也就 “焕然一新” (被格式化) 了。这解释了为什么 1TB 磁盘的快速格式化瞬间就可以完成。操作系统也提供了多种格式化的选项，包括更安全、也更慢 (更伤存储设备) 覆盖数据的格式化。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 实验描述\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"🗒️\",\n      title: \"实验要求：从快速格式化的 FAT32 文件系统中恢复图片数据\",\n      children: _jsxs(_components.p, {\n        children: [\"实现命令行工具 \", _jsx(_components.code, {\n          children: \"fsrecov\"\n        }), \"，给定一个经过快速格式化 (mkfs.vfat) 的 FAT32 文件系统镜像，镜像格式化前绝大部分文件都是以 BMP 格式存储的，你需要尽可能地从文件系统中恢复出完整的图片文件。\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.1 总览\"\n    }), \"\\n\", _jsxs(\"center\", {\n      children: [\"fsrecov \", _jsx(\"u\", {\n        children: \"FILE\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"FILE 是一个 FAT-32 文件系统的镜像。每恢复一张图片文件 (完整的文件，包含 BMP 头和所有数据)，调用系统中的 \", _jsx(_components.code, {\n        children: \"sha1sum\"\n      }), \" 命令获得它的校验和，在标准输出中逐行输出图片文件的校验和以及你恢复出的文件名。只有校验和与文件名\", _jsx(_components.strong, {\n        children: \"都恢复正确且一致\"\n      }), \"，才被认为正确恢复了一个文件。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.2 文件系统\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"作为一个 “小实验”，我们对恢复文件的任务作出了一些简化。首先，我们保证我们的文件系统镜像使用如下方法创建的 (主要使用 \", _jsx(_components.code, {\n        children: \"mkfs.fat\"\n      }), \" 工具):\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"首先，创建一个空文件 (例如在下面的例子中，文件系统镜像的大小是 64 MiB)，例如：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ cat /dev/zero | head -c $(( 1024 * 1024 * 64 )) \u003e fs.img\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"得到 fs.img，然后在这个文件上创建 FAT-32 文件系统：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ mkfs.fat -v -F 32 -S 512 -s 8 fs.img\\nmkfs.fat 4.2 (2021-01-31)\\nWARNING: Number of clusters for 32 bit FAT is less then suggested minimum.\\nfs.img has 8 heads and 32 sectors per track,\\nhidden sectors 0x0000;\\nlogical sector size is 512,\\nusing 0xf8 media descriptor, with 131072 sectors;\\ndrive number 0x80;\\nfilesystem has 2 32-bit FATs and 8 sectors per cluster.\\nFAT size is 128 sectors, and provides 16348 clusters.\\nThere are 32 reserved sectors.\\nVolume ID is 80121567, no volume label.\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"注意我们使用的选项：\", _jsx(_components.code, {\n        children: \"-S 512\"\n      }), \" 表示 sector 大小是 512, \", _jsx(_components.code, {\n        children: \"-s 8\"\n      }), \" 表示每个 cluster 有 8 个 sectors。这个信息对大家正确编程非常重要——如果你想偷懒，可以假设我们总是用这种方式创建文件系统镜像 (即硬编码这个信息)，但我们更推荐你阅读手册，写出兼容 FAT 标准的 fsrecov。如果你用 \", _jsx(_components.code, {\n        children: \"file\"\n      }), \" 命令，可以查看到镜像已经被正确格式化：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ file fs.img\\nfs.img: DOS/MBR boot sector, code offset 0x58+2, OEM-ID \\\"mkfs.fat\\\", sectors/cluster 8, Media descriptor 0xf8, sectors/track 32, heads 8, sectors 131072 (volumes \u003e 32 MB), FAT (32 bit), sectors/FAT 128, serial number 0x80121567, unlabeled\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们会挂载这个镜像 (一个空的文件系统)，并在根目录下创建 \", _jsx(_components.code, {\n        children: \"DCIM\"\n      }), \" 目录。现在仍然有很多相机延续了这个命名习惯。然后我们会在 DCIM 目录中进行很多次如下的文件操作。尽管图片文件分辨率、大小可能不同，但都\", _jsx(_components.strong, {\n        children: \"保证是真实世界中有意义的图片\"\n      }), \" (而不是随机数生成器生成的随机数据)：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"向 DCIM 中复制图片文件 (文件名为大/小写字母和数字、减号、下划线，以 “.bmp” 或 “.BMP” 结尾)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"删除 DCIM 中的图片文件\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"……\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"(反复操作之后，文件系统中可能存在一些碎片化的情况)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"操作完成后，我们会 unmount 文件系统镜像，然后再进行一次文件系统的快速格式化，通过使用同样的选项再次调用 \", _jsx(_components.code, {\n        children: \"mkfs.fat\"\n      }), \"：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ mkfs.fat -v -F 32 -S 512 -s 8 fs.img\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"此时的 \", _jsx(_components.code, {\n        children: \"fs.img\"\n      }), \" 就是你要恢复的文件系统镜像。此外，你可以假设所有的 BMP 文件，都是使用 Python PIL 库创建的 24-bit 位图：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"$ file 0M15CwG1yP32UPCp.bmp \\n0M15CwG1yP32UPCp.bmp: PC bitmap, Windows 3.x format, 364 x 448 x 24\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2.2 输出格式\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"试图恢复出 DCIM 目录下尽可能多的图片文件。对于每个恢复出的文件，输出一行，第一个字符串是该文件的 SHA1 fingerprint (通过调用系统的 \", _jsx(_components.code, {\n        children: \"sha1sum\"\n      }), \" 命令得到)，然后可以输出一个或多个空格，接下来输出图片的文件名，例如：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"d60e7d3d2b47d19418af5b0ba52406b86ec6ef83  0M15CwG1yP32UPCp.bmp\\n1ab8c4f2e61903ae2a00d0820ea0111fac04d9d3  1yh0sw8n6.bmp\\n1681e23d7b8bb0b36c399c065514bc04badfde79  2Kbg82NaSqPga.bmp\\n...\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 正确性标准\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"⚠️\",\n      title: \"严格按照要求输出\",\n      children: _jsx(_components.p, {\n        children: \"只有一行同时包含 40 字节的 sha1sum 之后是文件名，这一行才会被 Online Judge 解析。你的输出中可能带有一些调试信息，我们会忽略它 (不要输出太多调试信息，否则会导致 output limit exceeded)。\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.1 评测说明\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我们会使用不超过 128 MiB 的镜像文件来测试你的文件，时间限制为 10s。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"超过 10% 的文件名被恢复正确，可以通过所有 easy test cases；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"超过 50% 的文件名被恢复正确，可以通过一个 hard test case；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"超过 75% 的文件名和 50% 的图片被恢复正确，可以通过所有 hard test cases。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不必把图片恢复任务想象得太困难——大文件在文件系统中是倾向于连续存储的，就像在下面参考镜像的 FAT 表中看到的那样。此外，Online Judge 会把你的输出作为一个 utf-8 字符串进行读取。因此，如果你输出了非法的字符 (例如不经检查地输出恢复的文件名，但其实并不是合法的文件名)，将有可能导致解码失败。因此，你输出时请只保留文件名中的可打印 ASCII 字符。\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"☕️\",\n      title: \"Time Limit Exceeded?\",\n      children: _jsx(_components.p, {\n        children: \"你的程序可能无法在时限内恢复出所有的图片；首先，你可以在每恢复出一个图片后打印，并 flush stdout (超时的程序会被终止，但只要恢复的文件名/图片正确即判定为正确)。此外，你还可以使用 fork 创建多个进程并行恢复。我们的 Online Judge 有 4 个处理器核心。\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.2 参考镜像\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们为大家提供了一个参考文件系统镜像。实际测试的图像来自同一个数据集 (WikiArt)，但我们可能会挑选不同的图片、赋予文件其他的随机名称或改变图像的大小，但所有随机的参数都与我们给出的镜像相同 (例如随机的文件名长度的分布等)。镜像请\", _jsx(_components.a, {\n        href: \"https://box.nju.edu.cn/f/66a41ec46a334e8d8203/\",\n        children: \"点这里下载\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"镜像下载完毕后可以直接在文件系统中挂载 (你可能需要 root 权限)，这个镜像文件就成为了文件系统的一部分：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ mount /tmp/fsrecov.img /mnt/\\n$ tree /mnt/\\n/mnt\\n└── DCIM\\n    ├── 0M15CwG1yP32UPCp.bmp\\n    ├── 1yh0sw8n6.bmp\\n    ├── 2Kbg82NaSqPga.bmp\\n    ...\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"你可以查看其中的图片文件，例如 \", _jsx(_components.code, {\n        children: \"3DhTVVP9avTrH.bmp\"\n      }), \" 是下面的图片：\"]\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"../../img/3DhTVVP9avTrH.webp\",\n          alt: \"\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果你用二进制工具 (例如我们使用的是 xxd) 查看镜像文件，你能发现正确的 FAT 表，以链表的形式保存了每个图像文件的下一个数据块 (在 FAT 系统中，是 cluster 的编号)：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"00004000: f8ff ff0f ffff ff0f f8ff ff0f 1720 0000  ............. ..\\n00004010: 0500 0000 0600 0000 0700 0000 0800 0000  ................\\n00004020: 0900 0000 0a00 0000 0b00 0000 0c00 0000  ................\\n00004030: 0d00 0000 0e00 0000 0f00 0000 1000 0000  ................\\n00004040: 1100 0000 1200 0000 1300 0000 1400 0000  ................\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"接下来，你可以模拟 Online Judge 在测试你的代码前所做的操作：使用 \", _jsx(_components.code, {\n        children: \"mkfs.fat\"\n      }), \" 快速格式化这个磁盘镜像：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ mkfs.fat -v -F 32 -S 512 -s 8 fsrecov.img\\nmkfs.fat 4.1 (2017-01-24)\\nWARNING: Not enough clusters for a 32 bit FAT!\\n/tmp/fsrecov.img has 64 heads and 32 sectors per track,\\nhidden sectors 0x0000;\\nlogical sector size is 512,\\nusing 0xf8 media descriptor, with 131072 sectors;\\ndrive number 0x80;\\nfilesystem has 2 32-bit FATs and 8 sectors per cluster.\\nFAT size is 128 sectors, and provides 16348 clusters.\\nThere are 32 reserved sectors.\\nVolume ID is a332d0ad, no volume label.\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果你接下来再次挂载这个镜像，将会看到完全空白的目录，仿佛磁盘镜像上的所有文件都被删除了：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ tree /mnt/\\n/mnt/\\n\\n0 directories, 0 files\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果再次查看 \", _jsx(_components.code, {\n        children: \"fsrecov.img\"\n      }), \" 二进制文件，你会发现分区表已经被 “抹除” 了：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"00004000: f8ff ff0f ffff ff0f f8ff ff0f 0000 0000  ................\\n00004010: 0000 0000 0000 0000 0000 0000 0000 0000  ................\\n00004020: 0000 0000 0000 0000 0000 0000 0000 0000  ................\\n00004030: 0000 0000 0000 0000 0000 0000 0000 0000  ................\\n00004040: 0000 0000 0000 0000 0000 0000 0000 0000  ................\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"虽然操作系统已经看不到磁盘上的文件了，但如果你仔细地搜索 (使用 “查找” 工具) 一下，还是可以发现一些蛛丝马迹：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"00025ae0: 4250 0043 0070 002e 0062 000f 0089 6d00  BP.C.p...b....m.\\n00025af0: 7000 0000 ffff ffff ffff 0000 ffff ffff  p...............\\n00025b00: 0130 004d 0031 0035 0043 000f 0089 7700  .0.M.1.5.C....w.\\n00025b10: 4700 3100 7900 5000 3300 0000 3200 5500  G.1.y.P.3...2.U.\\n00025b20: 304d 3135 4357 7e31 424d 5020 0064 2b5a  0M15CW~1BMP .d+Z\\n00025b30: ac50 ac50 0000 2b5a ac50 6915 3677 0700  .P.P..+Z.Pi.6w..\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"这好像以某种格式 (FAT32 的 directory entry) 存储了 “\", _jsx(_components.code, {\n        children: \"0M15CwG1yP32UPCp.bmp\"\n      }), \"” 相关的信息。此外，bitmap 图片文件的文件头也被完整地在数据区里保留下来：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"000fb000: 424d 2ecf 0f00 0000 0000 3600 0000 2800  BM........6...(.\\n000fb010: 0000 0202 0000 9f02 0000 0100 1800 0000  ................\\n000fb020: 0000 f8ce 0f00 c40e 0000 c40e 0000 0000  ................\\n000fb030: 0000 0000 0000 7d74 9986 7ba3 6c61 8888  ......}t..{.la..\\n000fb040: 7ea4 8076 9d84 7ca2 766d 9469 6187 6a64  ~..v..|.vm.ia.jd\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"你的 \", _jsx(_components.code, {\n        children: \"fsrecov\"\n      }), \" 会被调用，运行在这个格式化后的镜像上，然后预期会得到一定的输出：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"d60e7d3d2b47d19418af5b0ba52406b86ec6ef83  0M15CwG1yP32UPCp.bmp\\n...\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果你挂载没有被格式化过的 \", _jsx(_components.code, {\n        children: \"fsrecov.img\"\n      }), \"，你可以查看所有图片的 sha1sum，从而检查你正确恢复了哪些图片。\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ cd /mnt/DCIM \u0026\u0026 sha1sum *.bmp\\nd60e7d3d2b47d19418af5b0ba52406b86ec6ef83  0M15CwG1yP32UPCp.bmp\\n1ab8c4f2e61903ae2a00d0820ea0111fac04d9d3  1yh0sw8n6.bmp\\n1681e23d7b8bb0b36c399c065514bc04badfde79  2Kbg82NaSqPga.bmp\\naabd1ef8a2371dd64fb64fc7f10a0a31047d1023  2pxHTrpI.bmp\\n...\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. 实验指南\"\n    }), \"\\n\", _jsx(Box, {\n      logo: \"☕️\",\n      title: \"这个实验的目的\",\n      children: _jsx(_components.p, {\n        children: \"这是一个阅读手册的训练。你可以使用传统的方法 (直接阅读)，或是使用 AI Copilot 的方式。FAT32 手册体量不大，精读手册也在你的掌控范围，这将会给你未来克服 “阅读更长的手册” 的恐惧打下良好的基础。\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.1 格式化数据恢复\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果数据结构的格式化使用：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [\"root-\u003eleft = root-\u003eright = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那么，undelete 就只要找回两个指针，整个二叉树就全都回来了 (假设其他部分的数据没有被覆盖掉)：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-c\",\n        children: \"root-\u003eleft = find_left();\\nroot-\u003eright = find_right();\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"“删除” 总是相当危险的操作。在某个月黑风高的夜晚修改了代码，以为 \", _jsx(_components.code, {\n        children: \"OBJ_DIR\"\n      }), \" 这个变量不再使用，遂删除。结果没有料到，Makefile 里还有这么一手：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"clean:\\n    rm -rf ... $(OBJ_DIR)/* ...\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在另一个月黑风高的夜晚，\", _jsx(_components.code, {\n        children: \"make clean\"\n      }), \" 之后，\", _jsx(_components.code, {\n        children: \"rm -rf /*\"\n      }), \" 开始了……每个人 (包括 jyy) 都有过在脑抽的时候误删过文件的经历。那可真是相当惨痛的经历——类似的还有把重要数据保存在优盘上，然后文件系统发生了损坏……当然，数据其实并没有从存储器上消失，因此如果有数据恢复的软件，那真是救命了！\"]\n    }), \"\\n\", _jsxs(Box, {\n      logo: \"☕️\",\n      title: \"保护好你的数据\",\n      children: [_jsx(_components.p, {\n        children: \"自从用上了 git、养成按时 git push 的习惯之后，重要数据的损失就降低到最小了——至少可以保证在任何时候，如果瞬间某台电脑彻底损坏，损失的工作量不会超过几个小时。每当 git push 成功以后，心里都会觉得很踏实。你在 809 的门上看到：\"\n      }), _jsx(\"center\", {\n        children: _jsx(_components.img, {\n          src: \"../../img/git-fire.webp\",\n          alt: \"\"\n        })\n      }), _jsx(_components.p, {\n        children: \"此外，现在的网络云盘也会保留一定的编辑历史。“保存历史版本” 其实是一个相当自然、符合直觉的设计。当然，未来也许所有服务都在云端，我们也再也不用担心数据的丢失。\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"数据对每个人来说都是非常宝贵的。在数码相机等设备的存储卡中，FAT (exFAT) 这样的文件系统依然广泛使用。再加上 “追加写入” 的特点，大部分照片是直接连续存储在存储卡中，也意味着相片是相对更容易恢复的。如果你不小心删除了一整天拍摄的照片，当你恢复出它们的时候，一定感受到文件系统设计者的不杀之恩。但同时，这也意味着不法分子有了可乘之机。文件系统中总有一些你不想让别人看到的文件——你不仅想在文件系统中删除它，还希望别人即便拿到你的磁盘做数据恢复，也不能恢复出文件的内容：明文存放了各大网站密码的文件、不能见人的照片……别有用心的人用 “修电脑” 摧毁了冠希哥和一众演艺界明星的事业和生活。格式化过的 SD 卡、恢复出厂设置的手机，都可能是不法分子敲诈勒索的筹码。幸运的是，随着文件系统加密(在文件系统层写入数据前即执行数据的加密)的普及，大家越来越不用担心这些问题了。\"\n    }), \"\\n\", _jsx(Quiz, {\n      title: \"文件粉碎\",\n      question: \"有些系统软件提供了 “文件粉碎” 的功能。文件粉碎的一个实现方法是用覆盖写的方式把文件的数据清除 (即找到磁盘上所有存储了该文件数据的块，并且向块内写入随机数据)，然后再删除。今天的 SSD FTL 可以在逻辑上把数据块标记为可用，实现快速的格式化和逻辑上的全盘擦除。\",\n      options: []\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.2 FAT32 文件系统\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们提供了一份 \", _jsx(_components.a, {\n        href: \"../../manuals/MSFAT-spec.pdf\",\n        children: \"Microsoft FAT Specification\"\n      }), \" 的 local copy。此外，参考代码也展示了如何遍历文件系统。但我们\", _jsx(\"red\", {\n        children: \"强烈建议大家不要复制其中的代码而是自己编写\"\n      }), \"，以得到最好的训练。\"]\n    }), \"\\n\", _jsx(Demo, {\n      path: \"persist/readfat\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"FAT 文件系统是由一些头部信息 (元数据)、FAT (文件分配表) 和数据 (cluster, 微软的官方翻译是 “簇”) 组成的。如果你做一些分析，你会知道：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"FAT 文件的头部是可用的——我们用同样的方式进行两次格式化；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"FAT 表将被清空，此部分的数据相当于全部丢失；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"数据区几乎没有变化——我们执行的是 “快速” 格式化。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"接下来，你就可以开始照抄手册，进行 FAT 文件系统的解析了，例如手册已经详细地规定好了 FAT32 文件系统前 512 个字节的格式，我们也在框架代码中提供了 fat32.h:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-class\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"struct\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"fat32hdr\"\n          }), \" {\"]\n        }), \"\\n    u8  BS_jmpBoot[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"];\\n    u8  BS_OEMName[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8\"\n        }), \"];\\n    u16 BPB_BytsPerSec;\\n    u8  BPB_SecPerClus;\\n    ...\\n    u8  __padding_1[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"420\"\n        }), \"];\\n    u16 Signature_word;\\n} __attribute__((packed));\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"你可以自己动手做一些实验 (用我们下发的镜像，或是自己动手创建镜像)，看看能不能在文件系统中找到一些有用的数据。虽然真实的文件系统存储在磁盘 (块设备) 上，但当我们完成 mmap 以后，它就真的是一个内存里的数据结构了，除了有些 “指针” 需要经过额外的计算才能得到它指向的地址。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.3 BMP 文件格式\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"为了完成实验，你还需要了解 BMP 文件的格式，请大家独立完成 BMP 文件格式的理解。好消息是这部分你们需要查阅的资料很简单，由于我们的 BMP 都是以同样的方式创建的，你可以忽略其中大部分的 fields，只需关注：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"bitmap 存储区域开始的 offset；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"图片的宽度和高度。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"互联网上也有充足的资料帮助我们理解：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"../../img/bitmap-format.webp\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(\"center\", {\n      children: \"(希望以后 AI 能够创造更多这样的内容)\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.4 扫描 Clusters\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在你对 FAT32 文件系统有了足够的认识以后，你会发现在我们的问题中，数据区的 clusters 分成以下几种情况：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"目录文件，存储若干目录项 (directory entry)，对应手册 Sections 6 和 7 描述的内容。注意 Section 7 是非常重要的，因为你必须恢复出完整的文件名；\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"BMP 文件的头部，以 “\", _jsx(_components.code, {\n          children: \"424d\"\n        }), \" (\", _jsx(_components.code, {\n          children: \"BM\"\n        }), \")” 开头；\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"BMP 文件的实际数据，按照 3 字节一组按顺序存储了图片中的所有像素；\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"未使用的 cluster。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在 FAT 表被清除后，我们已经无法根据 FAT 恢复出目录的树状结构了。因此接下来我们要做的是一个分类问题：我们需要依次扫描磁盘中的所有 clusters，并将它们标记为以上 4 类。你不需要使用任何机器学习——你可以手工硬编码一些特征，就足够完成识别了，例如目录文件里总是包含大量的 “BMP” 字符，这是数据和 bitmap 文件头所没有的。你不需要做得 100% 准确，因为你只要恢复相当一部分文件即可；但你要小心地编写健壮的代码，使得分类错误发生时程序不会发生太大的问题——你的程序可能在分类错误时 (例如将位图数据解析为目录时) 因为非法的输入而 crash。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.5 图片数据恢复\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"接下来，你需要的是恢复目录文件中的目录项，从而得到文件名。手册上对目录文件中的目录项给出了精确的定义。当你需要写代码解析文件时，手册就比 blog posts 靠谱得多了。在这里，你要小心目录项可能跨过 cluster 的情况——当然简单起见，你可以放弃这个文件的恢复，只要你的程序不会因此 crash 就行。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"../../img/fat-filename.webp\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当你恢复出一个目录项以后，你不仅得到了正确的文件名，而且得到了一个非常有用的信息：这个文件名对应的 cluster ID，你根据这个块的编号就可以找到一个保证是 BMP header 的 cluster——你可以和你在扫描 clusters 时的分类结果进行匹配，如果这个 cluster 不是一个 bitmap header，你可能需要放弃这个文件的恢复。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"接下来剩下的工作就是恢复图片的剩下部分了！最简单地，你可以假设图片剩下的部分 (clusters) 都连续地存储在文件中。因此你只要正确知道文件的大小 (这个信息在目录项中也有)，你就可以直接恢复出一张图片了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果想要更进一步，就需要做出一些数学上的分析。我们丢失的是 FAT 表，也就是所有的 “链接” 关系。例如，我们可以把文件恢复建模成一个图问题：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"建立有向图 \", _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"G\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"G\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.6833em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                children: \"G\"\n              })]\n            })\n          })]\n        }), \"，其中每一个 cluster 是一个顶点。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"对于两个顶点 \", _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"u\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"u\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.4306em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                children: \"u\"\n              })]\n            })\n          })]\n        }), \", \", _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"v\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"v\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.4306em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                style: {\n                  marginRight: \"0.03588em\"\n                },\n                children: \"v\"\n              })]\n            })\n          })]\n        }), \"，建立一条边 \", _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsxs(_components.mrow, {\n                  children: [_jsx(_components.mi, {\n                    children: \"u\"\n                  }), _jsx(_components.mo, {\n                    children: \"→\"\n                  }), _jsx(_components.mi, {\n                    children: \"v\"\n                  })]\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"u \\\\to v\"\n                })]\n              })\n            })\n          }), _jsxs(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: [_jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.4306em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                children: \"u\"\n              }), _jsx(_components.span, {\n                className: \"mspace\",\n                style: {\n                  marginRight: \"0.2778em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mrel\",\n                children: \"→\"\n              }), _jsx(_components.span, {\n                className: \"mspace\",\n                style: {\n                  marginRight: \"0.2778em\"\n                }\n              })]\n            }), _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.4306em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                style: {\n                  marginRight: \"0.03588em\"\n                },\n                children: \"v\"\n              })]\n            })]\n          })]\n        }), \"，权值是 \", _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"u\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"u\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.4306em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                children: \"u\"\n              })]\n            })\n          })]\n        }), \"、\", _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"v\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"v\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.4306em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                style: {\n                  marginRight: \"0.03588em\"\n                },\n                children: \"v\"\n              })]\n            })\n          })]\n        }), \" 作为同一个文件连续两块的概率。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"图中每一条 “概率足够大” 的路径就对应了一个文件。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"那么，计算机世界如何处理图像呢？一个最基本的想法是\", _jsxs(_components.strong, {\n        children: [\"把图片的像素值 \", _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"z\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"z\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.4306em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                style: {\n                  marginRight: \"0.04398em\"\n                },\n                children: \"z\"\n              })]\n            })\n          })]\n        }), \" 看成是坐标的函数\"]\n      }), \"，即 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"z\"\n                }), _jsx(_components.mo, {\n                  children: \"=\"\n                }), _jsx(_components.mi, {\n                  children: \"f\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"x\"\n                }), _jsx(_components.mo, {\n                  separator: \"true\",\n                  children: \",\"\n                }), _jsx(_components.mi, {\n                  children: \"y\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"z = f(x, y)\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.4306em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.04398em\"\n              },\n              children: \"z\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.10764em\"\n              },\n              children: \"f\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            }), _jsx(_components.span, {\n              className: \"mpunct\",\n              children: \",\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.1667em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.03588em\"\n              },\n              children: \"y\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            })]\n          })]\n        })]\n      }), \"。在此基础上，我们不妨假设 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mi, {\n                  children: \"z\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"z\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.4306em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.04398em\"\n              },\n              children: \"z\"\n            })]\n          })\n        })]\n      }), \" 是连续的，从而求它的导数：\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsxs(_components.mstyle, {\n                  scriptlevel: \"0\",\n                  displaystyle: \"true\",\n                  children: [_jsxs(_components.mfrac, {\n                    children: [_jsxs(_components.mrow, {\n                      children: [_jsx(_components.mi, {\n                        children: \"d\"\n                      }), _jsx(_components.mi, {\n                        children: \"z\"\n                      })]\n                    }), _jsxs(_components.mrow, {\n                      children: [_jsx(_components.mi, {\n                        children: \"d\"\n                      }), _jsx(_components.mi, {\n                        children: \"t\"\n                      })]\n                    })]\n                  }), _jsx(_components.mo, {\n                    children: \"=\"\n                  }), _jsxs(_components.mfrac, {\n                    children: [_jsxs(_components.mrow, {\n                      children: [_jsx(_components.mi, {\n                        mathvariant: \"normal\",\n                        children: \"∂\"\n                      }), _jsx(_components.mi, {\n                        children: \"z\"\n                      })]\n                    }), _jsxs(_components.mrow, {\n                      children: [_jsx(_components.mi, {\n                        mathvariant: \"normal\",\n                        children: \"∂\"\n                      }), _jsx(_components.mi, {\n                        children: \"x\"\n                      })]\n                    })]\n                  }), _jsxs(_components.mfrac, {\n                    children: [_jsxs(_components.mrow, {\n                      children: [_jsx(_components.mi, {\n                        children: \"d\"\n                      }), _jsx(_components.mi, {\n                        children: \"x\"\n                      })]\n                    }), _jsxs(_components.mrow, {\n                      children: [_jsx(_components.mi, {\n                        children: \"d\"\n                      }), _jsx(_components.mi, {\n                        children: \"t\"\n                      })]\n                    })]\n                  }), _jsx(_components.mo, {\n                    children: \"+\"\n                  }), _jsxs(_components.mfrac, {\n                    children: [_jsxs(_components.mrow, {\n                      children: [_jsx(_components.mi, {\n                        mathvariant: \"normal\",\n                        children: \"∂\"\n                      }), _jsx(_components.mi, {\n                        children: \"z\"\n                      })]\n                    }), _jsxs(_components.mrow, {\n                      children: [_jsx(_components.mi, {\n                        mathvariant: \"normal\",\n                        children: \"∂\"\n                      }), _jsx(_components.mi, {\n                        children: \"y\"\n                      })]\n                    })]\n                  }), _jsxs(_components.mfrac, {\n                    children: [_jsxs(_components.mrow, {\n                      children: [_jsx(_components.mi, {\n                        children: \"d\"\n                      }), _jsx(_components.mi, {\n                        children: \"y\"\n                      })]\n                    }), _jsxs(_components.mrow, {\n                      children: [_jsx(_components.mi, {\n                        children: \"d\"\n                      }), _jsx(_components.mi, {\n                        children: \"t\"\n                      })]\n                    })]\n                  })]\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"\\\\displaystyle \\\\frac{dz}{dt} = \\\\frac{\\\\partial z}{\\\\partial x} \\\\frac{dx}{dt} + \\\\frac{\\\\partial z}{\\\\partial y} \\\\frac{dy}{dt}\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"2.0574em\",\n                verticalAlign: \"-0.686em\"\n              }\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mopen nulldelimiter\"\n              }), _jsx(_components.span, {\n                className: \"mfrac\",\n                children: _jsxs(_components.span, {\n                  className: \"vlist-t vlist-t2\",\n                  children: [_jsxs(_components.span, {\n                    className: \"vlist-r\",\n                    children: [_jsxs(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"1.3714em\"\n                      },\n                      children: [_jsxs(_components.span, {\n                        style: {\n                          top: \"-2.314em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsxs(_components.span, {\n                          className: \"mord\",\n                          children: [_jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"d\"\n                          }), _jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"t\"\n                          })]\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.23em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"frac-line\",\n                          style: {\n                            borderBottomWidth: \"0.04em\"\n                          }\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.677em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsxs(_components.span, {\n                          className: \"mord\",\n                          children: [_jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"d\"\n                          }), _jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            style: {\n                              marginRight: \"0.04398em\"\n                            },\n                            children: \"z\"\n                          })]\n                        })]\n                      })]\n                    }), _jsx(_components.span, {\n                      className: \"vlist-s\",\n                      children: \"​\"\n                    })]\n                  }), _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.686em\"\n                      },\n                      children: _jsx(_components.span, {})\n                    })\n                  })]\n                })\n              }), _jsx(_components.span, {\n                className: \"mclose nulldelimiter\"\n              })]\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"2.0574em\",\n                verticalAlign: \"-0.686em\"\n              }\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mopen nulldelimiter\"\n              }), _jsx(_components.span, {\n                className: \"mfrac\",\n                children: _jsxs(_components.span, {\n                  className: \"vlist-t vlist-t2\",\n                  children: [_jsxs(_components.span, {\n                    className: \"vlist-r\",\n                    children: [_jsxs(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"1.3714em\"\n                      },\n                      children: [_jsxs(_components.span, {\n                        style: {\n                          top: \"-2.314em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsxs(_components.span, {\n                          className: \"mord\",\n                          children: [_jsx(_components.span, {\n                            className: \"mord\",\n                            style: {\n                              marginRight: \"0.05556em\"\n                            },\n                            children: \"∂\"\n                          }), _jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"x\"\n                          })]\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.23em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"frac-line\",\n                          style: {\n                            borderBottomWidth: \"0.04em\"\n                          }\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.677em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsxs(_components.span, {\n                          className: \"mord\",\n                          children: [_jsx(_components.span, {\n                            className: \"mord\",\n                            style: {\n                              marginRight: \"0.05556em\"\n                            },\n                            children: \"∂\"\n                          }), _jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            style: {\n                              marginRight: \"0.04398em\"\n                            },\n                            children: \"z\"\n                          })]\n                        })]\n                      })]\n                    }), _jsx(_components.span, {\n                      className: \"vlist-s\",\n                      children: \"​\"\n                    })]\n                  }), _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.686em\"\n                      },\n                      children: _jsx(_components.span, {})\n                    })\n                  })]\n                })\n              }), _jsx(_components.span, {\n                className: \"mclose nulldelimiter\"\n              })]\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mopen nulldelimiter\"\n              }), _jsx(_components.span, {\n                className: \"mfrac\",\n                children: _jsxs(_components.span, {\n                  className: \"vlist-t vlist-t2\",\n                  children: [_jsxs(_components.span, {\n                    className: \"vlist-r\",\n                    children: [_jsxs(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"1.3714em\"\n                      },\n                      children: [_jsxs(_components.span, {\n                        style: {\n                          top: \"-2.314em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsxs(_components.span, {\n                          className: \"mord\",\n                          children: [_jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"d\"\n                          }), _jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"t\"\n                          })]\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.23em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"frac-line\",\n                          style: {\n                            borderBottomWidth: \"0.04em\"\n                          }\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.677em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsxs(_components.span, {\n                          className: \"mord\",\n                          children: [_jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"d\"\n                          }), _jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"x\"\n                          })]\n                        })]\n                      })]\n                    }), _jsx(_components.span, {\n                      className: \"vlist-s\",\n                      children: \"​\"\n                    })]\n                  }), _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.686em\"\n                      },\n                      children: _jsx(_components.span, {})\n                    })\n                  })]\n                })\n              }), _jsx(_components.span, {\n                className: \"mclose nulldelimiter\"\n              })]\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mbin\",\n              children: \"+\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"2.2519em\",\n                verticalAlign: \"-0.8804em\"\n              }\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mopen nulldelimiter\"\n              }), _jsx(_components.span, {\n                className: \"mfrac\",\n                children: _jsxs(_components.span, {\n                  className: \"vlist-t vlist-t2\",\n                  children: [_jsxs(_components.span, {\n                    className: \"vlist-r\",\n                    children: [_jsxs(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"1.3714em\"\n                      },\n                      children: [_jsxs(_components.span, {\n                        style: {\n                          top: \"-2.314em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsxs(_components.span, {\n                          className: \"mord\",\n                          children: [_jsx(_components.span, {\n                            className: \"mord\",\n                            style: {\n                              marginRight: \"0.05556em\"\n                            },\n                            children: \"∂\"\n                          }), _jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            style: {\n                              marginRight: \"0.03588em\"\n                            },\n                            children: \"y\"\n                          })]\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.23em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"frac-line\",\n                          style: {\n                            borderBottomWidth: \"0.04em\"\n                          }\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.677em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsxs(_components.span, {\n                          className: \"mord\",\n                          children: [_jsx(_components.span, {\n                            className: \"mord\",\n                            style: {\n                              marginRight: \"0.05556em\"\n                            },\n                            children: \"∂\"\n                          }), _jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            style: {\n                              marginRight: \"0.04398em\"\n                            },\n                            children: \"z\"\n                          })]\n                        })]\n                      })]\n                    }), _jsx(_components.span, {\n                      className: \"vlist-s\",\n                      children: \"​\"\n                    })]\n                  }), _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.8804em\"\n                      },\n                      children: _jsx(_components.span, {})\n                    })\n                  })]\n                })\n              }), _jsx(_components.span, {\n                className: \"mclose nulldelimiter\"\n              })]\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mopen nulldelimiter\"\n              }), _jsx(_components.span, {\n                className: \"mfrac\",\n                children: _jsxs(_components.span, {\n                  className: \"vlist-t vlist-t2\",\n                  children: [_jsxs(_components.span, {\n                    className: \"vlist-r\",\n                    children: [_jsxs(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"1.3714em\"\n                      },\n                      children: [_jsxs(_components.span, {\n                        style: {\n                          top: \"-2.314em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsxs(_components.span, {\n                          className: \"mord\",\n                          children: [_jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"d\"\n                          }), _jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"t\"\n                          })]\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.23em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"frac-line\",\n                          style: {\n                            borderBottomWidth: \"0.04em\"\n                          }\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.677em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsxs(_components.span, {\n                          className: \"mord\",\n                          children: [_jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            children: \"d\"\n                          }), _jsx(_components.span, {\n                            className: \"mord mathnormal\",\n                            style: {\n                              marginRight: \"0.03588em\"\n                            },\n                            children: \"y\"\n                          })]\n                        })]\n                      })]\n                    }), _jsx(_components.span, {\n                      className: \"vlist-s\",\n                      children: \"​\"\n                    })]\n                  }), _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.686em\"\n                      },\n                      children: _jsx(_components.span, {})\n                    })\n                  })]\n                })\n              }), _jsx(_components.span, {\n                className: \"mclose nulldelimiter\"\n              })]\n            })]\n          })]\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当然，在计算机世界里，只要近似求解即可，实际求的可能是查分。这些想法启发我们设计许多有趣的技术，例如各类卷积核。卷积 (卷积神经网络) 也是掀起深度学习浪潮的幕后英雄。当然，我们不用做得那么复杂，你只要开动脑筋，用启发式的算法去考虑 “哪一块” 更像是 “这一块” 的后继即可，但你逐渐会在更深刻的意义上 (例如卷积神经网络) 上解释你的直觉和算法。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.5 计算校验和\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"终于，你得到了文件名、文件的大小和文件的所有数据——是时候把它的校验和输出了。在这个实验中，你需要调用外部工具 sha1sum 计算校验和。sha1sum 的命令行工具可以从 stdin (或者文件) 读取数据，然后把 hash digest 输出到标准输出：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-text\",\n        children: \"$ echo \\\"Hello, World\\\" | sha1sum\\n4ab299c8ad6ed14f31923dd94f8b5f5cb89dfb54  -\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"sha1sum 是一种计算字节序列 “指纹” 的算法。指纹 (fingerprint) 也称为校验和 (checksum)，它是一个单向的 hash function \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mi, {\n                  children: \"H\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"H\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6833em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.08125em\"\n              },\n              children: \"H\"\n            })]\n          })\n        })]\n      }), \"，能把一个很大空间里的字符串映射到很小的空间中 (计算 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"H\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"x\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"H(x)\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.08125em\"\n              },\n              children: \"H\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            })]\n          })\n        })]\n      }), \")，并且目前而言，给定一个 fingerprint 后的字符串 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mi, {\n                  children: \"t\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"t\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6151em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"t\"\n            })]\n          })\n        })]\n      }), \"，人类很难计算出一个字符串 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsx(_components.mi, {\n                  children: \"x\"\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"x\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.4306em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            })]\n          })\n        })]\n      }), \" 满足 \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"H\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \"(\"\n                }), _jsx(_components.mi, {\n                  children: \"x\"\n                }), _jsx(_components.mo, {\n                  stretchy: \"false\",\n                  children: \")\"\n                }), _jsx(_components.mo, {\n                  children: \"=\"\n                }), _jsx(_components.mi, {\n                  children: \"t\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"H(x)=t\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.08125em\"\n              },\n              children: \"H\"\n            }), _jsx(_components.span, {\n              className: \"mopen\",\n              children: \"(\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"x\"\n            }), _jsx(_components.span, {\n              className: \"mclose\",\n              children: \")\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mrel\",\n              children: \"=\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2778em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6151em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"t\"\n            })]\n          })]\n        })]\n      }), \"。指纹能在不传输整个文件的前提下，快速比较两个文件是否相等。除了校验文件的完整性之外，指纹还可以用来做数据的去重——例如大家在即时通信软件中传送文件 (例如 QQ) 时，服务器会用校验和检查是否已经存在文件的副本，如果是就可以立即结束传输 (所以你们在上传一些别人可能已经上传过文件时会出现大文件 “秒传” 的情况)。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果你不希望在这个实验里重复 pipe-fork-execve 的流程，popen 可以很好地解决这个问题：我们可以把恢复出的图像写入文件系统中的任何位置 (当然是某个临时目录)，然后用 popen 读取 sha1sum 的输出到缓冲区中，然后再将它输出：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-c\",\n        children: [\"fp = popen(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"sha1sum /tmp/your-tmp-filename\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"r\\\"\"\n        }), \");\\npanic_on(fp \u003c \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"popen\\\"\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"fscanf\"\n        }), \"(fp, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"%s\\\"\"\n        }), \", buf); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Get it!\"\n        }), \"\\npclose(fp);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.6 调试你的程序\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"这次的程序稍微有些长。你可能需要一些 logging 才能比较好地帮助你完成任务。记录日志时要小心干扰 Online Judge。注意你依然只能编写一个 \", _jsx(_components.code, {\n        children: \".c\"\n      }), \" 文件，因此注意你的代码风格，适当地使用 IDE 和代码折叠能最大程度地提高你的编码效率。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"除此之外，这个实验中一个常见的问题是你很多时候不知道你的程序 “为什么” 没有恢复出正确的图片——虽然你知道每一个图片的 sha1sum，但这些数值看起来就像是随机的数字，只要你有一个字节的差异，它们就会看起来完全不同。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一个调试的好办法是 “visualization”: 在调试时将恢复出的图片输出到某个目录中，然后直接 “肉眼” 观察恢复的结果，你会发现有些图片得到了正确的恢复，有些则没有。你能解释为什么会看到下面那样错误的图形吗？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"../../img/frecov-example.webp\",\n        alt: \"\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"frontmatter":{"title":"M6: 文件系统格式化恢复 (fsrecov)"}},"__N_SSG":true},"page":"/[[...index]]","query":{"index":["OS","2024","labs","M6.md"]},"buildId":"a2FwJzUPGFGc0QcwaUr13","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body>
</html>