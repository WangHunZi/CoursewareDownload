<!DOCTYPE html><html class="h-100">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link href="../../../static/css/base.css" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.font.im/css?family=Source+Serif+Pro%7CLato%7CInconsolata" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="../../../static/img/favicon.png" type="image/x-icon">

  <style>
    .font-sans {
      font-family: 'Lato', 'SimHei', 'STHeiti', 'SimHei', 'Serif';
    }
    .font-serif {
      font-family: 'Source Serif Pro', 'Songti SC', 'SimSun', 'Serif', serif;
    }
  </style>
  <link rel="stylesheet" href="../../../static/katex/katex.min.css">
  <script defer src="../../../static/katex/katex.min.js"></script>
  <script defer src="../../../static/katex/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
  <script>
      document.addEventListener("DOMContentLoaded", function() {
          renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            // • rendering keys, e.g.:
            throwOnError : false
          });
      });
  </script>


  

<style>
.article {
  -webkit-hyphens: auto;
}
form {
  margin-block-end: 0;
}
img {
  display: inline-block;
}
code { font-size: 85%; }
pre {
  font-size: 95%;
  line-height: 120%;
}
blockquote {
  font-size: 95%;
}
p {
  font-size: 105%;
  text-indent: 2em;
}
li {
  font-size: 105%;
}
blockquote p {
  text-indent: 0em;
}
.float-right {
  padding-left: 10px;
}
.float-left {
  padding-right: 10px;
}
a {
  color: rgb(29 78 216);
}
strong {
  font-family: 'Lato', 'SimHei', 'STHeiti', 'SimHei', 'Serif';
}
.box        {
  border-radius: 2px; padding: 1px 4px 2px 4px;
  font-family: 'Lato', 'SimHei', 'STHeiti', 'SimHei', 'Serif';
  font-size: 95%;
}
.box-blue,  .badge-primary  { background-color: rgba(66, 139, 202, 0.5); color: #1d4ed8; }
.box-green, .badge-success  { background-color: rgba(92, 184, 92, 0.5);  color: #15803d; }
.box-red,   .badge-danger   { background-color: rgba(217, 83, 79, 0.5);  color: #b91c1c; }
.box-yellow,.badge-warning  { background-color: rgba(240, 173, 78, 0.5); color: #a16207; }
.box-gray   { background-color: #a0a0a0; }

.badge {
  padding: 1 4 1 4;
  display: inline-block;
  border-radius: 0.25rem;
  border: 1px solid;
}
.message p {
  text-indent: 0em;
  margin-top: 1px;
}
.message h1, h2, h3, h4, h5 {
  font-family: 'Lato', 'SimHei', 'STHeiti', 'SimHei', 'Serif';
}
.message h2 {
  font-size: 120%;
  margin-top: 5px;
  margin-bottom: 2px;
}
.message li {
  list-style: disc;
  margin-left: 2em;
}
li > p {
  text-indent: 0em;
}
block-quote h4 {
  float: left;
  display: inline-block;
}
.center {
  display: block;
  margin: auto;
}
hr {
  margin-top: 20px;
  padding-bottom: 20px;
}

.fa-gradient {
	background: -webkit-gradient(linear, left top, left bottom, from(rgb(99, 27, 103)), to(#333));
	-webkit-background-clip: text;
	-webkit-text-fill-color: transparent;
}

</style>


  <title>Lab1: 大整数运算</title>
</head>

<body class="d-flex flex-column h-100">
  
  

<div>

<div class="px-2 py-1 w-full fixed z-50 bg-gradient-to-r from-black via-purple-700 via-purple-500 shadow-lg" style="-webkit-backdrop-filter: saturate(150%) blur(4px); backdrop-filter: saturate(150%) blur(4px)">
  <form>
    <a href="../../../index.html"><span class="text-lg px-2 text-white">Yanyan's Wiki</span></a>
    <a href="../../../OS/2023/index.html"><span class="text-sm px-2 text-white">操作系统 (2023)</span></a>
    <input maxlength="9" id="token-input" class="float-right appearance-none border border-transparent px-2 py-1 w-20 bg-white text-gray-700 placeholder-gray-400 shadow-md rounded text-xs focus:outline-none focus:ring-2 focus:ring-purple-600 focus:border-transparent font-mono" type="text" placeholder="TOKEN" oninput="login();">
  </form>
</div>

<div class="article container mx-auto md:px-8 lg:px-8 xl:px-8 2xl:px-8 shadow-lg border pb-8 pt-10 max-w-screen-md text-justify divide-y-2 divide-white">
  <div><h1 id="lab1" class=" text-2xl mt-2 font-sans">Lab1: 大整数运算</h1>
<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<h4 id="_1" class=" pt-2 pb-2 font-sans float-left text-sm box border mr-1 mt-1 box-blue" style=" padding-bottom: 0;">小实验说明</h4>
<p class=" font-serif my-1">小实验 (Labs) 是 ICS 这门课程里的一些综合编程题，旨在结合课堂知识解决一些实际中的问题。因为问题来自实际，所以有时候未必能立即在课本上找到相关知识的答案，而是需要 “活学活用”。因此，大家需要利用互联网上的知识解决这些问题，但<strong>不要</strong>试图直接搜索这些问题的答案，即便有也不要点进去 (也请自觉不要公开发布答案)。</p>
<p class=" font-serif my-1">Soft deadline: 2020 年 10 月 25 日 23:59:59。</p>
</blockquote>
<h2 id="1" class=" text-xl mt-2 pb-2 font-sans">1. 背景</h2>
<p class=" font-serif my-1">我们在《计算机系统基础》课程中，学习了数据是如何用机器表示的，以及计算机支持的数据的运算。在这个实验中，我们将会灵活地使用这些计算机系统的运算，实现一个非常基础的数学运算，并尝试着做一些性能统计。最后，我们有一个选做的实验帮助大家理解 IEEE754 浮点数的表示和运算。</p>
<h2 id="2" class=" text-xl mt-2 pb-2 font-sans">2. 实验要求</h2>
<h3 id="21" class=" text-lg mt-2 pb-2 font-sans">2.1 实验内容</h3>
<p class=" font-serif my-1">给定 64 位无符号整数 $a$, $b$, $m$ (类型为 <code>uint64_t</code>，即 $1 \le a, b, m < 2^{64}$)。你的任务是求出 $a\times b\pmod m$ 的数值，即最小的非负整数 $t$，满足 $a\times b\equiv t\pmod m$。</p>
<p class=" font-serif my-1">在这个实验中，你的任务是根据你所掌握的知识，实现功能正确的 <code>multimod</code>，并且只使用分支、循环、局部变量 (使用整数的位宽至多为 64-bit，即不得作弊使用 128 位整数)、赋值语句、位运算和加减法。允许定义额外的辅助函数。</p>
<p class=" font-serif my-1">我们允许使用数组，并允许你在全局空间初始化不超过 4 KB 的常量数组。<code>multimod</code> 函数调用时使用栈上的内存不得超过 4 KB。对挑战自己有兴趣的同学可以尝试不使用数组的实现。</p>
<p class=" font-serif my-1">你的代码应当是可移植的：应当同时兼容 32-bit 和 64-bit 系统。我们的框架代码 (和 Online Judge) 会用不同的选项编译 <code>multimod-32</code> 和 <code>multimod-64</code> 两个二进制文件。</p>
<h3 id="22" class=" text-lg mt-2 pb-2 font-sans">2.2 代码获取与提交</h3>
<p class=" font-serif my-1">如果你首次开始《计算机系统基础》Labs 系列实验，请从 Github 获取 ics-workbench:</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>git clone https://github.com/NJU-ProjectN/ics-workbench.git
</code></pre></div>

<p class=" font-serif my-1">进入 <code>ics-workbench</code> 后，在终端中执行 </p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code>git pull origin lab1
</code></pre></div>

<p class=" font-serif my-1">可以获得 <code>multimod</code> 的框架代码。请大家保持在 master 分支完成实验。在 Lab 对应的目录中 <code>make submit</code>。如 Lab1 的工作目录为 <code>multimod/</code>，则在 <code>multimod</code> 目录中执行 <code>make submit</code>。需要设置 <code>STUID</code> (学号) 和 <code>STUNAME</code> (中文姓名) 环境变量。</p>
<p class=" font-serif my-1"><oj-status course="ICS2020" module="Lab1"><div class="divide-y divide-dashed">
    <div class="flex font-semibold">
      ICS2020-Lab1 提交结果
    </div>
    
  </div>
</oj-status></p>
<h3 id="23" class=" text-lg mt-2 pb-2 font-sans">2.3 评分与正确性标准</h3>
<blockquote class=" bg-gray-200 p-2 rounded mb-2 mt-2 mx-4">
<p class=" font-serif my-1">在你提交的代码中，<code>multimod.c</code> 应该只包含 $a\cdot b\bmod m$ 的实现。其他代码 (如测试代码) 请存放在其他文件中，以免因包含禁止的操作被 Online Judge 拒绝。我们会将你的 <code>multimod.c</code> 复制到指定位置。</p>
<p class=" font-serif my-1">我们对禁用的操作 (如乘法和除法) 有一定的检查机制，但不能 100% 确保没有遗漏。请大家自觉遵守题目要求。</p>
</blockquote>
<p class=" font-serif my-1">Labs 完全客观评分；评分方法请阅读<a href="Labs.html" class=" text-amber-900">实验须知</a>。我们的测试用例分为 Easy 和 Hard。对于所有 Easy 测试用例，我们保证 $a, b < 2^{31}$。对于一个额外的 Easy 测试用例，我们保证 $m$ 是 2 的整数次幂——这将会极大简化你的实现。<strong>如果你感到实验很困难 (通常说明你的编程基础不足)，在 Soft Deadline 之前通过 Easy 测试用例能获得本次实验的绝大部分分数。</strong></p>
<h3 id="24" class=" text-lg mt-2 pb-2 font-sans">2.4 常见问题</h3>
<ol class=" list-decimal font-serif">
<li class=" ml-8">请不要修改 “ics-workbench” 的名字。否则将导致 Online Judge 不能识别你的目录。</li>
<li class=" ml-8">如果你的代码中包含乘法或除法指令，Online Judge 将会拒绝你的提交。如果你收到存在 “mul/div” 指令的反馈，你可以使用 binutils 工具集中的 objdump 命令查看编译后文件的二进制代码 (这个命令在整个计算机系统系列的实验中都非常常用)。另一种方法是使用 gcc 的 <code>-S</code> 选项生成汇编代码。</li>
</ol>
<h2 id="3" class=" text-xl mt-2 pb-2 font-sans">3. 实验指南</h2>
<h3 id="31" class=" text-lg mt-2 pb-2 font-sans">3.1 一个错误的实现</h3>
<p class=" font-serif my-1">你很容易写出如下实现：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">multimod</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p class=" font-serif my-1">但这段看起来正常的代码并不能满足实验的要求：使用乘法 (<code>a * b</code>) 计算两个 64 位整数的乘积，只能保留乘积的低 64 位。这意味着我们计算出的是 $$(a\cdot b \bmod 2^{64}) \bmod m;$$你很容易能举出一个反例，使得$$(a\cdot b \bmod 2^{64}) \bmod m \ne a\cdot b \bmod m.$$</p>
<h3 id="32" class=" text-lg mt-2 pb-2 font-sans">3.2 测试建议</h3>
<p class=" font-serif my-1">我们建议大家在开始写满足要求的 lab 代码之前，首先做一个正确且没有任何限制的参考实现——无论是直接用 C/C++ 实现，还是 “作弊” 使用 Python——Python 会容易得多，因为它自带大整数，然后使用 <code>popen</code> 函数可以立即在 C 语言里得到一个保证正确的大整数运算实现。</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">popen</span><span class="p">(</span><span class="s">"python3 -c 'print(10**100 - 1)'"</span><span class="p">,</span><span class="w"> </span><span class="s">"r"</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="n">fscanf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="w"> </span><span class="s">"%s"</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"popen() returns: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span>
<span class="n">pclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
</code></pre></div>

<p class=" font-serif my-1">在有这样一个参考实现之后，你就可以运行大量的测试来确保你的实现没有问题——除了测试一些随机的数据外，你也可以试着测试一些在整数大小边界的数据。此外，你的代码中可能会用到一些辅助函数 (例如乘法等)，你可以把它们的测试像课堂上讲解的 yemu 代码一样做成框架，这能大幅提高你的测试/调试效率。</p>
<h3 id="33-multimod" class=" text-lg mt-2 pb-2 font-sans">3.3 如何实现不用乘除法的 <code>multimod</code>？</h3>
<p class=" font-serif my-1">首先，你会有一个非常坚定的信念：这件事是办得到的。我们已经在《数字逻辑电路》以及《计算机系统基础》课程和习题课中反复强调，我们今天的计算机也不过是用逻辑门电路实现的。因此位运算和分支/循环 (甚至我们还允许使用加减法) 绝对有足够的表达能力实现<strong>任何算法</strong>。因此，大不了我们用逻辑门 (对应着位运算) 搭一个乘法器、除法器，不就行了吗？</p>
<h3 id="33" class=" text-lg mt-2 pb-2 font-sans">3.3 使用位运算实现加法</h3>
<p class=" font-serif my-1">虽然我们的实验允许使用加减法，但你完全可以使用位运算构造加法电路 (直接使用大家学过的数字逻辑电路中的加法器)，例如假设 <code>a</code> 和 <code>b</code> 是两位二进制数，存储在 <code>int</code> 型变量中：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">bit_of</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">>></span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">&</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">full_add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">carry</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">&</span><span class="w"> </span><span class="n">z</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">s0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">full_add</span><span class="p">(</span><span class="n">bit_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">bit_of</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">carry</span><span class="w">   </span><span class="p">(</span><span class="n">bit_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">bit_of</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">full_add</span><span class="p">(</span><span class="n">bit_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">bit_of</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">c0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">carry</span><span class="w">   </span><span class="p">(</span><span class="n">bit_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">bit_of</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">c0</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">c1</span><span class="w"> </span><span class="o"><<</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">s1</span><span class="w"> </span><span class="o"><<</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">s0</span><span class="w"> </span><span class="o"><<</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p class=" font-serif my-1">虽然代码看起来有点笨 (并且能写得更好)，但原理就是如此。顺着这个思路，你可以用加法器实现乘法器/除法器 (当然，除法其实困难得多……)</p>
<h3 id="34-multimod" class=" text-lg mt-2 pb-2 font-sans">3.4 实现 <code>multimod</code></h3>
<p class=" font-serif my-1">盯着 “$a\cdot b \bmod m$” 看是没办法解决问题的。正确的解题方法是把式子写出来，然后尝试做一些公式变形。这个例子里的公式变形是很直观的：
$$a \cdot b = (a_0 \cdot 2^0 + a_1 \cdot 2^1 + \ldots + a_{63} \cdot 2^{63}) \cdot b$$</p>
<p class=" font-serif my-1">对于上面表达式括号中的每一项，都是形如 $2^i \cdot b$ 的形式 (因为 $a_i \in \{0,1\}$)——因此</p>
<p class=" font-serif my-1">$$a \cdot b \bmod m = \left(\sum_{0 \le i < 64} a_i \cdot b \cdot 2^i \bmod m \right) \bmod m$$</p>
<p class=" font-serif my-1">因此，你只要能实现 $\bmod m$ 的加法即 $(x+y)\bmod m$，就能实现 $(b \cdot 2^i) \bmod m$，进而实现 $a\cdot b\bmod m$。在这里你要小心 $x+y$ 溢出 64-bit 整数的问题：当 $x+y = t + 2^{64}$ 发生溢出 ($0 \le t < 2^{64}-1$) 时，注意加法 wraparound 后得到的结果是
$$(x+y) \bmod 2^{64} = t.$$
我们实际需要求解的是
$$(t + 2^{64})\bmod m = \big( (t\bmod m) + (2^{64} \bmod m) \big) \bmod m.$$
这里还有一个潜在的溢出问题——如果这个加法依然溢出怎么办？这个聪明的问题留给你。</p>
<h2 id="4" class=" text-xl mt-2 pb-2 font-sans">4. 补充：一段神秘代码</h2>
<p class=" font-serif my-1">求 $a\cdot b \bmod m$ 是程序设计竞赛中的一个常见操作。在 ICPC 圈子中存在一份广为流传的一段神奇代码，出处和年代太久远已经很难考证 (我们保留了这份代码本来的样子)：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="kt">int64_t</span><span class="w"> </span><span class="nf">multimod_fast</span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)((</span><span class="kt">double</span><span class="p">)</span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o"><</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p class=" font-serif my-1">这段代码直接使用了 <code>a * b</code>，并且直接假设整数溢出时 wraparound (可以通过 <code>-fwrapv</code> 编译选项实现)。然后，这段代码竟然神奇地在 $O(1)$ 的时间里就解决了 $a \cdot b \bmod m$ 的求解？其中最精髓的一段在于：</p>
<div class="codehilite"><pre class=" bg-gray-100 overflow-x-auto rounded p-2 mb-2 mt-2"><span></span><code><span class="p">(</span><span class="kt">int64_t</span><span class="p">)((</span><span class="kt">double</span><span class="p">)</span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
</code></pre></div>

<p class=" font-serif my-1">把整数 <code>a</code> 强行转换成了浮点数 (假设使用 IEEE754 64 位双精度类型)。我们知道浮点数的精度也不是无限的，仅仅类型转换就已经损失精度了 (64 位双精度浮点数只有 52 位有效数字)，<code>double</code> 更不可能准确保存 <code>a * b</code> 的结果。</p>
<p class=" font-serif my-1">如果你对这一段代码有兴趣，请你利用学习过的数据的机器表示知识，理解 <code>multimod_fast</code> 中每一个子表达式的含义，并且分析其正确性 (完全处于自愿目的，不计分，也不需要提交任何代码)。</p></div>
</div>

<div class="container text-xs py-3">
  <span class="text-muted">
    <center><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="../../../static/img/cc-4.0.png"></a>
       <a style="color:inherit" href="https://beian.miit.gov.cn/">苏 ICP 备 2020049101 号</a>
    </center>
  </span>
</div>

</div>

<script src="../../../static/js/jquery.min.js"></script>

<script>
function get_token() {
  var match = document.cookie.match(new RegExp('(^| )token=([^;]+)'));
  if (match) return match[2];
  else return "";
}
var token = get_token();
var hint = "token", box = $("#token-input");

if (token == "") { }
else { box.val(token); }

function login() {
  var token = box.val()
  if (!token) {
    document.cookie = ''
  } else {
    document.cookie = 'token=' + token + '; expires=Fri, 31 Dec 9999 23:59:59 GMT;'
  }
}
</script>


</body>

</html>